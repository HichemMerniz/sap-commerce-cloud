import './polyfills.server.mjs';
import {
  ANONYMOUS_CONSENT_STATUS,
  ActionsSubject,
  ActivatedRoute,
  ActivatedRoutesService,
  AnonymousConsentsConfig,
  AnonymousConsentsService,
  AuthConfigService,
  AuthGuard,
  AuthService,
  BaseCoreModule,
  CURRENCY_CONTEXT_ID,
  CmsConfig,
  CmsService,
  Config,
  ConfigChunk,
  ConfigInitializerService,
  ConfigModule,
  ContainerBackgroundOptions,
  ContextServiceMap,
  CurrencyService,
  CustomerCouponService,
  CxDatePipe,
  CxEvent,
  DEFAULT_URL_MATCHER,
  DefaultConfigChunk,
  DeferLoadingStrategy,
  DynamicAttributeService,
  EMAIL_PATTERN,
  EventService,
  FeatureModulesService,
  GlobalMessageService,
  GlobalMessageType,
  I18nModule,
  LANGUAGE_CONTEXT_ID,
  LanguageService,
  LoggerService,
  MODULE_INITIALIZER,
  NavigationEnd,
  NavigationStart,
  NotificationType,
  OAuthFlow,
  OCC_USER_ID_ANONYMOUS,
  PASSWORD_PATTERN,
  PageMetaModule,
  PageMetaService,
  PageType,
  ProductReferenceService,
  ProductReviewService,
  ProductSearchService,
  ProductService,
  ProtectedRoutesGuard,
  ProtectedRoutesService,
  ROUTER_NAVIGATED,
  Router,
  RouterLink,
  RouterModule,
  RouterOutlet,
  RoutingConfigService,
  RoutingModule,
  RoutingService,
  Scroll,
  ScrollBehavior,
  SearchboxService,
  SemanticPathService,
  SiteContextConfig,
  SiteContextModule,
  THEME_CONTEXT_ID,
  TranslatePipe,
  TranslationChunkService,
  TranslationService,
  UnifiedInjector,
  UrlMatcherService,
  UrlModule,
  UrlPipe,
  UserConsentService,
  UserIdService,
  UserInterestsService,
  UserNotificationPreferenceService,
  UserPaymentService,
  WindowRef,
  createFrom,
  deepMerge,
  getLastValueSync,
  isNotNullable,
  isNotUndefined,
  isObject,
  ofType,
  provideConfig,
  provideDefaultConfig,
  resolveApplicable
} from "./chunk-AFAMYKVR.mjs";
import {
  APP_BOOTSTRAP_LISTENER,
  APP_INITIALIZER,
  ApplicationRef,
  AsyncPipe,
  Attribute,
  BehaviorSubject,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CommonModule,
  Component,
  ComponentFactory$1,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  DOCUMENT,
  DecimalPipe,
  Directive,
  DomSanitizer,
  EMPTY,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  HttpUrlEncodingCodec,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  KeyValueDiffers,
  LowerCasePipe,
  Meta,
  NEVER,
  NgClass,
  NgForOf,
  NgIf,
  NgModule,
  NgSwitch,
  NgSwitchCase,
  NgTemplateOutlet,
  NgZone,
  Observable,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  Renderer2,
  RendererFactory2,
  ReplaySubject,
  RuntimeError,
  SecurityContext,
  Self,
  SkipSelf,
  SlicePipe,
  Subject,
  Subscription,
  TemplateRef,
  Title,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  ViewportScroller,
  __decorate,
  __param,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  booleanAttribute,
  catchError,
  combineLatest,
  concat,
  debounceTime,
  defer,
  delay,
  delayWhen,
  distinctUntilChanged,
  endWith,
  filter,
  finalize,
  first,
  forkJoin,
  forwardRef,
  from,
  fromEvent,
  getDOM,
  inject,
  interval,
  isDevMode,
  isObservable,
  isPlatformBrowser,
  isPlatformServer,
  isPromise,
  isSubscribable,
  lastValueFrom,
  makeEnvironmentProviders,
  map,
  merge,
  mergeMap,
  observeOn,
  of,
  pairwise,
  publish,
  scan,
  setClassMetadata,
  share,
  shareReplay,
  skip,
  skipWhile,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  throttleTime,
  throwError,
  timer,
  using,
  withLatestFrom,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate3,
  ɵɵtextInterpolate4,
  ɵɵviewQuery
} from "./chunk-3LP6MEWW.mjs";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-JBYB2SS7.mjs";

// node_modules/@angular/forms/fesm2022/forms.mjs
var _BaseControlValueAccessor = class _BaseControlValueAccessor {
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
    this.onChange = (_) => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
};
_BaseControlValueAccessor.\u0275fac = function BaseControlValueAccessor_Factory(t) {
  return new (t || _BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_BaseControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BaseControlValueAccessor
});
var BaseControlValueAccessor = _BaseControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var _BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
};
_BuiltInControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BuiltInControlValueAccessor_BaseFactory;
  return function BuiltInControlValueAccessor_Factory(t) {
    return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(t || _BuiltInControlValueAccessor);
  };
})();
_BuiltInControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BuiltInControlValueAccessor,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var BuiltInControlValueAccessor = _BuiltInControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var _CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
};
_CheckboxControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CheckboxControlValueAccessor_BaseFactory;
  return function CheckboxControlValueAccessor_Factory(t) {
    return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(t || _CheckboxControlValueAccessor);
  };
})();
_CheckboxControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CheckboxControlValueAccessor,
  selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
  hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.checked);
      })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var CheckboxControlValueAccessor = _CheckboxControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var _DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    this._composing = false;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
};
_DefaultValueAccessor.\u0275fac = function DefaultValueAccessor_Factory(t) {
  return new (t || _DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
};
_DefaultValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _DefaultValueAccessor,
  selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
  hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
        return ctx._handleInput($event.target.value);
      })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
        return ctx._compositionStart();
      })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
        return ctx._compositionEnd($event.target.value);
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var DefaultValueAccessor = _DefaultValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || (typeof value === "string" || Array.isArray(value)) && value.length === 0;
}
function hasValidLength(value) {
  return value != null && typeof value.length === "number";
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var Validators = class {
  /**
   * @description
   * Validator that requires the control's value to be greater than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a minimum of 3
   *
   * ```typescript
   * const control = new FormControl(2, Validators.min(3));
   *
   * console.log(control.errors); // {min: {min: 3, actual: 2}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `min` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static min(min) {
    return minValidator(min);
  }
  /**
   * @description
   * Validator that requires the control's value to be less than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a maximum of 15
   *
   * ```typescript
   * const control = new FormControl(16, Validators.max(15));
   *
   * console.log(control.errors); // {max: {max: 15, actual: 16}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `max` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static max(max) {
    return maxValidator(max);
  }
  /**
   * @description
   * Validator that requires the control have a non-empty value.
   *
   * @usageNotes
   *
   * ### Validate that the field is non-empty
   *
   * ```typescript
   * const control = new FormControl('', Validators.required);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map with the `required` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static required(control) {
    return requiredValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value be true. This validator is commonly
   * used for required checkboxes.
   *
   * @usageNotes
   *
   * ### Validate that the field value is true
   *
   * ```typescript
   * const control = new FormControl('some value', Validators.requiredTrue);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map that contains the `required` property
   * set to `true` if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value pass an email validation test.
   *
   * Tests the value using a [regular
   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
   * pattern suitable for common use cases. The pattern is based on the definition of a valid email
   * address in the [WHATWG HTML
   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
   * lengths of different parts of the address).
   *
   * The differences from the WHATWG version include:
   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
   * - Disallow `local-part` to be longer than 64 characters.
   * - Disallow the whole address to be longer than 254 characters.
   *
   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
   * validate the value against a different pattern.
   *
   * @usageNotes
   *
   * ### Validate that the field matches a valid email pattern
   *
   * ```typescript
   * const control = new FormControl('bad@', Validators.email);
   *
   * console.log(control.errors); // {email: true}
   * ```
   *
   * @returns An error map with the `email` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static email(control) {
    return emailValidator(control);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be greater than or equal
   * to the provided minimum length. This validator is also provided by default if you use the
   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays. The
   * `minLength` validator logic is also not invoked for values when their `length` property is 0
   * (for example in case of an empty string or an empty array), to support optional controls. You
   * can use the standard `required` validator if empty values should not be considered valid.
   *
   * @usageNotes
   *
   * ### Validate that the field has a minimum of 3 characters
   *
   * ```typescript
   * const control = new FormControl('ng', Validators.minLength(3));
   *
   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
   * ```
   *
   * ```html
   * <input minlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `minlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be less than or equal
   * to the provided maximum length. This validator is also provided by default if you use the
   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays.
   *
   * @usageNotes
   *
   * ### Validate that the field has maximum of 5 characters
   *
   * ```typescript
   * const control = new FormControl('Angular', Validators.maxLength(5));
   *
   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
   * ```
   *
   * ```html
   * <input maxlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `maxlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  /**
   * @description
   * Validator that requires the control's value to match a regex pattern. This validator is also
   * provided by default if you use the HTML5 `pattern` attribute.
   *
   * @usageNotes
   *
   * ### Validate that the field only contains letters or spaces
   *
   * ```typescript
   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
   *
   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
   * ```
   *
   * ```html
   * <input pattern="[a-zA-Z ]*">
   * ```
   *
   * ### Pattern matching with the global or sticky flag
   *
   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
   * can produce different results on the same input when validations are run consecutively. This is
   * due to how the behavior of `RegExp.prototype.test` is
   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
   * Due to this behavior, it is recommended that when using
   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
   * flag enabled.
   *
   * ```typescript
   * // Not recommended (since the `g` flag is used)
   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
   *
   * // Good
   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
   * ```
   *
   * @param pattern A regular expression to be used as is to test the values, or a string.
   * If a string is passed, the `^` character is prepended and the `$` character is
   * appended to the provided string (if not already present), and the resulting regular
   * expression is used to test the values.
   *
   * @returns A validator function that returns an error map with the
   * `pattern` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  /**
   * @description
   * Validator that performs no operation.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static nullValidator(control) {
    return nullValidator(control);
  }
  static compose(validators) {
    return compose(validators);
  }
  /**
   * @description
   * Compose multiple async validators into a single function that returns the union
   * of the individual error objects for the provided control.
   *
   * @returns A validator function that returns an error map with the
   * merged error objects of the async validators if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static composeAsync(validators) {
    return composeAsync(validators);
  }
};
function minValidator(min) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      return null;
    }
    return control.value.length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      "maxlength": {
        "requiredLength": maxLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function patternValidator(pattern) {
  if (!pattern)
    return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^")
      regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$")
      regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null)
    return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators)
    return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  constructor() {
    this._rawValidators = [];
    this._rawAsyncValidators = [];
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control)
      this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  constructor() {
    super(...arguments);
    this._parent = null;
    this.name = null;
    this.valueAccessor = null;
  }
};
var AbstractControlStatus = class {
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var _NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatus.\u0275fac = function NgControlStatus_Factory(t) {
  return new (t || _NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
};
_NgControlStatus.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgControlStatus,
  selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
  hostVars: 14,
  hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NgControlStatus = _NgControlStatus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var _NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatusGroup.\u0275fac = function NgControlStatusGroup_Factory(t) {
  return new (t || _NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
};
_NgControlStatusGroup.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgControlStatusGroup,
  selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
  hostVars: 16,
  hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NgControlStatusGroup = _NgControlStatusGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException() {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`);
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._pendingDirty = false;
    this._hasOwnPendingAsyncValidator = false;
    this._pendingTouched = false;
    this._onCollectionChange = () => {
    };
    this._parent = null;
    this.pristine = true;
    this.touched = false;
    this._onDisabledChange = [];
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  /**
   * Marks the control as `touched`. A control is touched by focus and
   * blur events that do not change the value.
   *
   * @see {@link markAsUntouched()}
   * @see {@link markAsDirty()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsTouched(opts = {}) {
    this.touched = true;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(opts);
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   */
  markAllAsTouched() {
    this.markAsTouched({
      onlySelf: true
    });
    this._forEachChild((control) => control.markAllAsTouched());
  }
  /**
   * Marks the control as `untouched`.
   *
   * If the control has any children, also marks all children as `untouched`
   * and recalculates the `touched` status of all parent controls.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsDirty()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after the marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsUntouched(opts = {}) {
    this.touched = false;
    this._pendingTouched = false;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /**
   * Marks the control as `dirty`. A control becomes dirty when
   * the control's value is changed through the UI; compare `markAsTouched`.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsUntouched()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsDirty(opts = {}) {
    this.pristine = false;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(opts);
    }
  }
  /**
   * Marks the control as `pristine`.
   *
   * If the control has any children, marks all children as `pristine`,
   * and recalculates the `pristine` status of all parent
   * controls.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsUntouched()}
   * @see {@link markAsDirty()}
   *
   * @param opts Configuration options that determine how the control emits events after
   * marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsPristine(opts = {}) {
    this.pristine = true;
    this._pendingDirty = false;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /**
   * Marks the control as `pending`.
   *
   * A control is pending while the control performs async validation.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates changes and
   * emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event with the latest status the control is marked pending.
   * When false, no events are emitted.
   *
   */
  markAsPending(opts = {}) {
    this.status = PENDING;
    if (opts.emitEvent !== false) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(opts);
    }
  }
  /**
   * Disables the control. This means the control is exempt from validation checks and
   * excluded from the aggregate value of any parent. Its status is `DISABLED`.
   *
   * If the control has children, all children are also disabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control is disabled.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is disabled.
   * When false, no events are emitted.
   */
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine();
      }
      this._parent._updateTouched();
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  /**
   * Recalculates the value and validation status of the control.
   *
   * By default, it also updates the value and validity of its ancestors.
   *
   * @param opts Configuration options determine how the control propagates changes and emits events
   * after updates and validity checks are applied.
   * * `onlySelf`: When true, only update this control. When false or not supplied,
   * update all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is updated.
   * When false, no events are emitted.
   */
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(opts.emitEvent);
      }
    }
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = true;
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = false;
        this.setErrors(errors, {
          emitEvent
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      this._hasOwnPendingAsyncValidator = false;
    }
  }
  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   *
   * Calling `setErrors` also updates the validity of the parent control.
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control errors are set.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event after the errors are set.
   *
   * @usageNotes
   *
   * ### Manually set the errors for a control
   *
   * ```
   * const login = new FormControl('someLogin');
   * login.setErrors({
   *   notUnique: true
   * });
   *
   * expect(login.valid).toEqual(false);
   * expect(login.errors).toEqual({ notUnique: true });
   *
   * login.setValue('someOtherLogin');
   *
   * expect(login.valid).toEqual(true);
   * ```
   */
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null)
      return null;
    if (!Array.isArray(currPath))
      currPath = currPath.split(".");
    if (currPath.length === 0)
      return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled())
      return DISABLED;
    if (this.errors)
      return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING))
      return PENDING;
    if (this._anyControlsHaveStatus(INVALID))
      return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts = {}) {
    this.pristine = !this._anyControlsDirty();
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /** @internal */
  _updateTouched(opts = {}) {
    this.touched = this._anyControlsTouched();
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  registerControl(name, control) {
    if (this.controls[name])
      return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name])
      this.controls[name]._registerOnCollectionChange(() => {
      });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name])
      this.controls[name]._registerOnCollectionChange(() => {
      });
    delete this.controls[name];
    if (control)
      this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null)
      return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated)
      this.updateValueAndValidity({
        onlySelf: true
      });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var UntypedFormGroup = FormGroup;
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken("CallSetDisabledState", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control)
      _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor)
      _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange)
      validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change")
      updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange)
      updateControl(control, dir);
    if (control.updateOn !== "submit")
      control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty)
    control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent)
      dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode))
    _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1)
    return `path: '${path.join(" -> ")}'`;
  if (path?.[0])
    return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model"))
    return false;
  const change = changes["model"];
  if (change.isFirstChange())
    return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives2) {
  form._syncPendingControls();
  directives2.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors)
    return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode))
    _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode))
        _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode))
        _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor)
    return customAccessor;
  if (builtinAccessor)
    return builtinAccessor;
  if (defaultAccessor)
    return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1)
    list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never")
    return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var _NgForm = class _NgForm extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._directives = /* @__PURE__ */ new Set();
    this.ngSubmit = new EventEmitter();
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
};
_NgForm.\u0275fac = function NgForm_Factory(t) {
  return new (t || _NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgForm.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgForm,
  selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
  hostBindings: function NgForm_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function NgForm_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    options: [InputFlags.None, "ngFormOptions", "options"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
});
var NgForm = _NgForm;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1)
    list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.defaultValue = null;
    this._onChange = [];
    this._pendingChange = false;
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty)
        this.markAsDirty();
      if (this._pendingTouched)
        this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var UntypedFormControl = FormControl;
var isFormControl = (control) => control instanceof FormControl;
var _AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
};
_AbstractFormGroupDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AbstractFormGroupDirective_BaseFactory;
  return function AbstractFormGroupDirective_Factory(t) {
    return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_AbstractFormGroupDirective)))(t || _AbstractFormGroupDirective);
  };
})();
_AbstractFormGroupDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractFormGroupDirective,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var AbstractFormGroupDirective = _AbstractFormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var _NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = "";
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
};
_NgModelGroup.\u0275fac = function NgModelGroup_Factory(t) {
  return new (t || _NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_NgModelGroup.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgModelGroup,
  selectors: [["", "ngModelGroup", ""]],
  inputs: {
    name: [InputFlags.None, "ngModelGroup", "name"]
  },
  exportAs: ["ngModelGroup"],
  features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
});
var NgModelGroup = _NgModelGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var _NgModel = class _NgModel extends NgControl {
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this.control = new FormControl();
    this._registered = false;
    this.name = "";
    this.update = new EventEmitter();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if (!this._isStandalone()) {
      this._checkParentType();
    }
    this._checkName();
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
        throw formGroupNameException();
      } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
        throw modelParentException();
      }
    }
  }
  _checkName() {
    if (this.options && this.options.name)
      this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
};
_NgModel.\u0275fac = function NgModel_Factory(t) {
  return new (t || _NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgModel.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgModel,
  selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
  inputs: {
    name: "name",
    isDisabled: [InputFlags.None, "disabled", "isDisabled"],
    model: [InputFlags.None, "ngModel", "model"],
    options: [InputFlags.None, "ngModelOptions", "options"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngModel"],
  features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var NgModel = _NgModel;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var _\u0275NgNoValidate = class _\u0275NgNoValidate {
};
_\u0275NgNoValidate.\u0275fac = function \u0275NgNoValidate_Factory(t) {
  return new (t || _\u0275NgNoValidate)();
};
_\u0275NgNoValidate.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _\u0275NgNoValidate,
  selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
  hostAttrs: ["novalidate", ""]
});
var \u0275NgNoValidate = _\u0275NgNoValidate;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      }
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var _NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_NumberValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NumberValueAccessor_BaseFactory;
  return function NumberValueAccessor_Factory(t) {
    return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_NumberValueAccessor)))(t || _NumberValueAccessor);
  };
})();
_NumberValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NumberValueAccessor,
  selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
  hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var NumberValueAccessor = _NumberValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var _RadioControlRegistry = class _RadioControlRegistry {
  constructor() {
    this._accessors = [];
  }
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control)
      return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
};
_RadioControlRegistry.\u0275fac = function RadioControlRegistry_Factory(t) {
  return new (t || _RadioControlRegistry)();
};
_RadioControlRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RadioControlRegistry,
  factory: _RadioControlRegistry.\u0275fac,
  providedIn: "root"
});
var RadioControlRegistry = _RadioControlRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
    this.setDisabledStateFired = false;
    this.onChange = () => {
    };
    this.callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
      optional: true
    }) ?? setDisabledStateDefault;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName)
      this.name = this.formControlName;
  }
};
_RadioControlValueAccessor.\u0275fac = function RadioControlValueAccessor_Factory(t) {
  return new (t || _RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
};
_RadioControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RadioControlValueAccessor,
  selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
  hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
        return ctx.onChange();
      })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    name: "name",
    formControlName: "formControlName",
    value: "value"
  },
  features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var RadioControlValueAccessor = _RadioControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var _RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_RangeValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275RangeValueAccessor_BaseFactory;
  return function RangeValueAccessor_Factory(t) {
    return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_RangeValueAccessor)))(t || _RangeValueAccessor);
  };
})();
_RangeValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RangeValueAccessor,
  selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
  hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var RangeValueAccessor = _RangeValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var _FormControlDirective = class _FormControlDirective extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
};
_FormControlDirective._ngModelWarningSentOnce = false;
_FormControlDirective.\u0275fac = function FormControlDirective_Factory(t) {
  return new (t || _FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormControlDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormControlDirective,
  selectors: [["", "formControl", ""]],
  inputs: {
    form: [InputFlags.None, "formControl", "form"],
    isDisabled: [InputFlags.None, "disabled", "isDisabled"],
    model: [InputFlags.None, "ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormControlDirective = _FormControlDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var _FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._onCollectionChange = () => this._updateDomValue();
    this.directives = [];
    this.form = null;
    this.ngSubmit = new EventEmitter();
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingFormException();
    }
  }
};
_FormGroupDirective.\u0275fac = function FormGroupDirective_Factory(t) {
  return new (t || _FormGroupDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormGroupDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormGroupDirective,
  selectors: [["", "formGroup", ""]],
  hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function FormGroupDirective_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    form: [InputFlags.None, "formGroup", "form"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormGroupDirective = _FormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var _FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
};
_FormGroupName.\u0275fac = function FormGroupName_Factory(t) {
  return new (t || _FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormGroupName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormGroupName,
  selectors: [["", "formGroupName", ""]],
  inputs: {
    name: [InputFlags.None, "formGroupName", "name"]
  },
  features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
});
var FormGroupName = _FormGroupName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var _FormArrayName = class _FormArrayName extends ControlContainer {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormArray(this);
    }
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
  }
};
_FormArrayName.\u0275fac = function FormArrayName_Factory(t) {
  return new (t || _FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormArrayName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormArrayName,
  selectors: [["", "formArrayName", ""]],
  inputs: {
    name: [InputFlags.None, "formArrayName", "name"]
  },
  features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
});
var FormArrayName = _FormArrayName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var _FormControlName = class _FormControlName extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._added = false;
    this.name = null;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added)
      this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
        throw ngModelGroupException();
      } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
        throw controlParentException();
      }
    }
  }
  _setUpControl() {
    this._checkParentType();
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
};
_FormControlName._ngModelWarningSentOnce = false;
_FormControlName.\u0275fac = function FormControlName_Factory(t) {
  return new (t || _FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
};
_FormControlName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormControlName,
  selectors: [["", "formControlName", ""]],
  inputs: {
    name: [InputFlags.None, "formControlName", "name"],
    isDisabled: [InputFlags.None, "disabled", "isDisabled"],
    model: [InputFlags.None, "ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormControlName = _FormControlName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null)
    return `${value}`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var _SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value))
        return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
};
_SelectControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SelectControlValueAccessor_BaseFactory;
  return function SelectControlValueAccessor_Factory(t) {
    return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectControlValueAccessor)))(t || _SelectControlValueAccessor);
  };
})();
_SelectControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SelectControlValueAccessor,
  selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
  hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var SelectControlValueAccessor = _SelectControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _NgSelectOption = class _NgSelectOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select)
      this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null)
      return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select)
      this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_NgSelectOption.\u0275fac = function NgSelectOption_Factory(t) {
  return new (t || _NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
};
_NgSelectOption.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgSelectOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var NgSelectOption = _NgSelectOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null)
    return `${value}`;
  if (typeof value === "string")
    value = `'${value}'`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var _SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value))
        return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
};
_SelectMultipleControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SelectMultipleControlValueAccessor_BaseFactory;
  return function SelectMultipleControlValueAccessor_Factory(t) {
    return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(t || _SelectMultipleControlValueAccessor);
  };
})();
_SelectMultipleControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SelectMultipleControlValueAccessor,
  selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
  hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target);
      })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var SelectMultipleControlValueAccessor = _SelectMultipleControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _\u0275NgSelectMultipleOption = class _\u0275NgSelectMultipleOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null)
      return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_\u0275NgSelectMultipleOption.\u0275fac = function \u0275NgSelectMultipleOption_Factory(t) {
  return new (t || _\u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
};
_\u0275NgSelectMultipleOption.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _\u0275NgSelectMultipleOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var \u0275NgSelectMultipleOption = _\u0275NgSelectMultipleOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var _AbstractValidatorDirective = class _AbstractValidatorDirective {
  constructor() {
    this._validator = nullValidator;
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input) {
    return input != null;
  }
};
_AbstractValidatorDirective.\u0275fac = function AbstractValidatorDirective_Factory(t) {
  return new (t || _AbstractValidatorDirective)();
};
_AbstractValidatorDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractValidatorDirective,
  features: [\u0275\u0275NgOnChangesFeature]
});
var AbstractValidatorDirective = _AbstractValidatorDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var _MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "max";
    this.normalizeInput = (input) => toFloat(input);
    this.createValidator = (max) => maxValidator(max);
  }
};
_MaxValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MaxValidator_BaseFactory;
  return function MaxValidator_Factory(t) {
    return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxValidator)))(t || _MaxValidator);
  };
})();
_MaxValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MaxValidator,
  selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
    }
  },
  inputs: {
    max: "max"
  },
  features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MaxValidator = _MaxValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      }
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var _MinValidator = class _MinValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "min";
    this.normalizeInput = (input) => toFloat(input);
    this.createValidator = (min) => minValidator(min);
  }
};
_MinValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MinValidator_BaseFactory;
  return function MinValidator_Factory(t) {
    return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinValidator)))(t || _MinValidator);
  };
})();
_MinValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MinValidator,
  selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
    }
  },
  inputs: {
    min: "min"
  },
  features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MinValidator = _MinValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      }
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var _RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "required";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input) => requiredValidator;
  }
  /** @nodoc */
  enabled(input) {
    return input;
  }
};
_RequiredValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275RequiredValidator_BaseFactory;
  return function RequiredValidator_Factory(t) {
    return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_RequiredValidator)))(t || _RequiredValidator);
  };
})();
_RequiredValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RequiredValidator,
  selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
  hostVars: 1,
  hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("required", ctx._enabled ? "" : null);
    }
  },
  inputs: {
    required: "required"
  },
  features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var RequiredValidator = _RequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var _CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  constructor() {
    super(...arguments);
    this.createValidator = (input) => requiredTrueValidator;
  }
};
_CheckboxRequiredValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CheckboxRequiredValidator_BaseFactory;
  return function CheckboxRequiredValidator_Factory(t) {
    return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxRequiredValidator)))(t || _CheckboxRequiredValidator);
  };
})();
_CheckboxRequiredValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CheckboxRequiredValidator,
  selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("required", ctx._enabled ? "" : null);
    }
  },
  features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var CheckboxRequiredValidator = _CheckboxRequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var _EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "email";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input) => emailValidator;
  }
  /** @nodoc */
  enabled(input) {
    return input;
  }
};
_EmailValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275EmailValidator_BaseFactory;
  return function EmailValidator_Factory(t) {
    return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(_EmailValidator)))(t || _EmailValidator);
  };
})();
_EmailValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _EmailValidator,
  selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
  inputs: {
    email: "email"
  },
  features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var EmailValidator = _EmailValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR]
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var _MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "minlength";
    this.normalizeInput = (input) => toInteger(input);
    this.createValidator = (minlength) => minLengthValidator(minlength);
  }
};
_MinLengthValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MinLengthValidator_BaseFactory;
  return function MinLengthValidator_Factory(t) {
    return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinLengthValidator)))(t || _MinLengthValidator);
  };
})();
_MinLengthValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MinLengthValidator,
  selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
    }
  },
  inputs: {
    minlength: "minlength"
  },
  features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MinLengthValidator = _MinLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      }
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var _MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "maxlength";
    this.normalizeInput = (input) => toInteger(input);
    this.createValidator = (maxlength) => maxLengthValidator(maxlength);
  }
};
_MaxLengthValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MaxLengthValidator_BaseFactory;
  return function MaxLengthValidator_Factory(t) {
    return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxLengthValidator)))(t || _MaxLengthValidator);
  };
})();
_MaxLengthValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MaxLengthValidator,
  selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
    }
  },
  inputs: {
    maxlength: "maxlength"
  },
  features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MaxLengthValidator = _MaxLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      }
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var _PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "pattern";
    this.normalizeInput = (input) => input;
    this.createValidator = (input) => patternValidator(input);
  }
};
_PatternValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PatternValidator_BaseFactory;
  return function PatternValidator_Factory(t) {
    return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(_PatternValidator)))(t || _PatternValidator);
  };
})();
_PatternValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PatternValidator,
  selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function PatternValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
    }
  },
  inputs: {
    pattern: "pattern"
  },
  features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var PatternValidator = _PatternValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      }
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var _\u0275InternalFormsSharedModule = class _\u0275InternalFormsSharedModule {
};
_\u0275InternalFormsSharedModule.\u0275fac = function \u0275InternalFormsSharedModule_Factory(t) {
  return new (t || _\u0275InternalFormsSharedModule)();
};
_\u0275InternalFormsSharedModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _\u0275InternalFormsSharedModule
});
_\u0275InternalFormsSharedModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var \u0275InternalFormsSharedModule = _\u0275InternalFormsSharedModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275InternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0)
      adjustedIndex = 0;
    if (this.controls[adjustedIndex])
      this.controls[adjustedIndex]._registerOnCollectionChange(() => {
      });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0)
      adjustedIndex = 0;
    if (this.controls[adjustedIndex])
      this.controls[adjustedIndex]._registerOnCollectionChange(() => {
      });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null)
      return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1)
      return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated)
      this.updateValueAndValidity({
        onlySelf: true
      });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled)
        return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
var UntypedFormArray = FormArray;
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var _FormBuilder = class _FormBuilder {
  constructor() {
    this.useNonNullable = false;
  }
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
   * </code-example>
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
};
_FormBuilder.\u0275fac = function FormBuilder_Factory(t) {
  return new (t || _FormBuilder)();
};
_FormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FormBuilder,
  factory: _FormBuilder.\u0275fac,
  providedIn: "root"
});
var FormBuilder = _FormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NonNullableFormBuilder = class _NonNullableFormBuilder {
};
_NonNullableFormBuilder.\u0275fac = function NonNullableFormBuilder_Factory(t) {
  return new (t || _NonNullableFormBuilder)();
};
_NonNullableFormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NonNullableFormBuilder,
  factory: () => (() => inject(FormBuilder).nonNullable)(),
  providedIn: "root"
});
var NonNullableFormBuilder = _NonNullableFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var _UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
};
_UntypedFormBuilder.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275UntypedFormBuilder_BaseFactory;
  return function UntypedFormBuilder_Factory(t) {
    return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_UntypedFormBuilder)))(t || _UntypedFormBuilder);
  };
})();
_UntypedFormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _UntypedFormBuilder,
  factory: _UntypedFormBuilder.\u0275fac,
  providedIn: "root"
});
var UntypedFormBuilder = _UntypedFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION = new Version("17.3.3");
var _FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_FormsModule.\u0275fac = function FormsModule_Factory(t) {
  return new (t || _FormsModule)();
};
_FormsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FormsModule
});
_FormsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [\u0275InternalFormsSharedModule]
});
var FormsModule = _FormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var _ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_ReactiveFormsModule.\u0275fac = function ReactiveFormsModule_Factory(t) {
  return new (t || _ReactiveFormsModule)();
};
_ReactiveFormsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ReactiveFormsModule
});
_ReactiveFormsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [\u0275InternalFormsSharedModule]
});
var ReactiveFormsModule = _ReactiveFormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@angular/service-worker/fesm2022/service-worker.mjs
var ERR_SW_NOT_SUPPORTED = "Service workers are disabled or not supported by this browser";
function errorObservable(message) {
  return defer(() => throwError(new Error(message)));
}
var NgswCommChannel = class {
  constructor(serviceWorker) {
    this.serviceWorker = serviceWorker;
    if (!serviceWorker) {
      this.worker = this.events = this.registration = errorObservable(ERR_SW_NOT_SUPPORTED);
    } else {
      const controllerChangeEvents = fromEvent(serviceWorker, "controllerchange");
      const controllerChanges = controllerChangeEvents.pipe(map(() => serviceWorker.controller));
      const currentController = defer(() => of(serviceWorker.controller));
      const controllerWithChanges = concat(currentController, controllerChanges);
      this.worker = controllerWithChanges.pipe(filter((c) => !!c));
      this.registration = this.worker.pipe(switchMap(() => serviceWorker.getRegistration()));
      const rawEvents = fromEvent(serviceWorker, "message");
      const rawEventPayload = rawEvents.pipe(map((event) => event.data));
      const eventsUnconnected = rawEventPayload.pipe(filter((event) => event && event.type));
      const events = eventsUnconnected.pipe(publish());
      events.connect();
      this.events = events;
    }
  }
  postMessage(action, payload) {
    return this.worker.pipe(take(1), tap((sw) => {
      sw.postMessage(__spreadValues({
        action
      }, payload));
    })).toPromise().then(() => void 0);
  }
  postMessageWithOperation(type, payload, operationNonce) {
    const waitForOperationCompleted = this.waitForOperationCompleted(operationNonce);
    const postMessage = this.postMessage(type, payload);
    return Promise.all([postMessage, waitForOperationCompleted]).then(([, result]) => result);
  }
  generateNonce() {
    return Math.round(Math.random() * 1e7);
  }
  eventsOfType(type) {
    let filterFn;
    if (typeof type === "string") {
      filterFn = (event) => event.type === type;
    } else {
      filterFn = (event) => type.includes(event.type);
    }
    return this.events.pipe(filter(filterFn));
  }
  nextEventOfType(type) {
    return this.eventsOfType(type).pipe(take(1));
  }
  waitForOperationCompleted(nonce) {
    return this.eventsOfType("OPERATION_COMPLETED").pipe(filter((event) => event.nonce === nonce), take(1), map((event) => {
      if (event.result !== void 0) {
        return event.result;
      }
      throw new Error(event.error);
    })).toPromise();
  }
  get isEnabled() {
    return !!this.serviceWorker;
  }
};
var _SwPush = class _SwPush {
  /**
   * True if the Service Worker is enabled (supported by the browser and enabled via
   * `ServiceWorkerModule`).
   */
  get isEnabled() {
    return this.sw.isEnabled;
  }
  constructor(sw) {
    this.sw = sw;
    this.pushManager = null;
    this.subscriptionChanges = new Subject();
    if (!sw.isEnabled) {
      this.messages = NEVER;
      this.notificationClicks = NEVER;
      this.subscription = NEVER;
      return;
    }
    this.messages = this.sw.eventsOfType("PUSH").pipe(map((message) => message.data));
    this.notificationClicks = this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(map((message) => message.data));
    this.pushManager = this.sw.registration.pipe(map((registration) => registration.pushManager));
    const workerDrivenSubscriptions = this.pushManager.pipe(switchMap((pm) => pm.getSubscription()));
    this.subscription = merge(workerDrivenSubscriptions, this.subscriptionChanges);
  }
  /**
   * Subscribes to Web Push Notifications,
   * after requesting and receiving user permission.
   *
   * @param options An object containing the `serverPublicKey` string.
   * @returns A Promise that resolves to the new subscription object.
   */
  requestSubscription(options) {
    if (!this.sw.isEnabled || this.pushManager === null) {
      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
    }
    const pushOptions = {
      userVisibleOnly: true
    };
    let key = this.decodeBase64(options.serverPublicKey.replace(/_/g, "/").replace(/-/g, "+"));
    let applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));
    for (let i = 0; i < key.length; i++) {
      applicationServerKey[i] = key.charCodeAt(i);
    }
    pushOptions.applicationServerKey = applicationServerKey;
    return this.pushManager.pipe(switchMap((pm) => pm.subscribe(pushOptions)), take(1)).toPromise().then((sub) => {
      this.subscriptionChanges.next(sub);
      return sub;
    });
  }
  /**
   * Unsubscribes from Service Worker push notifications.
   *
   * @returns A Promise that is resolved when the operation succeeds, or is rejected if there is no
   *          active subscription or the unsubscribe operation fails.
   */
  unsubscribe() {
    if (!this.sw.isEnabled) {
      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
    }
    const doUnsubscribe = (sub) => {
      if (sub === null) {
        throw new Error("Not subscribed to push notifications.");
      }
      return sub.unsubscribe().then((success) => {
        if (!success) {
          throw new Error("Unsubscribe failed!");
        }
        this.subscriptionChanges.next(null);
      });
    };
    return this.subscription.pipe(take(1), switchMap(doUnsubscribe)).toPromise();
  }
  decodeBase64(input) {
    return atob(input);
  }
};
_SwPush.\u0275fac = function SwPush_Factory(t) {
  return new (t || _SwPush)(\u0275\u0275inject(NgswCommChannel));
};
_SwPush.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SwPush,
  factory: _SwPush.\u0275fac
});
var SwPush = _SwPush;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwPush, [{
    type: Injectable
  }], () => [{
    type: NgswCommChannel
  }], null);
})();
var _SwUpdate = class _SwUpdate {
  /**
   * True if the Service Worker is enabled (supported by the browser and enabled via
   * `ServiceWorkerModule`).
   */
  get isEnabled() {
    return this.sw.isEnabled;
  }
  constructor(sw) {
    this.sw = sw;
    if (!sw.isEnabled) {
      this.versionUpdates = NEVER;
      this.unrecoverable = NEVER;
      return;
    }
    this.versionUpdates = this.sw.eventsOfType(["VERSION_DETECTED", "VERSION_INSTALLATION_FAILED", "VERSION_READY", "NO_NEW_VERSION_DETECTED"]);
    this.unrecoverable = this.sw.eventsOfType("UNRECOVERABLE_STATE");
  }
  /**
   * Checks for an update and waits until the new version is downloaded from the server and ready
   * for activation.
   *
   * @returns a promise that
   * - resolves to `true` if a new version was found and is ready to be activated.
   * - resolves to `false` if no new version was found
   * - rejects if any error occurs
   */
  checkForUpdate() {
    if (!this.sw.isEnabled) {
      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
    }
    const nonce = this.sw.generateNonce();
    return this.sw.postMessageWithOperation("CHECK_FOR_UPDATES", {
      nonce
    }, nonce);
  }
  /**
   * Updates the current client (i.e. browser tab) to the latest version that is ready for
   * activation.
   *
   * In most cases, you should not use this method and instead should update a client by reloading
   * the page.
   *
   * <div class="alert is-important">
   *
   * Updating a client without reloading can easily result in a broken application due to a version
   * mismatch between the [application shell](guide/glossary#app-shell) and other page resources,
   * such as [lazy-loaded chunks](guide/glossary#lazy-loading), whose filenames may change between
   * versions.
   *
   * Only use this method, if you are certain it is safe for your specific use case.
   *
   * </div>
   *
   * @returns a promise that
   *  - resolves to `true` if an update was activated successfully
   *  - resolves to `false` if no update was available (for example, the client was already on the
   *    latest version).
   *  - rejects if any error occurs
   */
  activateUpdate() {
    if (!this.sw.isEnabled) {
      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
    }
    const nonce = this.sw.generateNonce();
    return this.sw.postMessageWithOperation("ACTIVATE_UPDATE", {
      nonce
    }, nonce);
  }
};
_SwUpdate.\u0275fac = function SwUpdate_Factory(t) {
  return new (t || _SwUpdate)(\u0275\u0275inject(NgswCommChannel));
};
_SwUpdate.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SwUpdate,
  factory: _SwUpdate.\u0275fac
});
var SwUpdate = _SwUpdate;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwUpdate, [{
    type: Injectable
  }], () => [{
    type: NgswCommChannel
  }], null);
})();
var SCRIPT = new InjectionToken(ngDevMode ? "NGSW_REGISTER_SCRIPT" : "");
function ngswAppInitializer(injector, script, options, platformId) {
  return () => {
    if (!(isPlatformBrowser(platformId) && "serviceWorker" in navigator && options.enabled !== false)) {
      return;
    }
    navigator.serviceWorker.addEventListener("controllerchange", () => {
      if (navigator.serviceWorker.controller !== null) {
        navigator.serviceWorker.controller.postMessage({
          action: "INITIALIZE"
        });
      }
    });
    let readyToRegister$;
    if (typeof options.registrationStrategy === "function") {
      readyToRegister$ = options.registrationStrategy();
    } else {
      const [strategy, ...args] = (options.registrationStrategy || "registerWhenStable:30000").split(":");
      switch (strategy) {
        case "registerImmediately":
          readyToRegister$ = of(null);
          break;
        case "registerWithDelay":
          readyToRegister$ = delayWithTimeout(+args[0] || 0);
          break;
        case "registerWhenStable":
          readyToRegister$ = !args[0] ? whenStable(injector) : merge(whenStable(injector), delayWithTimeout(+args[0]));
          break;
        default:
          throw new Error(`Unknown ServiceWorker registration strategy: ${options.registrationStrategy}`);
      }
    }
    const ngZone = injector.get(NgZone);
    ngZone.runOutsideAngular(() => readyToRegister$.pipe(take(1)).subscribe(() => navigator.serviceWorker.register(script, {
      scope: options.scope
    }).catch((err) => console.error("Service worker registration failed with:", err))));
  };
}
function delayWithTimeout(timeout) {
  return of(null).pipe(delay(timeout));
}
function whenStable(injector) {
  const appRef = injector.get(ApplicationRef);
  return appRef.isStable.pipe(filter((stable) => stable));
}
function ngswCommChannelFactory(opts, platformId) {
  return new NgswCommChannel(isPlatformBrowser(platformId) && opts.enabled !== false ? navigator.serviceWorker : void 0);
}
var SwRegistrationOptions = class {
};
function provideServiceWorker(script, options = {}) {
  return makeEnvironmentProviders([SwPush, SwUpdate, {
    provide: SCRIPT,
    useValue: script
  }, {
    provide: SwRegistrationOptions,
    useValue: options
  }, {
    provide: NgswCommChannel,
    useFactory: ngswCommChannelFactory,
    deps: [SwRegistrationOptions, PLATFORM_ID]
  }, {
    provide: APP_INITIALIZER,
    useFactory: ngswAppInitializer,
    deps: [Injector, SCRIPT, SwRegistrationOptions, PLATFORM_ID],
    multi: true
  }]);
}
var _ServiceWorkerModule = class _ServiceWorkerModule {
  /**
   * Register the given Angular Service Worker script.
   *
   * If `enabled` is set to `false` in the given options, the module will behave as if service
   * workers are not supported by the browser, and the service worker will not be registered.
   */
  static register(script, options = {}) {
    return {
      ngModule: _ServiceWorkerModule,
      providers: [provideServiceWorker(script, options)]
    };
  }
};
_ServiceWorkerModule.\u0275fac = function ServiceWorkerModule_Factory(t) {
  return new (t || _ServiceWorkerModule)();
};
_ServiceWorkerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ServiceWorkerModule
});
_ServiceWorkerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [SwPush, SwUpdate]
});
var ServiceWorkerModule = _ServiceWorkerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ServiceWorkerModule, [{
    type: NgModule,
    args: [{
      providers: [SwPush, SwUpdate]
    }]
  }], null, null);
})();

// node_modules/@ng-select/ng-select/fesm2022/ng-select-ng-select.mjs
var _c0 = ["content"];
var _c1 = ["scroll"];
var _c2 = ["padding"];
var _c3 = ["*"];
var _c4 = (a0) => ({
  searchTerm: a0
});
function NgDropdownPanelComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275elementContainer(1, 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.headerTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c4, ctx_r0.filterValue));
  }
}
function NgDropdownPanelComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275elementContainer(1, 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.footerTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c4, ctx_r0.filterValue));
  }
}
var _c5 = ["searchInput"];
var _c6 = ["clearButton"];
var _c7 = (a0, a1, a2) => ({
  item: a0,
  clear: a1,
  label: a2
});
var _c8 = (a0, a1) => ({
  items: a0,
  clear: a1
});
var _c9 = (a0, a1, a2, a3) => ({
  item: a0,
  item$: a1,
  index: a2,
  searchTerm: a3
});
function NgSelectComponent_ng_container_4_div_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 22);
    \u0275\u0275listener("click", function NgSelectComponent_ng_container_4_div_1_ng_template_1_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const item_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.unselect(item_r3));
    });
    \u0275\u0275text(1, "\xD7");
    \u0275\u0275elementEnd();
    \u0275\u0275element(2, "span", 23);
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngItemLabel", item_r3.label)("escape", ctx_r3.escapeHTML);
  }
}
function NgSelectComponent_ng_container_4_div_1_ng_template_3_Template(rf, ctx) {
}
function NgSelectComponent_ng_container_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275template(1, NgSelectComponent_ng_container_4_div_1_ng_template_1_Template, 3, 2, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, NgSelectComponent_ng_container_4_div_1_ng_template_3_Template, 0, 0, "ng-template", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const defaultLabelTemplate_r5 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("ng-value-disabled", item_r3.disabled);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.labelTemplate || defaultLabelTemplate_r5)("ngTemplateOutletContext", \u0275\u0275pureFunction3(4, _c7, item_r3.value, ctx_r3.clearItem, item_r3.label));
  }
}
function NgSelectComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NgSelectComponent_ng_container_4_div_1_Template, 4, 8, "div", 19);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r3.selectedItems)("ngForTrackBy", ctx_r3.trackByOption);
  }
}
function NgSelectComponent_5_ng_template_0_Template(rf, ctx) {
}
function NgSelectComponent_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NgSelectComponent_5_ng_template_0_Template, 0, 0, "ng-template", 21);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.multiLabelTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c8, ctx_r3.selectedValues, ctx_r3.clearItem));
  }
}
function NgSelectComponent_ng_container_9_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 25);
  }
}
function NgSelectComponent_ng_container_9_ng_template_3_Template(rf, ctx) {
}
function NgSelectComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NgSelectComponent_ng_container_9_ng_template_1_Template, 1, 0, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(3, NgSelectComponent_ng_container_9_ng_template_3_Template, 0, 0, "ng-template", 24);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const defaultLoadingSpinnerTemplate_r7 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.loadingSpinnerTemplate || defaultLoadingSpinnerTemplate_r7);
  }
}
function NgSelectComponent_span_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 26, 3)(2, "span", 27);
    \u0275\u0275text(3, "\xD7");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275propertyInterpolate("title", ctx_r3.clearAllText);
  }
}
function NgSelectComponent_ng_dropdown_panel_13_div_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 32);
  }
  if (rf & 2) {
    const item_r10 = \u0275\u0275nextContext().$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngItemLabel", item_r10.label)("escape", ctx_r3.escapeHTML);
  }
}
function NgSelectComponent_ng_dropdown_panel_13_div_2_ng_template_3_Template(rf, ctx) {
}
function NgSelectComponent_ng_dropdown_panel_13_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 31);
    \u0275\u0275listener("click", function NgSelectComponent_ng_dropdown_panel_13_div_2_Template_div_click_0_listener() {
      const item_r10 = \u0275\u0275restoreView(_r9).$implicit;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.toggleItem(item_r10));
    })("mouseover", function NgSelectComponent_ng_dropdown_panel_13_div_2_Template_div_mouseover_0_listener() {
      const item_r10 = \u0275\u0275restoreView(_r9).$implicit;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.onItemHover(item_r10));
    });
    \u0275\u0275template(1, NgSelectComponent_ng_dropdown_panel_13_div_2_ng_template_1_Template, 1, 2, "ng-template", null, 4, \u0275\u0275templateRefExtractor)(3, NgSelectComponent_ng_dropdown_panel_13_div_2_ng_template_3_Template, 0, 0, "ng-template", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    const defaultOptionTemplate_r11 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("ng-option-disabled", item_r10.disabled)("ng-option-selected", item_r10.selected)("ng-optgroup", item_r10.children)("ng-option", !item_r10.children)("ng-option-child", !!item_r10.parent)("ng-option-marked", item_r10 === ctx_r3.itemsList.markedItem);
    \u0275\u0275attribute("role", item_r10.children ? "group" : "option")("aria-selected", item_r10.selected)("id", item_r10 == null ? null : item_r10.htmlId);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", item_r10.children ? ctx_r3.optgroupTemplate || defaultOptionTemplate_r11 : ctx_r3.optionTemplate || defaultOptionTemplate_r11)("ngTemplateOutletContext", \u0275\u0275pureFunction4(17, _c9, item_r10.value, item_r10, item_r10.index, ctx_r3.searchTerm));
  }
}
function NgSelectComponent_ng_dropdown_panel_13_div_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span")(1, "span", 34);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r3.addTagText);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1('"', ctx_r3.searchTerm, '"');
  }
}
function NgSelectComponent_ng_dropdown_panel_13_div_3_ng_template_3_Template(rf, ctx) {
}
function NgSelectComponent_ng_dropdown_panel_13_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 33);
    \u0275\u0275listener("mouseover", function NgSelectComponent_ng_dropdown_panel_13_div_3_Template_div_mouseover_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.itemsList.unmarkItem());
    })("click", function NgSelectComponent_ng_dropdown_panel_13_div_3_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.selectTag());
    });
    \u0275\u0275template(1, NgSelectComponent_ng_dropdown_panel_13_div_3_ng_template_1_Template, 4, 2, "ng-template", null, 5, \u0275\u0275templateRefExtractor)(3, NgSelectComponent_ng_dropdown_panel_13_div_3_ng_template_3_Template, 0, 0, "ng-template", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const defaultTagTemplate_r13 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("ng-option-marked", !ctx_r3.itemsList.markedItem);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.tagTemplate || defaultTagTemplate_r13)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c4, ctx_r3.searchTerm));
  }
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 35);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r3.notFoundText);
  }
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_4_ng_template_3_Template(rf, ctx) {
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NgSelectComponent_ng_dropdown_panel_13_ng_container_4_ng_template_1_Template, 2, 1, "ng-template", null, 6, \u0275\u0275templateRefExtractor)(3, NgSelectComponent_ng_dropdown_panel_13_ng_container_4_ng_template_3_Template, 0, 0, "ng-template", 21);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const defaultNotFoundTemplate_r14 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.notFoundTemplate || defaultNotFoundTemplate_r14)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c4, ctx_r3.searchTerm));
  }
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 35);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r3.typeToSearchText);
  }
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_5_ng_template_3_Template(rf, ctx) {
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NgSelectComponent_ng_dropdown_panel_13_ng_container_5_ng_template_1_Template, 2, 1, "ng-template", null, 7, \u0275\u0275templateRefExtractor)(3, NgSelectComponent_ng_dropdown_panel_13_ng_container_5_ng_template_3_Template, 0, 0, "ng-template", 24);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const defaultTypeToSearchTemplate_r15 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.typeToSearchTemplate || defaultTypeToSearchTemplate_r15);
  }
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_6_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 35);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r3.loadingText);
  }
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_6_ng_template_3_Template(rf, ctx) {
}
function NgSelectComponent_ng_dropdown_panel_13_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NgSelectComponent_ng_dropdown_panel_13_ng_container_6_ng_template_1_Template, 2, 1, "ng-template", null, 8, \u0275\u0275templateRefExtractor)(3, NgSelectComponent_ng_dropdown_panel_13_ng_container_6_ng_template_3_Template, 0, 0, "ng-template", 21);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const defaultLoadingTextTemplate_r16 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.loadingTextTemplate || defaultLoadingTextTemplate_r16)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c4, ctx_r3.searchTerm));
  }
}
function NgSelectComponent_ng_dropdown_panel_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ng-dropdown-panel", 28);
    \u0275\u0275listener("update", function NgSelectComponent_ng_dropdown_panel_13_Template_ng_dropdown_panel_update_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.viewPortItems = $event);
    })("scroll", function NgSelectComponent_ng_dropdown_panel_13_Template_ng_dropdown_panel_scroll_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.scroll.emit($event));
    })("scrollToEnd", function NgSelectComponent_ng_dropdown_panel_13_Template_ng_dropdown_panel_scrollToEnd_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.scrollToEnd.emit($event));
    })("outsideClick", function NgSelectComponent_ng_dropdown_panel_13_Template_ng_dropdown_panel_outsideClick_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.close());
    });
    \u0275\u0275elementContainerStart(1);
    \u0275\u0275template(2, NgSelectComponent_ng_dropdown_panel_13_div_2_Template, 4, 22, "div", 29)(3, NgSelectComponent_ng_dropdown_panel_13_div_3_Template, 4, 6, "div", 30);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(4, NgSelectComponent_ng_dropdown_panel_13_ng_container_4_Template, 4, 4, "ng-container", 12)(5, NgSelectComponent_ng_dropdown_panel_13_ng_container_5_Template, 4, 1, "ng-container", 12)(6, NgSelectComponent_ng_dropdown_panel_13_ng_container_6_Template, 4, 4, "ng-container", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ng-select-multiple", ctx_r3.multiple);
    \u0275\u0275property("virtualScroll", ctx_r3.virtualScroll)("bufferAmount", ctx_r3.bufferAmount)("appendTo", ctx_r3.appendTo)("position", ctx_r3.dropdownPosition)("headerTemplate", ctx_r3.headerTemplate)("footerTemplate", ctx_r3.footerTemplate)("filterValue", ctx_r3.searchTerm)("items", ctx_r3.itemsList.filteredItems)("markedItem", ctx_r3.itemsList.markedItem)("ngClass", ctx_r3.appendTo ? ctx_r3.classes : null)("id", ctx_r3.dropdownId);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r3.viewPortItems)("ngForTrackBy", ctx_r3.trackByOption);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.showAddTag);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.showNoItemsFound());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.showTypeToSearch());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.loading && ctx_r3.itemsList.filteredItems.length === 0);
  }
}
var unescapedHTMLExp = /[&<>"']/g;
var hasUnescapedHTMLExp = RegExp(unescapedHTMLExp.source);
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHTML(value) {
  return value && hasUnescapedHTMLExp.test(value) ? value.replace(unescapedHTMLExp, (chr) => htmlEscapes[chr]) : value;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isObject2(value) {
  return typeof value === "object" && isDefined(value);
}
function isPromise2(value) {
  return value instanceof Promise;
}
function isFunction(value) {
  return value instanceof Function;
}
var _NgItemLabelDirective = class _NgItemLabelDirective {
  constructor(element) {
    this.element = element;
    this.escape = true;
  }
  ngOnChanges(changes) {
    this.element.nativeElement.innerHTML = this.escape ? escapeHTML(this.ngItemLabel) : this.ngItemLabel;
  }
};
_NgItemLabelDirective.\u0275fac = function NgItemLabelDirective_Factory(t) {
  return new (t || _NgItemLabelDirective)(\u0275\u0275directiveInject(ElementRef));
};
_NgItemLabelDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgItemLabelDirective,
  selectors: [["", "ngItemLabel", ""]],
  inputs: {
    ngItemLabel: "ngItemLabel",
    escape: "escape"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var NgItemLabelDirective = _NgItemLabelDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgItemLabelDirective, [{
    type: Directive,
    args: [{
      selector: "[ngItemLabel]"
    }]
  }], () => [{
    type: ElementRef
  }], {
    ngItemLabel: [{
      type: Input
    }],
    escape: [{
      type: Input
    }]
  });
})();
var _NgOptionTemplateDirective = class _NgOptionTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgOptionTemplateDirective.\u0275fac = function NgOptionTemplateDirective_Factory(t) {
  return new (t || _NgOptionTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgOptionTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgOptionTemplateDirective,
  selectors: [["", "ng-option-tmp", ""]]
});
var NgOptionTemplateDirective = _NgOptionTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptionTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-option-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgOptgroupTemplateDirective = class _NgOptgroupTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgOptgroupTemplateDirective.\u0275fac = function NgOptgroupTemplateDirective_Factory(t) {
  return new (t || _NgOptgroupTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgOptgroupTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgOptgroupTemplateDirective,
  selectors: [["", "ng-optgroup-tmp", ""]]
});
var NgOptgroupTemplateDirective = _NgOptgroupTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptgroupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-optgroup-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgLabelTemplateDirective = class _NgLabelTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgLabelTemplateDirective.\u0275fac = function NgLabelTemplateDirective_Factory(t) {
  return new (t || _NgLabelTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgLabelTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgLabelTemplateDirective,
  selectors: [["", "ng-label-tmp", ""]]
});
var NgLabelTemplateDirective = _NgLabelTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLabelTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-label-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgMultiLabelTemplateDirective = class _NgMultiLabelTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgMultiLabelTemplateDirective.\u0275fac = function NgMultiLabelTemplateDirective_Factory(t) {
  return new (t || _NgMultiLabelTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgMultiLabelTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgMultiLabelTemplateDirective,
  selectors: [["", "ng-multi-label-tmp", ""]]
});
var NgMultiLabelTemplateDirective = _NgMultiLabelTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgMultiLabelTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-multi-label-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgHeaderTemplateDirective = class _NgHeaderTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgHeaderTemplateDirective.\u0275fac = function NgHeaderTemplateDirective_Factory(t) {
  return new (t || _NgHeaderTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgHeaderTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgHeaderTemplateDirective,
  selectors: [["", "ng-header-tmp", ""]]
});
var NgHeaderTemplateDirective = _NgHeaderTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-header-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgFooterTemplateDirective = class _NgFooterTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgFooterTemplateDirective.\u0275fac = function NgFooterTemplateDirective_Factory(t) {
  return new (t || _NgFooterTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgFooterTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgFooterTemplateDirective,
  selectors: [["", "ng-footer-tmp", ""]]
});
var NgFooterTemplateDirective = _NgFooterTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgFooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-footer-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgNotFoundTemplateDirective = class _NgNotFoundTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgNotFoundTemplateDirective.\u0275fac = function NgNotFoundTemplateDirective_Factory(t) {
  return new (t || _NgNotFoundTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgNotFoundTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgNotFoundTemplateDirective,
  selectors: [["", "ng-notfound-tmp", ""]]
});
var NgNotFoundTemplateDirective = _NgNotFoundTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgNotFoundTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-notfound-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgTypeToSearchTemplateDirective = class _NgTypeToSearchTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgTypeToSearchTemplateDirective.\u0275fac = function NgTypeToSearchTemplateDirective_Factory(t) {
  return new (t || _NgTypeToSearchTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgTypeToSearchTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgTypeToSearchTemplateDirective,
  selectors: [["", "ng-typetosearch-tmp", ""]]
});
var NgTypeToSearchTemplateDirective = _NgTypeToSearchTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTypeToSearchTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-typetosearch-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgLoadingTextTemplateDirective = class _NgLoadingTextTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgLoadingTextTemplateDirective.\u0275fac = function NgLoadingTextTemplateDirective_Factory(t) {
  return new (t || _NgLoadingTextTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgLoadingTextTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgLoadingTextTemplateDirective,
  selectors: [["", "ng-loadingtext-tmp", ""]]
});
var NgLoadingTextTemplateDirective = _NgLoadingTextTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLoadingTextTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-loadingtext-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgTagTemplateDirective = class _NgTagTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgTagTemplateDirective.\u0275fac = function NgTagTemplateDirective_Factory(t) {
  return new (t || _NgTagTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgTagTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgTagTemplateDirective,
  selectors: [["", "ng-tag-tmp", ""]]
});
var NgTagTemplateDirective = _NgTagTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTagTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-tag-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NgLoadingSpinnerTemplateDirective = class _NgLoadingSpinnerTemplateDirective {
  constructor(template) {
    this.template = template;
  }
};
_NgLoadingSpinnerTemplateDirective.\u0275fac = function NgLoadingSpinnerTemplateDirective_Factory(t) {
  return new (t || _NgLoadingSpinnerTemplateDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NgLoadingSpinnerTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgLoadingSpinnerTemplateDirective,
  selectors: [["", "ng-loadingspinner-tmp", ""]]
});
var NgLoadingSpinnerTemplateDirective = _NgLoadingSpinnerTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLoadingSpinnerTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[ng-loadingspinner-tmp]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
function newId() {
  return "axxxxxxxxxxx".replace(/[x]/g, () => {
    const val = Math.random() * 16 | 0;
    return val.toString(16);
  });
}
var diacritics = {
  "\u24B6": "A",
  "\uFF21": "A",
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\u1EA6": "A",
  "\u1EA4": "A",
  "\u1EAA": "A",
  "\u1EA8": "A",
  "\xC3": "A",
  "\u0100": "A",
  "\u0102": "A",
  "\u1EB0": "A",
  "\u1EAE": "A",
  "\u1EB4": "A",
  "\u1EB2": "A",
  "\u0226": "A",
  "\u01E0": "A",
  "\xC4": "A",
  "\u01DE": "A",
  "\u1EA2": "A",
  "\xC5": "A",
  "\u01FA": "A",
  "\u01CD": "A",
  "\u0200": "A",
  "\u0202": "A",
  "\u1EA0": "A",
  "\u1EAC": "A",
  "\u1EB6": "A",
  "\u1E00": "A",
  "\u0104": "A",
  "\u023A": "A",
  "\u2C6F": "A",
  "\uA732": "AA",
  "\xC6": "AE",
  "\u01FC": "AE",
  "\u01E2": "AE",
  "\uA734": "AO",
  "\uA736": "AU",
  "\uA738": "AV",
  "\uA73A": "AV",
  "\uA73C": "AY",
  "\u24B7": "B",
  "\uFF22": "B",
  "\u1E02": "B",
  "\u1E04": "B",
  "\u1E06": "B",
  "\u0243": "B",
  "\u0182": "B",
  "\u0181": "B",
  "\u24B8": "C",
  "\uFF23": "C",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\xC7": "C",
  "\u1E08": "C",
  "\u0187": "C",
  "\u023B": "C",
  "\uA73E": "C",
  "\u24B9": "D",
  "\uFF24": "D",
  "\u1E0A": "D",
  "\u010E": "D",
  "\u1E0C": "D",
  "\u1E10": "D",
  "\u1E12": "D",
  "\u1E0E": "D",
  "\u0110": "D",
  "\u018B": "D",
  "\u018A": "D",
  "\u0189": "D",
  "\uA779": "D",
  "\u01F1": "DZ",
  "\u01C4": "DZ",
  "\u01F2": "Dz",
  "\u01C5": "Dz",
  "\u24BA": "E",
  "\uFF25": "E",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\u1EC0": "E",
  "\u1EBE": "E",
  "\u1EC4": "E",
  "\u1EC2": "E",
  "\u1EBC": "E",
  "\u0112": "E",
  "\u1E14": "E",
  "\u1E16": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\xCB": "E",
  "\u1EBA": "E",
  "\u011A": "E",
  "\u0204": "E",
  "\u0206": "E",
  "\u1EB8": "E",
  "\u1EC6": "E",
  "\u0228": "E",
  "\u1E1C": "E",
  "\u0118": "E",
  "\u1E18": "E",
  "\u1E1A": "E",
  "\u0190": "E",
  "\u018E": "E",
  "\u24BB": "F",
  "\uFF26": "F",
  "\u1E1E": "F",
  "\u0191": "F",
  "\uA77B": "F",
  "\u24BC": "G",
  "\uFF27": "G",
  "\u01F4": "G",
  "\u011C": "G",
  "\u1E20": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u01E6": "G",
  "\u0122": "G",
  "\u01E4": "G",
  "\u0193": "G",
  "\uA7A0": "G",
  "\uA77D": "G",
  "\uA77E": "G",
  "\u24BD": "H",
  "\uFF28": "H",
  "\u0124": "H",
  "\u1E22": "H",
  "\u1E26": "H",
  "\u021E": "H",
  "\u1E24": "H",
  "\u1E28": "H",
  "\u1E2A": "H",
  "\u0126": "H",
  "\u2C67": "H",
  "\u2C75": "H",
  "\uA78D": "H",
  "\u24BE": "I",
  "\uFF29": "I",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u0130": "I",
  "\xCF": "I",
  "\u1E2E": "I",
  "\u1EC8": "I",
  "\u01CF": "I",
  "\u0208": "I",
  "\u020A": "I",
  "\u1ECA": "I",
  "\u012E": "I",
  "\u1E2C": "I",
  "\u0197": "I",
  "\u24BF": "J",
  "\uFF2A": "J",
  "\u0134": "J",
  "\u0248": "J",
  "\u24C0": "K",
  "\uFF2B": "K",
  "\u1E30": "K",
  "\u01E8": "K",
  "\u1E32": "K",
  "\u0136": "K",
  "\u1E34": "K",
  "\u0198": "K",
  "\u2C69": "K",
  "\uA740": "K",
  "\uA742": "K",
  "\uA744": "K",
  "\uA7A2": "K",
  "\u24C1": "L",
  "\uFF2C": "L",
  "\u013F": "L",
  "\u0139": "L",
  "\u013D": "L",
  "\u1E36": "L",
  "\u1E38": "L",
  "\u013B": "L",
  "\u1E3C": "L",
  "\u1E3A": "L",
  "\u0141": "L",
  "\u023D": "L",
  "\u2C62": "L",
  "\u2C60": "L",
  "\uA748": "L",
  "\uA746": "L",
  "\uA780": "L",
  "\u01C7": "LJ",
  "\u01C8": "Lj",
  "\u24C2": "M",
  "\uFF2D": "M",
  "\u1E3E": "M",
  "\u1E40": "M",
  "\u1E42": "M",
  "\u2C6E": "M",
  "\u019C": "M",
  "\u24C3": "N",
  "\uFF2E": "N",
  "\u01F8": "N",
  "\u0143": "N",
  "\xD1": "N",
  "\u1E44": "N",
  "\u0147": "N",
  "\u1E46": "N",
  "\u0145": "N",
  "\u1E4A": "N",
  "\u1E48": "N",
  "\u0220": "N",
  "\u019D": "N",
  "\uA790": "N",
  "\uA7A4": "N",
  "\u01CA": "NJ",
  "\u01CB": "Nj",
  "\u24C4": "O",
  "\uFF2F": "O",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\u1ED2": "O",
  "\u1ED0": "O",
  "\u1ED6": "O",
  "\u1ED4": "O",
  "\xD5": "O",
  "\u1E4C": "O",
  "\u022C": "O",
  "\u1E4E": "O",
  "\u014C": "O",
  "\u1E50": "O",
  "\u1E52": "O",
  "\u014E": "O",
  "\u022E": "O",
  "\u0230": "O",
  "\xD6": "O",
  "\u022A": "O",
  "\u1ECE": "O",
  "\u0150": "O",
  "\u01D1": "O",
  "\u020C": "O",
  "\u020E": "O",
  "\u01A0": "O",
  "\u1EDC": "O",
  "\u1EDA": "O",
  "\u1EE0": "O",
  "\u1EDE": "O",
  "\u1EE2": "O",
  "\u1ECC": "O",
  "\u1ED8": "O",
  "\u01EA": "O",
  "\u01EC": "O",
  "\xD8": "O",
  "\u01FE": "O",
  "\u0186": "O",
  "\u019F": "O",
  "\uA74A": "O",
  "\uA74C": "O",
  "\u01A2": "OI",
  "\uA74E": "OO",
  "\u0222": "OU",
  "\u24C5": "P",
  "\uFF30": "P",
  "\u1E54": "P",
  "\u1E56": "P",
  "\u01A4": "P",
  "\u2C63": "P",
  "\uA750": "P",
  "\uA752": "P",
  "\uA754": "P",
  "\u24C6": "Q",
  "\uFF31": "Q",
  "\uA756": "Q",
  "\uA758": "Q",
  "\u024A": "Q",
  "\u24C7": "R",
  "\uFF32": "R",
  "\u0154": "R",
  "\u1E58": "R",
  "\u0158": "R",
  "\u0210": "R",
  "\u0212": "R",
  "\u1E5A": "R",
  "\u1E5C": "R",
  "\u0156": "R",
  "\u1E5E": "R",
  "\u024C": "R",
  "\u2C64": "R",
  "\uA75A": "R",
  "\uA7A6": "R",
  "\uA782": "R",
  "\u24C8": "S",
  "\uFF33": "S",
  "\u1E9E": "S",
  "\u015A": "S",
  "\u1E64": "S",
  "\u015C": "S",
  "\u1E60": "S",
  "\u0160": "S",
  "\u1E66": "S",
  "\u1E62": "S",
  "\u1E68": "S",
  "\u0218": "S",
  "\u015E": "S",
  "\u2C7E": "S",
  "\uA7A8": "S",
  "\uA784": "S",
  "\u24C9": "T",
  "\uFF34": "T",
  "\u1E6A": "T",
  "\u0164": "T",
  "\u1E6C": "T",
  "\u021A": "T",
  "\u0162": "T",
  "\u1E70": "T",
  "\u1E6E": "T",
  "\u0166": "T",
  "\u01AC": "T",
  "\u01AE": "T",
  "\u023E": "T",
  "\uA786": "T",
  "\uA728": "TZ",
  "\u24CA": "U",
  "\uFF35": "U",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\u0168": "U",
  "\u1E78": "U",
  "\u016A": "U",
  "\u1E7A": "U",
  "\u016C": "U",
  "\xDC": "U",
  "\u01DB": "U",
  "\u01D7": "U",
  "\u01D5": "U",
  "\u01D9": "U",
  "\u1EE6": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u01D3": "U",
  "\u0214": "U",
  "\u0216": "U",
  "\u01AF": "U",
  "\u1EEA": "U",
  "\u1EE8": "U",
  "\u1EEE": "U",
  "\u1EEC": "U",
  "\u1EF0": "U",
  "\u1EE4": "U",
  "\u1E72": "U",
  "\u0172": "U",
  "\u1E76": "U",
  "\u1E74": "U",
  "\u0244": "U",
  "\u24CB": "V",
  "\uFF36": "V",
  "\u1E7C": "V",
  "\u1E7E": "V",
  "\u01B2": "V",
  "\uA75E": "V",
  "\u0245": "V",
  "\uA760": "VY",
  "\u24CC": "W",
  "\uFF37": "W",
  "\u1E80": "W",
  "\u1E82": "W",
  "\u0174": "W",
  "\u1E86": "W",
  "\u1E84": "W",
  "\u1E88": "W",
  "\u2C72": "W",
  "\u24CD": "X",
  "\uFF38": "X",
  "\u1E8A": "X",
  "\u1E8C": "X",
  "\u24CE": "Y",
  "\uFF39": "Y",
  "\u1EF2": "Y",
  "\xDD": "Y",
  "\u0176": "Y",
  "\u1EF8": "Y",
  "\u0232": "Y",
  "\u1E8E": "Y",
  "\u0178": "Y",
  "\u1EF6": "Y",
  "\u1EF4": "Y",
  "\u01B3": "Y",
  "\u024E": "Y",
  "\u1EFE": "Y",
  "\u24CF": "Z",
  "\uFF3A": "Z",
  "\u0179": "Z",
  "\u1E90": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u1E92": "Z",
  "\u1E94": "Z",
  "\u01B5": "Z",
  "\u0224": "Z",
  "\u2C7F": "Z",
  "\u2C6B": "Z",
  "\uA762": "Z",
  "\u24D0": "a",
  "\uFF41": "a",
  "\u1E9A": "a",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\u1EA7": "a",
  "\u1EA5": "a",
  "\u1EAB": "a",
  "\u1EA9": "a",
  "\xE3": "a",
  "\u0101": "a",
  "\u0103": "a",
  "\u1EB1": "a",
  "\u1EAF": "a",
  "\u1EB5": "a",
  "\u1EB3": "a",
  "\u0227": "a",
  "\u01E1": "a",
  "\xE4": "a",
  "\u01DF": "a",
  "\u1EA3": "a",
  "\xE5": "a",
  "\u01FB": "a",
  "\u01CE": "a",
  "\u0201": "a",
  "\u0203": "a",
  "\u1EA1": "a",
  "\u1EAD": "a",
  "\u1EB7": "a",
  "\u1E01": "a",
  "\u0105": "a",
  "\u2C65": "a",
  "\u0250": "a",
  "\uA733": "aa",
  "\xE6": "ae",
  "\u01FD": "ae",
  "\u01E3": "ae",
  "\uA735": "ao",
  "\uA737": "au",
  "\uA739": "av",
  "\uA73B": "av",
  "\uA73D": "ay",
  "\u24D1": "b",
  "\uFF42": "b",
  "\u1E03": "b",
  "\u1E05": "b",
  "\u1E07": "b",
  "\u0180": "b",
  "\u0183": "b",
  "\u0253": "b",
  "\u24D2": "c",
  "\uFF43": "c",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\xE7": "c",
  "\u1E09": "c",
  "\u0188": "c",
  "\u023C": "c",
  "\uA73F": "c",
  "\u2184": "c",
  "\u24D3": "d",
  "\uFF44": "d",
  "\u1E0B": "d",
  "\u010F": "d",
  "\u1E0D": "d",
  "\u1E11": "d",
  "\u1E13": "d",
  "\u1E0F": "d",
  "\u0111": "d",
  "\u018C": "d",
  "\u0256": "d",
  "\u0257": "d",
  "\uA77A": "d",
  "\u01F3": "dz",
  "\u01C6": "dz",
  "\u24D4": "e",
  "\uFF45": "e",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\u1EC1": "e",
  "\u1EBF": "e",
  "\u1EC5": "e",
  "\u1EC3": "e",
  "\u1EBD": "e",
  "\u0113": "e",
  "\u1E15": "e",
  "\u1E17": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\xEB": "e",
  "\u1EBB": "e",
  "\u011B": "e",
  "\u0205": "e",
  "\u0207": "e",
  "\u1EB9": "e",
  "\u1EC7": "e",
  "\u0229": "e",
  "\u1E1D": "e",
  "\u0119": "e",
  "\u1E19": "e",
  "\u1E1B": "e",
  "\u0247": "e",
  "\u025B": "e",
  "\u01DD": "e",
  "\u24D5": "f",
  "\uFF46": "f",
  "\u1E1F": "f",
  "\u0192": "f",
  "\uA77C": "f",
  "\u24D6": "g",
  "\uFF47": "g",
  "\u01F5": "g",
  "\u011D": "g",
  "\u1E21": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u01E7": "g",
  "\u0123": "g",
  "\u01E5": "g",
  "\u0260": "g",
  "\uA7A1": "g",
  "\u1D79": "g",
  "\uA77F": "g",
  "\u24D7": "h",
  "\uFF48": "h",
  "\u0125": "h",
  "\u1E23": "h",
  "\u1E27": "h",
  "\u021F": "h",
  "\u1E25": "h",
  "\u1E29": "h",
  "\u1E2B": "h",
  "\u1E96": "h",
  "\u0127": "h",
  "\u2C68": "h",
  "\u2C76": "h",
  "\u0265": "h",
  "\u0195": "hv",
  "\u24D8": "i",
  "\uFF49": "i",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\xEF": "i",
  "\u1E2F": "i",
  "\u1EC9": "i",
  "\u01D0": "i",
  "\u0209": "i",
  "\u020B": "i",
  "\u1ECB": "i",
  "\u012F": "i",
  "\u1E2D": "i",
  "\u0268": "i",
  "\u0131": "i",
  "\u24D9": "j",
  "\uFF4A": "j",
  "\u0135": "j",
  "\u01F0": "j",
  "\u0249": "j",
  "\u24DA": "k",
  "\uFF4B": "k",
  "\u1E31": "k",
  "\u01E9": "k",
  "\u1E33": "k",
  "\u0137": "k",
  "\u1E35": "k",
  "\u0199": "k",
  "\u2C6A": "k",
  "\uA741": "k",
  "\uA743": "k",
  "\uA745": "k",
  "\uA7A3": "k",
  "\u24DB": "l",
  "\uFF4C": "l",
  "\u0140": "l",
  "\u013A": "l",
  "\u013E": "l",
  "\u1E37": "l",
  "\u1E39": "l",
  "\u013C": "l",
  "\u1E3D": "l",
  "\u1E3B": "l",
  "\u017F": "l",
  "\u0142": "l",
  "\u019A": "l",
  "\u026B": "l",
  "\u2C61": "l",
  "\uA749": "l",
  "\uA781": "l",
  "\uA747": "l",
  "\u01C9": "lj",
  "\u24DC": "m",
  "\uFF4D": "m",
  "\u1E3F": "m",
  "\u1E41": "m",
  "\u1E43": "m",
  "\u0271": "m",
  "\u026F": "m",
  "\u24DD": "n",
  "\uFF4E": "n",
  "\u01F9": "n",
  "\u0144": "n",
  "\xF1": "n",
  "\u1E45": "n",
  "\u0148": "n",
  "\u1E47": "n",
  "\u0146": "n",
  "\u1E4B": "n",
  "\u1E49": "n",
  "\u019E": "n",
  "\u0272": "n",
  "\u0149": "n",
  "\uA791": "n",
  "\uA7A5": "n",
  "\u01CC": "nj",
  "\u24DE": "o",
  "\uFF4F": "o",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\u1ED3": "o",
  "\u1ED1": "o",
  "\u1ED7": "o",
  "\u1ED5": "o",
  "\xF5": "o",
  "\u1E4D": "o",
  "\u022D": "o",
  "\u1E4F": "o",
  "\u014D": "o",
  "\u1E51": "o",
  "\u1E53": "o",
  "\u014F": "o",
  "\u022F": "o",
  "\u0231": "o",
  "\xF6": "o",
  "\u022B": "o",
  "\u1ECF": "o",
  "\u0151": "o",
  "\u01D2": "o",
  "\u020D": "o",
  "\u020F": "o",
  "\u01A1": "o",
  "\u1EDD": "o",
  "\u1EDB": "o",
  "\u1EE1": "o",
  "\u1EDF": "o",
  "\u1EE3": "o",
  "\u1ECD": "o",
  "\u1ED9": "o",
  "\u01EB": "o",
  "\u01ED": "o",
  "\xF8": "o",
  "\u01FF": "o",
  "\u0254": "o",
  "\uA74B": "o",
  "\uA74D": "o",
  "\u0275": "o",
  "\u01A3": "oi",
  "\u0223": "ou",
  "\uA74F": "oo",
  "\u24DF": "p",
  "\uFF50": "p",
  "\u1E55": "p",
  "\u1E57": "p",
  "\u01A5": "p",
  "\u1D7D": "p",
  "\uA751": "p",
  "\uA753": "p",
  "\uA755": "p",
  "\u24E0": "q",
  "\uFF51": "q",
  "\u024B": "q",
  "\uA757": "q",
  "\uA759": "q",
  "\u24E1": "r",
  "\uFF52": "r",
  "\u0155": "r",
  "\u1E59": "r",
  "\u0159": "r",
  "\u0211": "r",
  "\u0213": "r",
  "\u1E5B": "r",
  "\u1E5D": "r",
  "\u0157": "r",
  "\u1E5F": "r",
  "\u024D": "r",
  "\u027D": "r",
  "\uA75B": "r",
  "\uA7A7": "r",
  "\uA783": "r",
  "\u24E2": "s",
  "\uFF53": "s",
  "\xDF": "s",
  "\u015B": "s",
  "\u1E65": "s",
  "\u015D": "s",
  "\u1E61": "s",
  "\u0161": "s",
  "\u1E67": "s",
  "\u1E63": "s",
  "\u1E69": "s",
  "\u0219": "s",
  "\u015F": "s",
  "\u023F": "s",
  "\uA7A9": "s",
  "\uA785": "s",
  "\u1E9B": "s",
  "\u24E3": "t",
  "\uFF54": "t",
  "\u1E6B": "t",
  "\u1E97": "t",
  "\u0165": "t",
  "\u1E6D": "t",
  "\u021B": "t",
  "\u0163": "t",
  "\u1E71": "t",
  "\u1E6F": "t",
  "\u0167": "t",
  "\u01AD": "t",
  "\u0288": "t",
  "\u2C66": "t",
  "\uA787": "t",
  "\uA729": "tz",
  "\u24E4": "u",
  "\uFF55": "u",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\u0169": "u",
  "\u1E79": "u",
  "\u016B": "u",
  "\u1E7B": "u",
  "\u016D": "u",
  "\xFC": "u",
  "\u01DC": "u",
  "\u01D8": "u",
  "\u01D6": "u",
  "\u01DA": "u",
  "\u1EE7": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u01D4": "u",
  "\u0215": "u",
  "\u0217": "u",
  "\u01B0": "u",
  "\u1EEB": "u",
  "\u1EE9": "u",
  "\u1EEF": "u",
  "\u1EED": "u",
  "\u1EF1": "u",
  "\u1EE5": "u",
  "\u1E73": "u",
  "\u0173": "u",
  "\u1E77": "u",
  "\u1E75": "u",
  "\u0289": "u",
  "\u24E5": "v",
  "\uFF56": "v",
  "\u1E7D": "v",
  "\u1E7F": "v",
  "\u028B": "v",
  "\uA75F": "v",
  "\u028C": "v",
  "\uA761": "vy",
  "\u24E6": "w",
  "\uFF57": "w",
  "\u1E81": "w",
  "\u1E83": "w",
  "\u0175": "w",
  "\u1E87": "w",
  "\u1E85": "w",
  "\u1E98": "w",
  "\u1E89": "w",
  "\u2C73": "w",
  "\u24E7": "x",
  "\uFF58": "x",
  "\u1E8B": "x",
  "\u1E8D": "x",
  "\u24E8": "y",
  "\uFF59": "y",
  "\u1EF3": "y",
  "\xFD": "y",
  "\u0177": "y",
  "\u1EF9": "y",
  "\u0233": "y",
  "\u1E8F": "y",
  "\xFF": "y",
  "\u1EF7": "y",
  "\u1E99": "y",
  "\u1EF5": "y",
  "\u01B4": "y",
  "\u024F": "y",
  "\u1EFF": "y",
  "\u24E9": "z",
  "\uFF5A": "z",
  "\u017A": "z",
  "\u1E91": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u1E93": "z",
  "\u1E95": "z",
  "\u01B6": "z",
  "\u0225": "z",
  "\u0240": "z",
  "\u2C6C": "z",
  "\uA763": "z",
  "\u0386": "\u0391",
  "\u0388": "\u0395",
  "\u0389": "\u0397",
  "\u038A": "\u0399",
  "\u03AA": "\u0399",
  "\u038C": "\u039F",
  "\u038E": "\u03A5",
  "\u03AB": "\u03A5",
  "\u038F": "\u03A9",
  "\u03AC": "\u03B1",
  "\u03AD": "\u03B5",
  "\u03AE": "\u03B7",
  "\u03AF": "\u03B9",
  "\u03CA": "\u03B9",
  "\u0390": "\u03B9",
  "\u03CC": "\u03BF",
  "\u03CD": "\u03C5",
  "\u03CB": "\u03C5",
  "\u03B0": "\u03C5",
  "\u03C9": "\u03C9",
  "\u03C2": "\u03C3"
};
function stripSpecialChars(text) {
  const match = (a) => diacritics[a] || a;
  return text.replace(/[^\u0000-\u007E]/g, match);
}
var ItemsList = class {
  constructor(_ngSelect, _selectionModel) {
    this._ngSelect = _ngSelect;
    this._selectionModel = _selectionModel;
    this._items = [];
    this._filteredItems = [];
    this._markedIndex = -1;
  }
  get items() {
    return this._items;
  }
  get filteredItems() {
    return this._filteredItems;
  }
  get markedIndex() {
    return this._markedIndex;
  }
  get selectedItems() {
    return this._selectionModel.value;
  }
  get markedItem() {
    return this._filteredItems[this._markedIndex];
  }
  get noItemsToSelect() {
    return this._ngSelect.hideSelected && this._items.length === this.selectedItems.length;
  }
  get maxItemsSelected() {
    return this._ngSelect.multiple && this._ngSelect.maxSelectedItems <= this.selectedItems.length;
  }
  get lastSelectedItem() {
    let i = this.selectedItems.length - 1;
    for (; i >= 0; i--) {
      const item = this.selectedItems[i];
      if (!item.disabled) {
        return item;
      }
    }
    return null;
  }
  setItems(items) {
    this._items = items.map((item, index) => this.mapItem(item, index));
    if (this._ngSelect.groupBy) {
      this._groups = this._groupBy(this._items, this._ngSelect.groupBy);
      this._items = this._flatten(this._groups);
    } else {
      this._groups = /* @__PURE__ */ new Map();
      this._groups.set(void 0, this._items);
    }
    this._filteredItems = [...this._items];
  }
  select(item) {
    if (item.selected || this.maxItemsSelected) {
      return;
    }
    const multiple = this._ngSelect.multiple;
    if (!multiple) {
      this.clearSelected();
    }
    this._selectionModel.select(item, multiple, this._ngSelect.selectableGroupAsModel);
    if (this._ngSelect.hideSelected) {
      this._hideSelected(item);
    }
  }
  unselect(item) {
    if (!item.selected) {
      return;
    }
    this._selectionModel.unselect(item, this._ngSelect.multiple);
    if (this._ngSelect.hideSelected && isDefined(item.index) && this._ngSelect.multiple) {
      this._showSelected(item);
    }
  }
  findItem(value) {
    let findBy;
    if (this._ngSelect.compareWith) {
      findBy = (item) => this._ngSelect.compareWith(item.value, value);
    } else if (this._ngSelect.bindValue) {
      findBy = (item) => !item.children && this.resolveNested(item.value, this._ngSelect.bindValue) === value;
    } else {
      findBy = (item) => item.value === value || !item.children && item.label && item.label === this.resolveNested(value, this._ngSelect.bindLabel);
    }
    return this._items.find((item) => findBy(item));
  }
  addItem(item) {
    const option = this.mapItem(item, this._items.length);
    this._items.push(option);
    this._filteredItems.push(option);
    return option;
  }
  clearSelected(keepDisabled = false) {
    this._selectionModel.clear(keepDisabled);
    this._items.forEach((item) => {
      item.selected = keepDisabled && item.selected && item.disabled;
      item.marked = false;
    });
    if (this._ngSelect.hideSelected) {
      this.resetFilteredItems();
    }
  }
  findByLabel(term) {
    term = stripSpecialChars(term).toLocaleLowerCase();
    return this.filteredItems.find((item) => {
      const label = stripSpecialChars(item.label).toLocaleLowerCase();
      return label.substr(0, term.length) === term;
    });
  }
  filter(term) {
    if (!term) {
      this.resetFilteredItems();
      return;
    }
    this._filteredItems = [];
    term = this._ngSelect.searchFn ? term : stripSpecialChars(term).toLocaleLowerCase();
    const match = this._ngSelect.searchFn || this._defaultSearchFn;
    const hideSelected = this._ngSelect.hideSelected;
    for (const key of Array.from(this._groups.keys())) {
      const matchedItems = [];
      for (const item of this._groups.get(key)) {
        if (hideSelected && (item.parent && item.parent.selected || item.selected)) {
          continue;
        }
        const searchItem = this._ngSelect.searchFn ? item.value : item;
        if (match(term, searchItem)) {
          matchedItems.push(item);
        }
      }
      if (matchedItems.length > 0) {
        const [last] = matchedItems.slice(-1);
        if (last.parent) {
          const head = this._items.find((x) => x === last.parent);
          this._filteredItems.push(head);
        }
        this._filteredItems.push(...matchedItems);
      }
    }
  }
  resetFilteredItems() {
    if (this._filteredItems.length === this._items.length) {
      return;
    }
    if (this._ngSelect.hideSelected && this.selectedItems.length > 0) {
      this._filteredItems = this._items.filter((x) => !x.selected);
    } else {
      this._filteredItems = this._items;
    }
  }
  unmarkItem() {
    this._markedIndex = -1;
  }
  markNextItem() {
    this._stepToItem(1);
  }
  markPreviousItem() {
    this._stepToItem(-1);
  }
  markItem(item) {
    this._markedIndex = this._filteredItems.indexOf(item);
  }
  markSelectedOrDefault(markDefault) {
    if (this._filteredItems.length === 0) {
      return;
    }
    const lastMarkedIndex = this._getLastMarkedIndex();
    if (lastMarkedIndex > -1) {
      this._markedIndex = lastMarkedIndex;
    } else {
      this._markedIndex = markDefault ? this.filteredItems.findIndex((x) => !x.disabled) : -1;
    }
  }
  resolveNested(option, key) {
    if (!isObject2(option)) {
      return option;
    }
    if (key.indexOf(".") === -1) {
      return option[key];
    } else {
      const keys = key.split(".");
      let value = option;
      for (let i = 0, len = keys.length; i < len; ++i) {
        if (value == null) {
          return null;
        }
        value = value[keys[i]];
      }
      return value;
    }
  }
  mapItem(item, index) {
    const label = isDefined(item.$ngOptionLabel) ? item.$ngOptionLabel : this.resolveNested(item, this._ngSelect.bindLabel);
    const value = isDefined(item.$ngOptionValue) ? item.$ngOptionValue : item;
    return {
      index,
      label: isDefined(label) ? label.toString() : "",
      value,
      disabled: item.disabled,
      htmlId: `${this._ngSelect.dropdownId}-${index}`
    };
  }
  mapSelectedItems() {
    const multiple = this._ngSelect.multiple;
    for (const selected of this.selectedItems) {
      const value = this._ngSelect.bindValue ? this.resolveNested(selected.value, this._ngSelect.bindValue) : selected.value;
      const item = isDefined(value) ? this.findItem(value) : null;
      this._selectionModel.unselect(selected, multiple);
      this._selectionModel.select(item || selected, multiple, this._ngSelect.selectableGroupAsModel);
    }
    if (this._ngSelect.hideSelected) {
      this._filteredItems = this.filteredItems.filter((x) => this.selectedItems.indexOf(x) === -1);
    }
  }
  _showSelected(item) {
    this._filteredItems.push(item);
    if (item.parent) {
      const parent = item.parent;
      const parentExists = this._filteredItems.find((x) => x === parent);
      if (!parentExists) {
        this._filteredItems.push(parent);
      }
    } else if (item.children) {
      for (const child of item.children) {
        child.selected = false;
        this._filteredItems.push(child);
      }
    }
    this._filteredItems = [...this._filteredItems.sort((a, b) => a.index - b.index)];
  }
  _hideSelected(item) {
    this._filteredItems = this._filteredItems.filter((x) => x !== item);
    if (item.parent) {
      const children = item.parent.children;
      if (children.every((x) => x.selected)) {
        this._filteredItems = this._filteredItems.filter((x) => x !== item.parent);
      }
    } else if (item.children) {
      this._filteredItems = this.filteredItems.filter((x) => x.parent !== item);
    }
  }
  _defaultSearchFn(search, opt) {
    const label = stripSpecialChars(opt.label).toLocaleLowerCase();
    return label.indexOf(search) > -1;
  }
  _getNextItemIndex(steps) {
    if (steps > 0) {
      return this._markedIndex >= this._filteredItems.length - 1 ? 0 : this._markedIndex + 1;
    }
    return this._markedIndex <= 0 ? this._filteredItems.length - 1 : this._markedIndex - 1;
  }
  _stepToItem(steps) {
    if (this._filteredItems.length === 0 || this._filteredItems.every((x) => x.disabled)) {
      return;
    }
    this._markedIndex = this._getNextItemIndex(steps);
    if (this.markedItem.disabled) {
      this._stepToItem(steps);
    }
  }
  _getLastMarkedIndex() {
    if (this._ngSelect.hideSelected) {
      return -1;
    }
    if (this._markedIndex > -1 && this.markedItem === void 0) {
      return -1;
    }
    const selectedIndex = this._filteredItems.indexOf(this.lastSelectedItem);
    if (this.lastSelectedItem && selectedIndex < 0) {
      return -1;
    }
    return Math.max(this.markedIndex, selectedIndex);
  }
  _groupBy(items, prop) {
    const groups = /* @__PURE__ */ new Map();
    if (items.length === 0) {
      return groups;
    }
    if (Array.isArray(items[0].value[prop])) {
      for (const item of items) {
        const children = (item.value[prop] || []).map((x, index) => this.mapItem(x, index));
        groups.set(item, children);
      }
      return groups;
    }
    const isFnKey = isFunction(this._ngSelect.groupBy);
    const keyFn = (item) => {
      const key = isFnKey ? prop(item.value) : item.value[prop];
      return isDefined(key) ? key : void 0;
    };
    for (const item of items) {
      const key = keyFn(item);
      const group = groups.get(key);
      if (group) {
        group.push(item);
      } else {
        groups.set(key, [item]);
      }
    }
    return groups;
  }
  _flatten(groups) {
    const isGroupByFn = isFunction(this._ngSelect.groupBy);
    const items = [];
    for (const key of Array.from(groups.keys())) {
      let i = items.length;
      if (key === void 0) {
        const withoutGroup = groups.get(void 0) || [];
        items.push(...withoutGroup.map((x) => {
          x.index = i++;
          return x;
        }));
        continue;
      }
      const isObjectKey = isObject2(key);
      const parent = {
        label: isObjectKey ? "" : String(key),
        children: void 0,
        parent: null,
        index: i++,
        disabled: !this._ngSelect.selectableGroup,
        htmlId: newId()
      };
      const groupKey = isGroupByFn ? this._ngSelect.bindLabel : this._ngSelect.groupBy;
      const groupValue = this._ngSelect.groupValue || (() => {
        if (isObjectKey) {
          return key.value;
        }
        return {
          [groupKey]: key
        };
      });
      const children = groups.get(key).map((x) => {
        x.parent = parent;
        x.children = void 0;
        x.index = i++;
        return x;
      });
      parent.children = children;
      parent.value = groupValue(key, children.map((x) => x.value));
      items.push(parent);
      items.push(...children);
    }
    return items;
  }
};
var KeyCode;
(function(KeyCode2) {
  KeyCode2[KeyCode2["Tab"] = 9] = "Tab";
  KeyCode2[KeyCode2["Enter"] = 13] = "Enter";
  KeyCode2[KeyCode2["Esc"] = 27] = "Esc";
  KeyCode2[KeyCode2["Space"] = 32] = "Space";
  KeyCode2[KeyCode2["ArrowUp"] = 38] = "ArrowUp";
  KeyCode2[KeyCode2["ArrowDown"] = 40] = "ArrowDown";
  KeyCode2[KeyCode2["Backspace"] = 8] = "Backspace";
})(KeyCode || (KeyCode = {}));
var _NgDropdownPanelService = class _NgDropdownPanelService {
  constructor() {
    this._dimensions = {
      itemHeight: 0,
      panelHeight: 0,
      itemsPerViewport: 0
    };
  }
  get dimensions() {
    return this._dimensions;
  }
  calculateItems(scrollPos, itemsLength, buffer) {
    const d = this._dimensions;
    const scrollHeight = d.itemHeight * itemsLength;
    const scrollTop = Math.max(0, scrollPos);
    const indexByScrollTop = scrollTop / scrollHeight * itemsLength;
    let end = Math.min(itemsLength, Math.ceil(indexByScrollTop) + (d.itemsPerViewport + 1));
    const maxStartEnd = end;
    const maxStart = Math.max(0, maxStartEnd - d.itemsPerViewport);
    let start = Math.min(maxStart, Math.floor(indexByScrollTop));
    let topPadding = d.itemHeight * Math.ceil(start) - d.itemHeight * Math.min(start, buffer);
    topPadding = !isNaN(topPadding) ? topPadding : 0;
    start = !isNaN(start) ? start : -1;
    end = !isNaN(end) ? end : -1;
    start -= buffer;
    start = Math.max(0, start);
    end += buffer;
    end = Math.min(itemsLength, end);
    return {
      topPadding,
      scrollHeight,
      start,
      end
    };
  }
  setDimensions(itemHeight, panelHeight) {
    const itemsPerViewport = Math.max(1, Math.floor(panelHeight / itemHeight));
    this._dimensions = {
      itemHeight,
      panelHeight,
      itemsPerViewport
    };
  }
  getScrollTo(itemTop, itemHeight, lastScroll) {
    const {
      panelHeight
    } = this.dimensions;
    const itemBottom = itemTop + itemHeight;
    const top = lastScroll;
    const bottom = top + panelHeight;
    if (panelHeight >= itemBottom && lastScroll === itemTop) {
      return null;
    }
    if (itemBottom > bottom) {
      return top + itemBottom - bottom;
    } else if (itemTop <= top) {
      return itemTop;
    }
    return null;
  }
};
_NgDropdownPanelService.\u0275fac = function NgDropdownPanelService_Factory(t) {
  return new (t || _NgDropdownPanelService)();
};
_NgDropdownPanelService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NgDropdownPanelService,
  factory: _NgDropdownPanelService.\u0275fac
});
var NgDropdownPanelService = _NgDropdownPanelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgDropdownPanelService, [{
    type: Injectable
  }], null, null);
})();
var CSS_POSITIONS = ["top", "right", "bottom", "left"];
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var _NgDropdownPanelComponent = class _NgDropdownPanelComponent {
  constructor(_renderer, _zone, _panelService, _elementRef, _document) {
    this._renderer = _renderer;
    this._zone = _zone;
    this._panelService = _panelService;
    this._document = _document;
    this.items = [];
    this.position = "auto";
    this.virtualScroll = false;
    this.filterValue = null;
    this.update = new EventEmitter();
    this.scroll = new EventEmitter();
    this.scrollToEnd = new EventEmitter();
    this.outsideClick = new EventEmitter();
    this._destroy$ = new Subject();
    this._scrollToEndFired = false;
    this._updateScrollHeight = false;
    this._lastScrollPosition = 0;
    this._dropdown = _elementRef.nativeElement;
  }
  get currentPosition() {
    return this._currentPosition;
  }
  get itemsLength() {
    return this._itemsLength;
  }
  set itemsLength(value) {
    if (value !== this._itemsLength) {
      this._itemsLength = value;
      this._onItemsLengthChanged();
    }
  }
  get _startOffset() {
    if (this.markedItem) {
      const {
        itemHeight,
        panelHeight
      } = this._panelService.dimensions;
      const offset = this.markedItem.index * itemHeight;
      return panelHeight > offset ? 0 : offset;
    }
    return 0;
  }
  ngOnInit() {
    this._select = this._dropdown.parentElement;
    this._virtualPadding = this.paddingElementRef.nativeElement;
    this._scrollablePanel = this.scrollElementRef.nativeElement;
    this._contentPanel = this.contentElementRef.nativeElement;
    this._handleScroll();
    this._handleOutsideClick();
    this._appendDropdown();
    this._setupMousedownListener();
  }
  ngOnChanges(changes) {
    if (changes.items) {
      const change = changes.items;
      this._onItemsChange(change.currentValue, change.firstChange);
    }
  }
  ngOnDestroy() {
    this._destroy$.next();
    this._destroy$.complete();
    this._destroy$.unsubscribe();
    if (this.appendTo) {
      this._renderer.removeChild(this._dropdown.parentNode, this._dropdown);
    }
  }
  scrollTo(option, startFromOption = false) {
    if (!option) {
      return;
    }
    const index = this.items.indexOf(option);
    if (index < 0 || index >= this.itemsLength) {
      return;
    }
    let scrollTo;
    if (this.virtualScroll) {
      const itemHeight = this._panelService.dimensions.itemHeight;
      scrollTo = this._panelService.getScrollTo(index * itemHeight, itemHeight, this._lastScrollPosition);
    } else {
      const item = this._dropdown.querySelector(`#${option.htmlId}`);
      const lastScroll = startFromOption ? item.offsetTop : this._lastScrollPosition;
      scrollTo = this._panelService.getScrollTo(item.offsetTop, item.clientHeight, lastScroll);
    }
    if (isDefined(scrollTo)) {
      this._scrollablePanel.scrollTop = scrollTo;
    }
  }
  scrollToTag() {
    const panel = this._scrollablePanel;
    panel.scrollTop = panel.scrollHeight - panel.clientHeight;
  }
  adjustPosition() {
    this._updateYPosition();
  }
  _handleDropdownPosition() {
    this._currentPosition = this._calculateCurrentPosition(this._dropdown);
    if (CSS_POSITIONS.includes(this._currentPosition)) {
      this._updateDropdownClass(this._currentPosition);
    } else {
      this._updateDropdownClass("bottom");
    }
    if (this.appendTo) {
      this._updateYPosition();
    }
    this._dropdown.style.opacity = "1";
  }
  _updateDropdownClass(currentPosition) {
    CSS_POSITIONS.forEach((position) => {
      const REMOVE_CSS_CLASS = `ng-select-${position}`;
      this._renderer.removeClass(this._dropdown, REMOVE_CSS_CLASS);
      this._renderer.removeClass(this._select, REMOVE_CSS_CLASS);
    });
    const ADD_CSS_CLASS = `ng-select-${currentPosition}`;
    this._renderer.addClass(this._dropdown, ADD_CSS_CLASS);
    this._renderer.addClass(this._select, ADD_CSS_CLASS);
  }
  _handleScroll() {
    this._zone.runOutsideAngular(() => {
      fromEvent(this.scrollElementRef.nativeElement, "scroll").pipe(takeUntil(this._destroy$), auditTime(0, SCROLL_SCHEDULER)).subscribe((e) => {
        const path = e.path || e.composedPath && e.composedPath();
        if (!path || path.length === 0 && !e.target) {
          return;
        }
        const scrollTop = !path || path.length === 0 ? e.target.scrollTop : path[0].scrollTop;
        this._onContentScrolled(scrollTop);
      });
    });
  }
  _handleOutsideClick() {
    if (!this._document) {
      return;
    }
    this._zone.runOutsideAngular(() => {
      merge(fromEvent(this._document, "touchstart", {
        capture: true
      }), fromEvent(this._document, "mousedown", {
        capture: true
      })).pipe(takeUntil(this._destroy$)).subscribe(($event) => this._checkToClose($event));
    });
  }
  _checkToClose($event) {
    if (this._select.contains($event.target) || this._dropdown.contains($event.target)) {
      return;
    }
    const path = $event.path || $event.composedPath && $event.composedPath();
    if ($event.target && $event.target.shadowRoot && path && path[0] && this._select.contains(path[0])) {
      return;
    }
    this._zone.run(() => this.outsideClick.emit());
  }
  _onItemsChange(items, firstChange) {
    this.items = items || [];
    this._scrollToEndFired = false;
    this.itemsLength = items.length;
    if (this.virtualScroll) {
      this._updateItemsRange(firstChange);
    } else {
      this._setVirtualHeight();
      this._updateItems(firstChange);
    }
  }
  _updateItems(firstChange) {
    this.update.emit(this.items);
    if (firstChange === false) {
      return;
    }
    this._zone.runOutsideAngular(() => {
      Promise.resolve().then(() => {
        const panelHeight = this._scrollablePanel.clientHeight;
        this._panelService.setDimensions(0, panelHeight);
        this._handleDropdownPosition();
        this.scrollTo(this.markedItem, firstChange);
      });
    });
  }
  _updateItemsRange(firstChange) {
    this._zone.runOutsideAngular(() => {
      this._measureDimensions().then(() => {
        if (firstChange) {
          this._renderItemsRange(this._startOffset);
          this._handleDropdownPosition();
        } else {
          this._renderItemsRange();
        }
      });
    });
  }
  _onContentScrolled(scrollTop) {
    if (this.virtualScroll) {
      this._renderItemsRange(scrollTop);
    }
    this._lastScrollPosition = scrollTop;
    this._fireScrollToEnd(scrollTop);
  }
  _updateVirtualHeight(height) {
    if (this._updateScrollHeight) {
      this._virtualPadding.style.height = `${height}px`;
      this._updateScrollHeight = false;
    }
  }
  _setVirtualHeight() {
    if (!this._virtualPadding) {
      return;
    }
    this._virtualPadding.style.height = `0px`;
  }
  _onItemsLengthChanged() {
    this._updateScrollHeight = true;
  }
  _renderItemsRange(scrollTop = null) {
    if (scrollTop && this._lastScrollPosition === scrollTop) {
      return;
    }
    scrollTop = scrollTop || this._scrollablePanel.scrollTop;
    const range = this._panelService.calculateItems(scrollTop, this.itemsLength, this.bufferAmount);
    this._updateVirtualHeight(range.scrollHeight);
    this._contentPanel.style.transform = `translateY(${range.topPadding}px)`;
    this._zone.run(() => {
      this.update.emit(this.items.slice(range.start, range.end));
      this.scroll.emit({
        start: range.start,
        end: range.end
      });
    });
    if (isDefined(scrollTop) && this._lastScrollPosition === 0) {
      this._scrollablePanel.scrollTop = scrollTop;
      this._lastScrollPosition = scrollTop;
    }
  }
  _measureDimensions() {
    if (this._panelService.dimensions.itemHeight > 0 || this.itemsLength === 0) {
      return Promise.resolve(this._panelService.dimensions);
    }
    const [first2] = this.items;
    this.update.emit([first2]);
    return Promise.resolve().then(() => {
      const option = this._dropdown.querySelector(`#${first2.htmlId}`);
      const optionHeight = option.clientHeight;
      this._virtualPadding.style.height = `${optionHeight * this.itemsLength}px`;
      const panelHeight = this._scrollablePanel.clientHeight;
      this._panelService.setDimensions(optionHeight, panelHeight);
      return this._panelService.dimensions;
    });
  }
  _fireScrollToEnd(scrollTop) {
    if (this._scrollToEndFired || scrollTop === 0) {
      return;
    }
    const padding = this.virtualScroll ? this._virtualPadding : this._contentPanel;
    if (scrollTop + this._dropdown.clientHeight >= padding.clientHeight - 1) {
      this._zone.run(() => this.scrollToEnd.emit());
      this._scrollToEndFired = true;
    }
  }
  _calculateCurrentPosition(dropdownEl) {
    if (this.position !== "auto") {
      return this.position;
    }
    const selectRect = this._select.getBoundingClientRect();
    const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
    const offsetTop = selectRect.top + window.pageYOffset;
    const height = selectRect.height;
    const dropdownHeight = dropdownEl.getBoundingClientRect().height;
    if (offsetTop + height + dropdownHeight > scrollTop + document.documentElement.clientHeight) {
      return "top";
    } else {
      return "bottom";
    }
  }
  _appendDropdown() {
    if (!this.appendTo) {
      return;
    }
    this._parent = document.querySelector(this.appendTo);
    if (!this._parent) {
      throw new Error(`appendTo selector ${this.appendTo} did not found any parent element`);
    }
    this._updateXPosition();
    this._parent.appendChild(this._dropdown);
  }
  _updateXPosition() {
    const select = this._select.getBoundingClientRect();
    const parent = this._parent.getBoundingClientRect();
    const offsetLeft = select.left - parent.left;
    this._dropdown.style.left = offsetLeft + "px";
    this._dropdown.style.width = select.width + "px";
    this._dropdown.style.minWidth = select.width + "px";
  }
  _updateYPosition() {
    const select = this._select.getBoundingClientRect();
    const parent = this._parent.getBoundingClientRect();
    const delta = select.height;
    if (this._currentPosition === "top") {
      const offsetBottom = parent.bottom - select.bottom;
      this._dropdown.style.bottom = offsetBottom + delta + "px";
      this._dropdown.style.top = "auto";
    } else if (this._currentPosition === "bottom") {
      const offsetTop = select.top - parent.top;
      this._dropdown.style.top = offsetTop + delta + "px";
      this._dropdown.style.bottom = "auto";
    }
  }
  _setupMousedownListener() {
    this._zone.runOutsideAngular(() => {
      fromEvent(this._dropdown, "mousedown").pipe(takeUntil(this._destroy$)).subscribe((event) => {
        const target = event.target;
        if (target.tagName === "INPUT") {
          return;
        }
        event.preventDefault();
      });
    });
  }
};
_NgDropdownPanelComponent.\u0275fac = function NgDropdownPanelComponent_Factory(t) {
  return new (t || _NgDropdownPanelComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NgDropdownPanelService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(DOCUMENT, 8));
};
_NgDropdownPanelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NgDropdownPanelComponent,
  selectors: [["ng-dropdown-panel"]],
  viewQuery: function NgDropdownPanelComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c0, 7, ElementRef);
      \u0275\u0275viewQuery(_c1, 7, ElementRef);
      \u0275\u0275viewQuery(_c2, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentElementRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollElementRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.paddingElementRef = _t.first);
    }
  },
  inputs: {
    items: "items",
    markedItem: "markedItem",
    position: "position",
    appendTo: "appendTo",
    bufferAmount: "bufferAmount",
    virtualScroll: "virtualScroll",
    headerTemplate: "headerTemplate",
    footerTemplate: "footerTemplate",
    filterValue: "filterValue"
  },
  outputs: {
    update: "update",
    scroll: "scroll",
    scrollToEnd: "scrollToEnd",
    outsideClick: "outsideClick"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c3,
  decls: 9,
  vars: 6,
  consts: [["scroll", ""], ["padding", ""], ["content", ""], ["class", "ng-dropdown-header", 4, "ngIf"], ["role", "listbox", 1, "ng-dropdown-panel-items", "scroll-host"], ["class", "ng-dropdown-footer", 4, "ngIf"], [1, "ng-dropdown-header"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "ng-dropdown-footer"]],
  template: function NgDropdownPanelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NgDropdownPanelComponent_div_0_Template, 2, 4, "div", 3);
      \u0275\u0275elementStart(1, "div", 4, 0);
      \u0275\u0275element(3, "div", null, 1);
      \u0275\u0275elementStart(5, "div", null, 2);
      \u0275\u0275projection(7);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(8, NgDropdownPanelComponent_div_8_Template, 2, 4, "div", 5);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.headerTemplate);
      \u0275\u0275advance(3);
      \u0275\u0275classProp("total-padding", ctx.virtualScroll);
      \u0275\u0275advance(2);
      \u0275\u0275classProp("scrollable-content", ctx.virtualScroll && ctx.items.length);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.footerTemplate);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NgDropdownPanelComponent = _NgDropdownPanelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgDropdownPanelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "ng-dropdown-panel",
      template: `
        <div *ngIf="headerTemplate" class="ng-dropdown-header">
            <ng-container [ngTemplateOutlet]="headerTemplate" [ngTemplateOutletContext]="{ searchTerm: filterValue }"></ng-container>
        </div>
        <div #scroll role="listbox" class="ng-dropdown-panel-items scroll-host">
            <div #padding [class.total-padding]="virtualScroll"></div>
            <div #content [class.scrollable-content]="virtualScroll && items.length">
                <ng-content></ng-content>
            </div>
        </div>
        <div *ngIf="footerTemplate" class="ng-dropdown-footer">
            <ng-container [ngTemplateOutlet]="footerTemplate" [ngTemplateOutletContext]="{ searchTerm: filterValue }"></ng-container>
        </div>
    `
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NgDropdownPanelService
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    items: [{
      type: Input
    }],
    markedItem: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    appendTo: [{
      type: Input
    }],
    bufferAmount: [{
      type: Input
    }],
    virtualScroll: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    footerTemplate: [{
      type: Input
    }],
    filterValue: [{
      type: Input
    }],
    update: [{
      type: Output
    }],
    scroll: [{
      type: Output
    }],
    scrollToEnd: [{
      type: Output
    }],
    outsideClick: [{
      type: Output
    }],
    contentElementRef: [{
      type: ViewChild,
      args: ["content", {
        read: ElementRef,
        static: true
      }]
    }],
    scrollElementRef: [{
      type: ViewChild,
      args: ["scroll", {
        read: ElementRef,
        static: true
      }]
    }],
    paddingElementRef: [{
      type: ViewChild,
      args: ["padding", {
        read: ElementRef,
        static: true
      }]
    }]
  });
})();
var _NgOptionComponent = class _NgOptionComponent {
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = this._isDisabled(value);
  }
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.stateChange$ = new Subject();
    this._disabled = false;
  }
  get label() {
    return (this.elementRef.nativeElement.textContent || "").trim();
  }
  ngOnChanges(changes) {
    if (changes.disabled) {
      this.stateChange$.next({
        value: this.value,
        disabled: this._disabled
      });
    }
  }
  ngAfterViewChecked() {
    if (this.label !== this._previousLabel) {
      this._previousLabel = this.label;
      this.stateChange$.next({
        value: this.value,
        disabled: this._disabled,
        label: this.elementRef.nativeElement.innerHTML
      });
    }
  }
  ngOnDestroy() {
    this.stateChange$.complete();
  }
  _isDisabled(value) {
    return value != null && `${value}` !== "false";
  }
};
_NgOptionComponent.\u0275fac = function NgOptionComponent_Factory(t) {
  return new (t || _NgOptionComponent)(\u0275\u0275directiveInject(ElementRef));
};
_NgOptionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NgOptionComponent,
  selectors: [["ng-option"]],
  inputs: {
    value: "value",
    disabled: "disabled"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function NgOptionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NgOptionComponent = _NgOptionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptionComponent, [{
    type: Component,
    args: [{
      selector: "ng-option",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-content></ng-content>`
    }]
  }], () => [{
    type: ElementRef
  }], {
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var _NgSelectConfig = class _NgSelectConfig {
  constructor() {
    this.notFoundText = "No items found";
    this.typeToSearchText = "Type to search";
    this.addTagText = "Add item";
    this.loadingText = "Loading...";
    this.clearAllText = "Clear all";
    this.disableVirtualScroll = true;
    this.openOnEnter = true;
    this.appearance = "underline";
  }
};
_NgSelectConfig.\u0275fac = function NgSelectConfig_Factory(t) {
  return new (t || _NgSelectConfig)();
};
_NgSelectConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NgSelectConfig,
  factory: _NgSelectConfig.\u0275fac,
  providedIn: "root"
});
var NgSelectConfig = _NgSelectConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ConsoleService = class _ConsoleService {
  warn(message) {
    console.warn(message);
  }
};
_ConsoleService.\u0275fac = function ConsoleService_Factory(t) {
  return new (t || _ConsoleService)();
};
_ConsoleService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ConsoleService,
  factory: _ConsoleService.\u0275fac,
  providedIn: "root"
});
var ConsoleService = _ConsoleService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConsoleService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var SELECTION_MODEL_FACTORY = new InjectionToken("ng-select-selection-model");
var _NgSelectComponent = class _NgSelectComponent {
  get items() {
    return this._items;
  }
  set items(value) {
    if (value === null) {
      value = [];
    }
    this._itemsAreUsed = true;
    this._items = value;
  }
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (fn !== void 0 && fn !== null && !isFunction(fn)) {
      throw Error("`compareWith` must be a function.");
    }
    this._compareWith = fn;
  }
  get clearSearchOnAdd() {
    if (isDefined(this._clearSearchOnAdd)) {
      return this._clearSearchOnAdd;
    } else if (isDefined(this.config.clearSearchOnAdd)) {
      return this.config.clearSearchOnAdd;
    }
    return this.closeOnSelect;
  }
  set clearSearchOnAdd(value) {
    this._clearSearchOnAdd = value;
  }
  get deselectOnClick() {
    if (isDefined(this._deselectOnClick)) {
      return this._deselectOnClick;
    } else if (isDefined(this.config.deselectOnClick)) {
      return this.config.deselectOnClick;
    }
    return this.multiple;
  }
  set deselectOnClick(value) {
    this._deselectOnClick = value;
  }
  get disabled() {
    return this.readonly || this._disabled;
  }
  get filtered() {
    return !!this.searchTerm && this.searchable || this._isComposing;
  }
  get single() {
    return !this.multiple;
  }
  get _editableSearchTerm() {
    return this.editableSearchTerm && !this.multiple;
  }
  constructor(classes, autoFocus, config, newSelectionModel, _elementRef, _cd, _console) {
    this.classes = classes;
    this.autoFocus = autoFocus;
    this.config = config;
    this._cd = _cd;
    this._console = _console;
    this.markFirst = true;
    this.dropdownPosition = "auto";
    this.loading = false;
    this.closeOnSelect = true;
    this.hideSelected = false;
    this.selectOnTab = false;
    this.bufferAmount = 4;
    this.selectableGroup = false;
    this.selectableGroupAsModel = true;
    this.searchFn = null;
    this.trackByFn = null;
    this.clearOnBackspace = true;
    this.labelForId = null;
    this.inputAttrs = {};
    this.readonly = false;
    this.searchWhileComposing = true;
    this.minTermLength = 0;
    this.editableSearchTerm = false;
    this.keyDownFn = (_) => true;
    this.multiple = false;
    this.addTag = false;
    this.searchable = true;
    this.clearable = true;
    this.isOpen = false;
    this.blurEvent = new EventEmitter();
    this.focusEvent = new EventEmitter();
    this.changeEvent = new EventEmitter();
    this.openEvent = new EventEmitter();
    this.closeEvent = new EventEmitter();
    this.searchEvent = new EventEmitter();
    this.clearEvent = new EventEmitter();
    this.addEvent = new EventEmitter();
    this.removeEvent = new EventEmitter();
    this.scroll = new EventEmitter();
    this.scrollToEnd = new EventEmitter();
    this.useDefaultClass = true;
    this.viewPortItems = [];
    this.searchTerm = null;
    this.dropdownId = newId();
    this.escapeHTML = true;
    this._items = [];
    this._defaultLabel = "label";
    this._pressedKeys = [];
    this._isComposing = false;
    this._destroy$ = new Subject();
    this._keyPress$ = new Subject();
    this._onChange = (_) => {
    };
    this._onTouched = () => {
    };
    this.clearItem = (item) => {
      const option = this.selectedItems.find((x) => x.value === item);
      this.unselect(option);
    };
    this.trackByOption = (_, item) => {
      if (this.trackByFn) {
        return this.trackByFn(item.value);
      }
      return item;
    };
    this._mergeGlobalConfig(config);
    this.itemsList = new ItemsList(this, newSelectionModel());
    this.element = _elementRef.nativeElement;
  }
  get selectedItems() {
    return this.itemsList.selectedItems;
  }
  get selectedValues() {
    return this.selectedItems.map((x) => x.value);
  }
  get hasValue() {
    return this.selectedItems.length > 0;
  }
  get currentPanelPosition() {
    if (this.dropdownPanel) {
      return this.dropdownPanel.currentPosition;
    }
    return void 0;
  }
  ngOnInit() {
    this._handleKeyPresses();
    this._setInputAttributes();
  }
  ngOnChanges(changes) {
    if (changes.multiple) {
      this.itemsList.clearSelected();
    }
    if (changes.items) {
      this._setItems(changes.items.currentValue || []);
    }
    if (changes.isOpen) {
      this._manualOpen = isDefined(changes.isOpen.currentValue);
    }
  }
  ngAfterViewInit() {
    if (!this._itemsAreUsed) {
      this.escapeHTML = false;
      this._setItemsFromNgOptions();
    }
    if (isDefined(this.autoFocus)) {
      this.focus();
    }
  }
  ngOnDestroy() {
    this._destroy$.next();
    this._destroy$.complete();
  }
  handleKeyDown($event) {
    const keyCode = KeyCode[$event.which];
    if (keyCode) {
      if (this.keyDownFn($event) === false) {
        return;
      }
      this.handleKeyCode($event);
    } else if ($event.key && $event.key.length === 1) {
      this._keyPress$.next($event.key.toLocaleLowerCase());
    }
  }
  handleKeyCode($event) {
    const target = $event.target;
    if (this.clearButton && this.clearButton.nativeElement === target) {
      this.handleKeyCodeClear($event);
    } else {
      this.handleKeyCodeInput($event);
    }
  }
  handleKeyCodeInput($event) {
    switch ($event.which) {
      case KeyCode.ArrowDown:
        this._handleArrowDown($event);
        break;
      case KeyCode.ArrowUp:
        this._handleArrowUp($event);
        break;
      case KeyCode.Space:
        this._handleSpace($event);
        break;
      case KeyCode.Enter:
        this._handleEnter($event);
        break;
      case KeyCode.Tab:
        this._handleTab($event);
        break;
      case KeyCode.Esc:
        this.close();
        $event.preventDefault();
        break;
      case KeyCode.Backspace:
        this._handleBackspace();
        break;
    }
  }
  handleKeyCodeClear($event) {
    switch ($event.which) {
      case KeyCode.Enter:
        this.handleClearClick();
        $event.preventDefault();
        break;
    }
  }
  handleMousedown($event) {
    const target = $event.target;
    if (target.tagName !== "INPUT") {
      $event.preventDefault();
    }
    if (target.classList.contains("ng-clear-wrapper")) {
      this.handleClearClick();
      return;
    }
    if (target.classList.contains("ng-arrow-wrapper")) {
      this.handleArrowClick();
      return;
    }
    if (target.classList.contains("ng-value-icon")) {
      return;
    }
    if (!this.focused) {
      this.focus();
    }
    if (this.searchable) {
      this.open();
    } else {
      this.toggle();
    }
  }
  handleArrowClick() {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  }
  handleClearClick() {
    if (this.hasValue) {
      this.itemsList.clearSelected(true);
      this._updateNgModel();
    }
    this._clearSearch();
    this.focus();
    this.clearEvent.emit();
    this._onSelectionChanged();
  }
  clearModel() {
    if (!this.clearable) {
      return;
    }
    this.itemsList.clearSelected();
    this._updateNgModel();
  }
  writeValue(value) {
    this.itemsList.clearSelected();
    this._handleWriteValue(value);
    this._cd.markForCheck();
  }
  registerOnChange(fn) {
    this._onChange = fn;
  }
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  setDisabledState(state) {
    this._disabled = state;
    this._cd.markForCheck();
  }
  toggle() {
    if (!this.isOpen) {
      this.open();
    } else {
      this.close();
    }
  }
  open() {
    if (this.disabled || this.isOpen || this._manualOpen) {
      return;
    }
    if (!this._isTypeahead && !this.addTag && this.itemsList.noItemsToSelect) {
      return;
    }
    this.isOpen = true;
    this.itemsList.markSelectedOrDefault(this.markFirst);
    this.openEvent.emit();
    if (!this.searchTerm) {
      this.focus();
    }
    this.detectChanges();
  }
  close() {
    if (!this.isOpen || this._manualOpen) {
      return;
    }
    this.isOpen = false;
    this._isComposing = false;
    if (!this._editableSearchTerm) {
      this._clearSearch();
    } else {
      this.itemsList.resetFilteredItems();
    }
    this.itemsList.unmarkItem();
    this._onTouched();
    this.closeEvent.emit();
    this._cd.markForCheck();
  }
  toggleItem(item) {
    if (!item || item.disabled || this.disabled) {
      return;
    }
    if (this.deselectOnClick && item.selected) {
      this.unselect(item);
    } else {
      this.select(item);
    }
    if (this._editableSearchTerm) {
      this._setSearchTermFromItems();
    }
    this._onSelectionChanged();
  }
  select(item) {
    if (!item.selected) {
      this.itemsList.select(item);
      if (this.clearSearchOnAdd && !this._editableSearchTerm) {
        this._clearSearch();
      }
      this._updateNgModel();
      if (this.multiple) {
        this.addEvent.emit(item.value);
      }
    }
    if (this.closeOnSelect || this.itemsList.noItemsToSelect) {
      this.close();
    }
  }
  focus() {
    this.searchInput.nativeElement.focus();
  }
  blur() {
    this.searchInput.nativeElement.blur();
  }
  unselect(item) {
    if (!item) {
      return;
    }
    this.itemsList.unselect(item);
    this.focus();
    this._updateNgModel();
    this.removeEvent.emit(item.value);
  }
  selectTag() {
    let tag;
    if (isFunction(this.addTag)) {
      tag = this.addTag(this.searchTerm);
    } else {
      tag = this._primitive ? this.searchTerm : {
        [this.bindLabel]: this.searchTerm
      };
    }
    const handleTag = (item) => this._isTypeahead || !this.isOpen ? this.itemsList.mapItem(item, null) : this.itemsList.addItem(item);
    if (isPromise2(tag)) {
      tag.then((item) => this.select(handleTag(item))).catch(() => {
      });
    } else if (tag) {
      this.select(handleTag(tag));
    }
  }
  showClear() {
    return this.clearable && (this.hasValue || this.searchTerm) && !this.disabled;
  }
  focusOnClear() {
    this.blur();
    if (this.clearButton) {
      this.clearButton.nativeElement.focus();
    }
  }
  get showAddTag() {
    if (!this._validTerm) {
      return false;
    }
    const term = this.searchTerm.toLowerCase().trim();
    return this.addTag && !this.itemsList.filteredItems.some((x) => x.label.toLowerCase() === term) && (!this.hideSelected && this.isOpen || !this.selectedItems.some((x) => x.label.toLowerCase() === term)) && !this.loading;
  }
  showNoItemsFound() {
    const empty = this.itemsList.filteredItems.length === 0;
    return (empty && !this._isTypeahead && !this.loading || empty && this._isTypeahead && this._validTerm && !this.loading) && !this.showAddTag;
  }
  showTypeToSearch() {
    const empty = this.itemsList.filteredItems.length === 0;
    return empty && this._isTypeahead && !this._validTerm && !this.loading;
  }
  onCompositionStart() {
    this._isComposing = true;
  }
  onCompositionEnd(term) {
    this._isComposing = false;
    if (this.searchWhileComposing) {
      return;
    }
    this.filter(term);
  }
  filter(term) {
    if (this._isComposing && !this.searchWhileComposing) {
      return;
    }
    this.searchTerm = term;
    if (this._isTypeahead && (this._validTerm || this.minTermLength === 0)) {
      this.typeahead.next(term);
    }
    if (!this._isTypeahead) {
      this.itemsList.filter(this.searchTerm);
      if (this.isOpen) {
        this.itemsList.markSelectedOrDefault(this.markFirst);
      }
    }
    this.searchEvent.emit({
      term,
      items: this.itemsList.filteredItems.map((x) => x.value)
    });
    this.open();
  }
  onInputFocus($event) {
    if (this.focused) {
      return;
    }
    if (this._editableSearchTerm) {
      this._setSearchTermFromItems();
    }
    this.element.classList.add("ng-select-focused");
    this.focusEvent.emit($event);
    this.focused = true;
  }
  onInputBlur($event) {
    this.element.classList.remove("ng-select-focused");
    this.blurEvent.emit($event);
    if (!this.isOpen && !this.disabled) {
      this._onTouched();
    }
    if (this._editableSearchTerm) {
      this._setSearchTermFromItems();
    }
    this.focused = false;
  }
  onItemHover(item) {
    if (item.disabled) {
      return;
    }
    this.itemsList.markItem(item);
  }
  detectChanges() {
    if (!this._cd.destroyed) {
      this._cd.detectChanges();
    }
  }
  _setSearchTermFromItems() {
    const selected = this.selectedItems && this.selectedItems[0];
    this.searchTerm = selected && selected.label || null;
  }
  _setItems(items) {
    const firstItem = items[0];
    this.bindLabel = this.bindLabel || this._defaultLabel;
    this._primitive = isDefined(firstItem) ? !isObject2(firstItem) : this._primitive || this.bindLabel === this._defaultLabel;
    this.itemsList.setItems(items);
    if (items.length > 0 && this.hasValue) {
      this.itemsList.mapSelectedItems();
    }
    if (this.isOpen && isDefined(this.searchTerm) && !this._isTypeahead) {
      this.itemsList.filter(this.searchTerm);
    }
    if (this._isTypeahead || this.isOpen) {
      this.itemsList.markSelectedOrDefault(this.markFirst);
    }
  }
  _setItemsFromNgOptions() {
    const mapNgOptions = (options) => {
      this.items = options.map((option) => ({
        $ngOptionValue: option.value,
        $ngOptionLabel: option.elementRef.nativeElement.innerHTML,
        disabled: option.disabled
      }));
      this.itemsList.setItems(this.items);
      if (this.hasValue) {
        this.itemsList.mapSelectedItems();
      }
      this.detectChanges();
    };
    const handleOptionChange = () => {
      const changedOrDestroyed = merge(this.ngOptions.changes, this._destroy$);
      merge(...this.ngOptions.map((option) => option.stateChange$)).pipe(takeUntil(changedOrDestroyed)).subscribe((option) => {
        const item = this.itemsList.findItem(option.value);
        item.disabled = option.disabled;
        item.label = option.label || item.label;
        this._cd.detectChanges();
      });
    };
    this.ngOptions.changes.pipe(startWith(this.ngOptions), takeUntil(this._destroy$)).subscribe((options) => {
      this.bindLabel = this._defaultLabel;
      mapNgOptions(options);
      handleOptionChange();
    });
  }
  _isValidWriteValue(value) {
    if (!isDefined(value) || this.multiple && value === "" || Array.isArray(value) && value.length === 0) {
      return false;
    }
    const validateBinding = (item) => {
      if (!isDefined(this.compareWith) && isObject2(item) && this.bindValue) {
        this._console.warn(`Setting object(${JSON.stringify(item)}) as your model with bindValue is not allowed unless [compareWith] is used.`);
        return false;
      }
      return true;
    };
    if (this.multiple) {
      if (!Array.isArray(value)) {
        this._console.warn("Multiple select ngModel should be array.");
        return false;
      }
      return value.every((item) => validateBinding(item));
    } else {
      return validateBinding(value);
    }
  }
  _handleWriteValue(ngModel) {
    if (!this._isValidWriteValue(ngModel)) {
      return;
    }
    const select = (val) => {
      let item = this.itemsList.findItem(val);
      if (item) {
        this.itemsList.select(item);
      } else {
        const isValObject = isObject2(val);
        const isPrimitive = !isValObject && !this.bindValue;
        if (isValObject || isPrimitive) {
          this.itemsList.select(this.itemsList.mapItem(val, null));
        } else if (this.bindValue) {
          item = {
            [this.bindLabel]: null,
            [this.bindValue]: val
          };
          this.itemsList.select(this.itemsList.mapItem(item, null));
        }
      }
    };
    if (this.multiple) {
      ngModel.forEach((item) => select(item));
    } else {
      select(ngModel);
    }
  }
  _handleKeyPresses() {
    if (this.searchable) {
      return;
    }
    this._keyPress$.pipe(takeUntil(this._destroy$), tap((letter) => this._pressedKeys.push(letter)), debounceTime(200), filter(() => this._pressedKeys.length > 0), map(() => this._pressedKeys.join(""))).subscribe((term) => {
      const item = this.itemsList.findByLabel(term);
      if (item) {
        if (this.isOpen) {
          this.itemsList.markItem(item);
          this._scrollToMarked();
          this._cd.markForCheck();
        } else {
          this.select(item);
        }
      }
      this._pressedKeys = [];
    });
  }
  _setInputAttributes() {
    const input = this.searchInput.nativeElement;
    const attributes = __spreadValues({
      type: "text",
      autocorrect: "off",
      autocapitalize: "off",
      autocomplete: this.labelForId ? "off" : this.dropdownId
    }, this.inputAttrs);
    for (const key of Object.keys(attributes)) {
      input.setAttribute(key, attributes[key]);
    }
  }
  _updateNgModel() {
    const model = [];
    for (const item of this.selectedItems) {
      if (this.bindValue) {
        let value = null;
        if (item.children) {
          const groupKey = this.groupValue ? this.bindValue : this.groupBy;
          value = item.value[groupKey || this.groupBy];
        } else {
          value = this.itemsList.resolveNested(item.value, this.bindValue);
        }
        model.push(value);
      } else {
        model.push(item.value);
      }
    }
    const selected = this.selectedItems.map((x) => x.value);
    if (this.multiple) {
      this._onChange(model);
      this.changeEvent.emit(selected);
    } else {
      this._onChange(isDefined(model[0]) ? model[0] : null);
      this.changeEvent.emit(selected[0]);
    }
    this._cd.markForCheck();
  }
  _clearSearch() {
    if (!this.searchTerm) {
      return;
    }
    this._changeSearch(null);
    this.itemsList.resetFilteredItems();
  }
  _changeSearch(searchTerm) {
    this.searchTerm = searchTerm;
    if (this._isTypeahead) {
      this.typeahead.next(searchTerm);
    }
  }
  _scrollToMarked() {
    if (!this.isOpen || !this.dropdownPanel) {
      return;
    }
    this.dropdownPanel.scrollTo(this.itemsList.markedItem);
  }
  _scrollToTag() {
    if (!this.isOpen || !this.dropdownPanel) {
      return;
    }
    this.dropdownPanel.scrollToTag();
  }
  _onSelectionChanged() {
    if (this.isOpen && this.deselectOnClick && this.appendTo) {
      this._cd.detectChanges();
      this.dropdownPanel.adjustPosition();
    }
  }
  _handleTab($event) {
    if (this.isOpen === false) {
      if (this.showClear()) {
        this.focusOnClear();
        $event.preventDefault();
      } else if (!this.addTag) {
        return;
      }
    }
    if (this.selectOnTab) {
      if (this.itemsList.markedItem) {
        this.toggleItem(this.itemsList.markedItem);
        $event.preventDefault();
      } else if (this.showAddTag) {
        this.selectTag();
        $event.preventDefault();
      } else {
        this.close();
      }
    } else {
      this.close();
    }
  }
  _handleEnter($event) {
    if (this.isOpen || this._manualOpen) {
      if (this.itemsList.markedItem) {
        this.toggleItem(this.itemsList.markedItem);
      } else if (this.showAddTag) {
        this.selectTag();
      }
    } else if (this.openOnEnter) {
      this.open();
    } else {
      return;
    }
    $event.preventDefault();
  }
  _handleSpace($event) {
    if (this.isOpen || this._manualOpen) {
      return;
    }
    this.open();
    $event.preventDefault();
  }
  _handleArrowDown($event) {
    if (this._nextItemIsTag(1)) {
      this.itemsList.unmarkItem();
      this._scrollToTag();
    } else {
      this.itemsList.markNextItem();
      this._scrollToMarked();
    }
    this.open();
    $event.preventDefault();
  }
  _handleArrowUp($event) {
    if (!this.isOpen) {
      return;
    }
    if (this._nextItemIsTag(-1)) {
      this.itemsList.unmarkItem();
      this._scrollToTag();
    } else {
      this.itemsList.markPreviousItem();
      this._scrollToMarked();
    }
    $event.preventDefault();
  }
  _nextItemIsTag(nextStep) {
    const nextIndex = this.itemsList.markedIndex + nextStep;
    return this.addTag && this.searchTerm && this.itemsList.markedItem && (nextIndex < 0 || nextIndex === this.itemsList.filteredItems.length);
  }
  _handleBackspace() {
    if (this.searchTerm || !this.clearable || !this.clearOnBackspace || !this.hasValue) {
      return;
    }
    if (this.multiple) {
      this.unselect(this.itemsList.lastSelectedItem);
    } else {
      this.clearModel();
    }
  }
  get _isTypeahead() {
    return this.typeahead && this.typeahead.observers.length > 0;
  }
  get _validTerm() {
    const term = this.searchTerm && this.searchTerm.trim();
    return term && term.length >= this.minTermLength;
  }
  _mergeGlobalConfig(config) {
    this.placeholder = this.placeholder || config.placeholder;
    this.notFoundText = this.notFoundText || config.notFoundText;
    this.typeToSearchText = this.typeToSearchText || config.typeToSearchText;
    this.addTagText = this.addTagText || config.addTagText;
    this.loadingText = this.loadingText || config.loadingText;
    this.clearAllText = this.clearAllText || config.clearAllText;
    this.virtualScroll = isDefined(this.virtualScroll) ? this.virtualScroll : isDefined(config.disableVirtualScroll) ? !config.disableVirtualScroll : false;
    this.openOnEnter = isDefined(this.openOnEnter) ? this.openOnEnter : config.openOnEnter;
    this.appendTo = this.appendTo || config.appendTo;
    this.bindValue = this.bindValue || config.bindValue;
    this.bindLabel = this.bindLabel || config.bindLabel;
    this.appearance = this.appearance || config.appearance;
  }
};
_NgSelectComponent.\u0275fac = function NgSelectComponent_Factory(t) {
  return new (t || _NgSelectComponent)(\u0275\u0275injectAttribute("class"), \u0275\u0275injectAttribute("autofocus"), \u0275\u0275directiveInject(NgSelectConfig), \u0275\u0275directiveInject(SELECTION_MODEL_FACTORY), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ConsoleService));
};
_NgSelectComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NgSelectComponent,
  selectors: [["ng-select"]],
  contentQueries: function NgSelectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NgOptionTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgOptgroupTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgLabelTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgMultiLabelTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgHeaderTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgFooterTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgNotFoundTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgTypeToSearchTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgLoadingTextTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgTagTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgLoadingSpinnerTemplateDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NgOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.optionTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.optgroupTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.labelTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.multiLabelTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.footerTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.notFoundTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.typeToSearchTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.loadingTextTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tagTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.loadingSpinnerTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ngOptions = _t);
    }
  },
  viewQuery: function NgSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NgDropdownPanelComponent, 5);
      \u0275\u0275viewQuery(_c5, 7);
      \u0275\u0275viewQuery(_c6, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.dropdownPanel = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.searchInput = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.clearButton = _t.first);
    }
  },
  hostVars: 20,
  hostBindings: function NgSelectComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown", function NgSelectComponent_keydown_HostBindingHandler($event) {
        return ctx.handleKeyDown($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("ng-select-typeahead", ctx.typeahead)("ng-select-multiple", ctx.multiple)("ng-select-taggable", ctx.addTag)("ng-select-searchable", ctx.searchable)("ng-select-clearable", ctx.clearable)("ng-select-opened", ctx.isOpen)("ng-select", ctx.useDefaultClass)("ng-select-disabled", ctx.disabled)("ng-select-filtered", ctx.filtered)("ng-select-single", ctx.single);
    }
  },
  inputs: {
    bindLabel: "bindLabel",
    bindValue: "bindValue",
    markFirst: "markFirst",
    placeholder: "placeholder",
    notFoundText: "notFoundText",
    typeToSearchText: "typeToSearchText",
    addTagText: "addTagText",
    loadingText: "loadingText",
    clearAllText: "clearAllText",
    appearance: "appearance",
    dropdownPosition: "dropdownPosition",
    appendTo: "appendTo",
    loading: "loading",
    closeOnSelect: "closeOnSelect",
    hideSelected: "hideSelected",
    selectOnTab: "selectOnTab",
    openOnEnter: "openOnEnter",
    maxSelectedItems: "maxSelectedItems",
    groupBy: "groupBy",
    groupValue: "groupValue",
    bufferAmount: "bufferAmount",
    virtualScroll: "virtualScroll",
    selectableGroup: "selectableGroup",
    selectableGroupAsModel: "selectableGroupAsModel",
    searchFn: "searchFn",
    trackByFn: "trackByFn",
    clearOnBackspace: "clearOnBackspace",
    labelForId: "labelForId",
    inputAttrs: "inputAttrs",
    tabIndex: "tabIndex",
    readonly: "readonly",
    searchWhileComposing: "searchWhileComposing",
    minTermLength: "minTermLength",
    editableSearchTerm: "editableSearchTerm",
    keyDownFn: "keyDownFn",
    typeahead: "typeahead",
    multiple: "multiple",
    addTag: "addTag",
    searchable: "searchable",
    clearable: "clearable",
    isOpen: "isOpen",
    items: "items",
    compareWith: "compareWith",
    clearSearchOnAdd: "clearSearchOnAdd",
    deselectOnClick: "deselectOnClick"
  },
  outputs: {
    blurEvent: "blur",
    focusEvent: "focus",
    changeEvent: "change",
    openEvent: "open",
    closeEvent: "close",
    searchEvent: "search",
    clearEvent: "clear",
    addEvent: "add",
    removeEvent: "remove",
    scroll: "scroll",
    scrollToEnd: "scrollToEnd"
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NgSelectComponent),
    multi: true
  }, NgDropdownPanelService]), \u0275\u0275NgOnChangesFeature],
  decls: 14,
  vars: 19,
  consts: [["searchInput", ""], ["defaultLabelTemplate", ""], ["defaultLoadingSpinnerTemplate", ""], ["clearButton", ""], ["defaultOptionTemplate", ""], ["defaultTagTemplate", ""], ["defaultNotFoundTemplate", ""], ["defaultTypeToSearchTemplate", ""], ["defaultLoadingTextTemplate", ""], [1, "ng-select-container", 3, "mousedown"], [1, "ng-value-container"], [1, "ng-placeholder"], [4, "ngIf"], ["role", "combobox", "aria-haspopup", "listbox", 1, "ng-input"], ["aria-autocomplete", "list", 3, "input", "compositionstart", "compositionend", "focus", "blur", "change", "readOnly", "disabled", "value"], ["class", "ng-clear-wrapper", "tabindex", "0", 3, "title", 4, "ngIf"], [1, "ng-arrow-wrapper"], [1, "ng-arrow"], ["class", "ng-dropdown-panel", "role", "listbox", "aria-label", "Options list", 3, "virtualScroll", "bufferAmount", "appendTo", "position", "headerTemplate", "footerTemplate", "filterValue", "items", "markedItem", "ng-select-multiple", "ngClass", "id", "update", "scroll", "scrollToEnd", "outsideClick", 4, "ngIf"], ["class", "ng-value", 3, "ng-value-disabled", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "ng-value"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["aria-hidden", "true", 1, "ng-value-icon", "left", 3, "click"], [1, "ng-value-label", 3, "ngItemLabel", "escape"], [3, "ngTemplateOutlet"], [1, "ng-spinner-loader"], ["tabindex", "0", 1, "ng-clear-wrapper", 3, "title"], ["aria-hidden", "true", 1, "ng-clear"], ["role", "listbox", "aria-label", "Options list", 1, "ng-dropdown-panel", 3, "update", "scroll", "scrollToEnd", "outsideClick", "virtualScroll", "bufferAmount", "appendTo", "position", "headerTemplate", "footerTemplate", "filterValue", "items", "markedItem", "ngClass", "id"], ["class", "ng-option", 3, "ng-option-disabled", "ng-option-selected", "ng-optgroup", "ng-option", "ng-option-child", "ng-option-marked", "click", "mouseover", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "ng-option", "role", "option", 3, "ng-option-marked", "mouseover", "click", 4, "ngIf"], [1, "ng-option", 3, "click", "mouseover"], [1, "ng-option-label", 3, "ngItemLabel", "escape"], ["role", "option", 1, "ng-option", 3, "mouseover", "click"], [1, "ng-tag-label"], [1, "ng-option", "ng-option-disabled"]],
  template: function NgSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 9);
      \u0275\u0275listener("mousedown", function NgSelectComponent_Template_div_mousedown_0_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.handleMousedown($event));
      });
      \u0275\u0275elementStart(1, "div", 10)(2, "div", 11);
      \u0275\u0275text(3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, NgSelectComponent_ng_container_4_Template, 2, 2, "ng-container", 12)(5, NgSelectComponent_5_Template, 1, 5, null, 12);
      \u0275\u0275elementStart(6, "div", 13)(7, "input", 14, 0);
      \u0275\u0275listener("input", function NgSelectComponent_Template_input_input_7_listener() {
        \u0275\u0275restoreView(_r1);
        const searchInput_r6 = \u0275\u0275reference(8);
        return \u0275\u0275resetView(ctx.filter(searchInput_r6.value));
      })("compositionstart", function NgSelectComponent_Template_input_compositionstart_7_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onCompositionStart());
      })("compositionend", function NgSelectComponent_Template_input_compositionend_7_listener() {
        \u0275\u0275restoreView(_r1);
        const searchInput_r6 = \u0275\u0275reference(8);
        return \u0275\u0275resetView(ctx.onCompositionEnd(searchInput_r6.value));
      })("focus", function NgSelectComponent_Template_input_focus_7_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onInputFocus($event));
      })("blur", function NgSelectComponent_Template_input_blur_7_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onInputBlur($event));
      })("change", function NgSelectComponent_Template_input_change_7_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView($event.stopPropagation());
      });
      \u0275\u0275elementEnd()()();
      \u0275\u0275template(9, NgSelectComponent_ng_container_9_Template, 4, 1, "ng-container", 12)(10, NgSelectComponent_span_10_Template, 4, 1, "span", 15);
      \u0275\u0275elementStart(11, "span", 16);
      \u0275\u0275element(12, "span", 17);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(13, NgSelectComponent_ng_dropdown_panel_13_Template, 7, 19, "ng-dropdown-panel", 18);
    }
    if (rf & 2) {
      \u0275\u0275classProp("ng-appearance-outline", ctx.appearance === "outline")("ng-has-value", ctx.hasValue);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.placeholder);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", (!ctx.multiLabelTemplate || !ctx.multiple) && ctx.selectedItems.length > 0);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.multiple && ctx.multiLabelTemplate && ctx.selectedValues.length > 0);
      \u0275\u0275advance();
      \u0275\u0275attribute("aria-expanded", ctx.isOpen)("aria-owns", ctx.isOpen ? ctx.dropdownId : null);
      \u0275\u0275advance();
      \u0275\u0275property("readOnly", !ctx.searchable || ctx.itemsList.maxItemsSelected)("disabled", ctx.disabled)("value", ctx.searchTerm ? ctx.searchTerm : "");
      \u0275\u0275attribute("id", ctx.labelForId)("tabindex", ctx.tabIndex)("aria-activedescendant", ctx.isOpen ? ctx.itemsList == null ? null : ctx.itemsList.markedItem == null ? null : ctx.itemsList.markedItem.htmlId : null)("aria-controls", ctx.isOpen ? ctx.dropdownId : null);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.loading);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showClear());
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.isOpen);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgDropdownPanelComponent, NgItemLabelDirective],
  styles: ['@charset "UTF-8";.ng-select{position:relative;display:block;box-sizing:border-box}.ng-select div,.ng-select input,.ng-select span{box-sizing:border-box}.ng-select [hidden]{display:none}.ng-select.ng-select-searchable .ng-select-container .ng-value-container .ng-input{opacity:1}.ng-select.ng-select-opened .ng-select-container{z-index:1001}.ng-select.ng-select-disabled .ng-select-container .ng-value-container .ng-placeholder,.ng-select.ng-select-disabled .ng-select-container .ng-value-container .ng-value{-webkit-user-select:none;user-select:none;cursor:default}.ng-select.ng-select-disabled .ng-arrow-wrapper{cursor:default}.ng-select.ng-select-filtered .ng-placeholder{display:none}.ng-select .ng-select-container{cursor:default;display:flex;outline:none;overflow:hidden;position:relative;width:100%}.ng-select .ng-select-container .ng-value-container{display:flex;flex:1}.ng-select .ng-select-container .ng-value-container .ng-input{opacity:0}.ng-select .ng-select-container .ng-value-container .ng-input>input{box-sizing:content-box;background:none transparent;border:0 none;box-shadow:none;outline:none;padding:0;cursor:default;width:100%}.ng-select .ng-select-container .ng-value-container .ng-input>input::-ms-clear{display:none}.ng-select .ng-select-container .ng-value-container .ng-input>input[readonly]{-webkit-user-select:none;user-select:none;width:0;padding:0}.ng-select.ng-select-single.ng-select-filtered .ng-select-container .ng-value-container .ng-value{visibility:hidden}.ng-select.ng-select-single .ng-select-container .ng-value-container,.ng-select.ng-select-single .ng-select-container .ng-value-container .ng-value{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ng-select.ng-select-single .ng-select-container .ng-value-container .ng-value .ng-value-icon{display:none}.ng-select.ng-select-single .ng-select-container .ng-value-container .ng-input{position:absolute;left:0;width:100%}.ng-select.ng-select-multiple.ng-select-disabled>.ng-select-container .ng-value-container .ng-value .ng-value-icon{display:none}.ng-select.ng-select-multiple .ng-select-container .ng-value-container{flex-wrap:wrap}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-placeholder{position:absolute}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value{white-space:nowrap}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value.ng-value-disabled .ng-value-icon{display:none}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon{cursor:pointer}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-input{flex:1;z-index:2}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-placeholder{z-index:1}.ng-select .ng-clear-wrapper{cursor:pointer;position:relative;width:17px;-webkit-user-select:none;user-select:none}.ng-select .ng-clear-wrapper .ng-clear{display:inline-block;font-size:18px;line-height:1;pointer-events:none}.ng-select .ng-spinner-loader{border-radius:50%;width:17px;height:17px;margin-right:5px;font-size:10px;position:relative;text-indent:-9999em;border-top:2px solid rgba(66,66,66,.2);border-right:2px solid rgba(66,66,66,.2);border-bottom:2px solid rgba(66,66,66,.2);border-left:2px solid #424242;transform:translateZ(0);animation:load8 .8s infinite linear}.ng-select .ng-spinner-loader:after{border-radius:50%;width:17px;height:17px}@keyframes load8{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.ng-select .ng-arrow-wrapper{cursor:pointer;position:relative;text-align:center;-webkit-user-select:none;user-select:none}.ng-select .ng-arrow-wrapper .ng-arrow{pointer-events:none;display:inline-block;height:0;width:0;position:relative}.ng-dropdown-panel{box-sizing:border-box;position:absolute;opacity:0;width:100%;z-index:1050;-webkit-overflow-scrolling:touch}.ng-dropdown-panel .ng-dropdown-panel-items{display:block;height:auto;box-sizing:border-box;max-height:240px;overflow-y:auto}.ng-dropdown-panel .ng-dropdown-panel-items .ng-optgroup{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option{box-sizing:border-box;cursor:pointer;display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option .ng-option-label:empty:before{content:"\\200b"}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option .highlighted{font-weight:700;text-decoration:underline}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.disabled{cursor:default}.ng-dropdown-panel .scroll-host{overflow:hidden;overflow-y:auto;position:relative;display:block;-webkit-overflow-scrolling:touch}.ng-dropdown-panel .scrollable-content{top:0;left:0;width:100%;height:100%;position:absolute}.ng-dropdown-panel .total-padding{width:1px;opacity:0}\n'],
  encapsulation: 2,
  changeDetection: 0
});
var NgSelectComponent = _NgSelectComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectComponent, [{
    type: Component,
    args: [{
      selector: "ng-select",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NgSelectComponent),
        multi: true
      }, NgDropdownPanelService],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div
    (mousedown)="handleMousedown($event)"
    [class.ng-appearance-outline]="appearance === 'outline'"
    [class.ng-has-value]="hasValue"
    class="ng-select-container">

    <div class="ng-value-container">
        <div class="ng-placeholder">{{placeholder}}</div>

        <ng-container *ngIf="(!multiLabelTemplate  || !multiple ) && selectedItems.length > 0">
            <div [class.ng-value-disabled]="item.disabled" class="ng-value" *ngFor="let item of selectedItems; trackBy: trackByOption">
                <ng-template #defaultLabelTemplate>
                    <span class="ng-value-icon left" (click)="unselect(item);" aria-hidden="true">\xD7</span>
                    <span class="ng-value-label" [ngItemLabel]="item.label" [escape]="escapeHTML"></span>
                </ng-template>

                <ng-template
                    [ngTemplateOutlet]="labelTemplate || defaultLabelTemplate"
                    [ngTemplateOutletContext]="{ item: item.value, clear: clearItem, label: item.label }">
                </ng-template>
            </div>
        </ng-container>

        <ng-template *ngIf="multiple && multiLabelTemplate && selectedValues.length > 0"
                [ngTemplateOutlet]="multiLabelTemplate"
                [ngTemplateOutletContext]="{ items: selectedValues, clear: clearItem }">
        </ng-template>

        <div class="ng-input"
            role="combobox" 
            [attr.aria-expanded]="isOpen" 
            [attr.aria-owns]="isOpen ? dropdownId : null" 
            aria-haspopup="listbox">

            <input #searchInput
                   [attr.id]="labelForId"
                   [attr.tabindex]="tabIndex"
                   [readOnly]="!searchable || itemsList.maxItemsSelected"
                   [disabled]="disabled"
                   [value]="searchTerm ? searchTerm : ''"
                   (input)="filter(searchInput.value)"
                   (compositionstart)="onCompositionStart()"
                   (compositionend)="onCompositionEnd(searchInput.value)"
                   (focus)="onInputFocus($event)"
                   (blur)="onInputBlur($event)"
                   (change)="$event.stopPropagation()"
                   [attr.aria-activedescendant]="isOpen ? itemsList?.markedItem?.htmlId : null"
                   aria-autocomplete="list"
                   [attr.aria-controls]="isOpen ? dropdownId : null">
        </div>
    </div>

    <ng-container *ngIf="loading">
        <ng-template #defaultLoadingSpinnerTemplate>
            <div class="ng-spinner-loader"></div>
        </ng-template>

        <ng-template
            [ngTemplateOutlet]="loadingSpinnerTemplate || defaultLoadingSpinnerTemplate">
        </ng-template>
    </ng-container>

    <span *ngIf="showClear()" class="ng-clear-wrapper" tabindex="0" title="{{clearAllText}}" #clearButton>
        <span class="ng-clear" aria-hidden="true">\xD7</span>
    </span>

    <span class="ng-arrow-wrapper">
        <span class="ng-arrow"></span>
    </span>
</div>

<ng-dropdown-panel *ngIf="isOpen"
                   class="ng-dropdown-panel"
                   [virtualScroll]="virtualScroll"
                   [bufferAmount]="bufferAmount"
                   [appendTo]="appendTo"
                   [position]="dropdownPosition"
                   [headerTemplate]="headerTemplate"
                   [footerTemplate]="footerTemplate"
                   [filterValue]="searchTerm"
                   [items]="itemsList.filteredItems"
                   [markedItem]="itemsList.markedItem"
                   (update)="viewPortItems = $event"
                   (scroll)="scroll.emit($event)"
                   (scrollToEnd)="scrollToEnd.emit($event)"
                   (outsideClick)="close()"
                   [class.ng-select-multiple]="multiple"
                   [ngClass]="appendTo ? classes : null"
                   [id]="dropdownId"
                   role="listbox"
                   aria-label="Options list">

    <ng-container>
        <div class="ng-option" [attr.role]="item.children ? 'group' : 'option'" (click)="toggleItem(item)" (mouseover)="onItemHover(item)"
                *ngFor="let item of viewPortItems; trackBy: trackByOption"
                [class.ng-option-disabled]="item.disabled"
                [class.ng-option-selected]="item.selected"
                [class.ng-optgroup]="item.children"
                [class.ng-option]="!item.children"
                [class.ng-option-child]="!!item.parent"
                [class.ng-option-marked]="item === itemsList.markedItem"
                [attr.aria-selected]="item.selected"
                [attr.id]="item?.htmlId">

            <ng-template #defaultOptionTemplate>
                <span class="ng-option-label" [ngItemLabel]="item.label" [escape]="escapeHTML"></span>
            </ng-template>

            <ng-template
                [ngTemplateOutlet]="item.children ? (optgroupTemplate || defaultOptionTemplate) : (optionTemplate || defaultOptionTemplate)"
                [ngTemplateOutletContext]="{ item: item.value, item$:item, index: item.index, searchTerm: searchTerm }">
            </ng-template>
        </div>

        <div class="ng-option" [class.ng-option-marked]="!itemsList.markedItem" (mouseover)="itemsList.unmarkItem()" role="option" (click)="selectTag()" *ngIf="showAddTag">
            <ng-template #defaultTagTemplate>
                <span><span class="ng-tag-label">{{addTagText}}</span>"{{searchTerm}}"</span>
            </ng-template>

            <ng-template
                [ngTemplateOutlet]="tagTemplate || defaultTagTemplate"
                [ngTemplateOutletContext]="{ searchTerm: searchTerm }">
            </ng-template>
        </div>
    </ng-container>

    <ng-container *ngIf="showNoItemsFound()">
        <ng-template #defaultNotFoundTemplate>
            <div class="ng-option ng-option-disabled">{{notFoundText}}</div>
        </ng-template>

        <ng-template
            [ngTemplateOutlet]="notFoundTemplate || defaultNotFoundTemplate"
            [ngTemplateOutletContext]="{ searchTerm: searchTerm }">
        </ng-template>
    </ng-container>

    <ng-container *ngIf="showTypeToSearch()">
        <ng-template #defaultTypeToSearchTemplate>
            <div class="ng-option ng-option-disabled">{{typeToSearchText}}</div>
        </ng-template>

        <ng-template
            [ngTemplateOutlet]="typeToSearchTemplate || defaultTypeToSearchTemplate">
        </ng-template>
    </ng-container>

    <ng-container *ngIf="loading && itemsList.filteredItems.length === 0">
        <ng-template #defaultLoadingTextTemplate>
            <div class="ng-option ng-option-disabled">{{loadingText}}</div>
        </ng-template>

        <ng-template
            [ngTemplateOutlet]="loadingTextTemplate || defaultLoadingTextTemplate"
            [ngTemplateOutletContext]="{ searchTerm: searchTerm }">
        </ng-template>
    </ng-container>

</ng-dropdown-panel>
`,
      styles: ['@charset "UTF-8";.ng-select{position:relative;display:block;box-sizing:border-box}.ng-select div,.ng-select input,.ng-select span{box-sizing:border-box}.ng-select [hidden]{display:none}.ng-select.ng-select-searchable .ng-select-container .ng-value-container .ng-input{opacity:1}.ng-select.ng-select-opened .ng-select-container{z-index:1001}.ng-select.ng-select-disabled .ng-select-container .ng-value-container .ng-placeholder,.ng-select.ng-select-disabled .ng-select-container .ng-value-container .ng-value{-webkit-user-select:none;user-select:none;cursor:default}.ng-select.ng-select-disabled .ng-arrow-wrapper{cursor:default}.ng-select.ng-select-filtered .ng-placeholder{display:none}.ng-select .ng-select-container{cursor:default;display:flex;outline:none;overflow:hidden;position:relative;width:100%}.ng-select .ng-select-container .ng-value-container{display:flex;flex:1}.ng-select .ng-select-container .ng-value-container .ng-input{opacity:0}.ng-select .ng-select-container .ng-value-container .ng-input>input{box-sizing:content-box;background:none transparent;border:0 none;box-shadow:none;outline:none;padding:0;cursor:default;width:100%}.ng-select .ng-select-container .ng-value-container .ng-input>input::-ms-clear{display:none}.ng-select .ng-select-container .ng-value-container .ng-input>input[readonly]{-webkit-user-select:none;user-select:none;width:0;padding:0}.ng-select.ng-select-single.ng-select-filtered .ng-select-container .ng-value-container .ng-value{visibility:hidden}.ng-select.ng-select-single .ng-select-container .ng-value-container,.ng-select.ng-select-single .ng-select-container .ng-value-container .ng-value{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ng-select.ng-select-single .ng-select-container .ng-value-container .ng-value .ng-value-icon{display:none}.ng-select.ng-select-single .ng-select-container .ng-value-container .ng-input{position:absolute;left:0;width:100%}.ng-select.ng-select-multiple.ng-select-disabled>.ng-select-container .ng-value-container .ng-value .ng-value-icon{display:none}.ng-select.ng-select-multiple .ng-select-container .ng-value-container{flex-wrap:wrap}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-placeholder{position:absolute}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value{white-space:nowrap}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value.ng-value-disabled .ng-value-icon{display:none}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon{cursor:pointer}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-input{flex:1;z-index:2}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-placeholder{z-index:1}.ng-select .ng-clear-wrapper{cursor:pointer;position:relative;width:17px;-webkit-user-select:none;user-select:none}.ng-select .ng-clear-wrapper .ng-clear{display:inline-block;font-size:18px;line-height:1;pointer-events:none}.ng-select .ng-spinner-loader{border-radius:50%;width:17px;height:17px;margin-right:5px;font-size:10px;position:relative;text-indent:-9999em;border-top:2px solid rgba(66,66,66,.2);border-right:2px solid rgba(66,66,66,.2);border-bottom:2px solid rgba(66,66,66,.2);border-left:2px solid #424242;transform:translateZ(0);animation:load8 .8s infinite linear}.ng-select .ng-spinner-loader:after{border-radius:50%;width:17px;height:17px}@keyframes load8{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.ng-select .ng-arrow-wrapper{cursor:pointer;position:relative;text-align:center;-webkit-user-select:none;user-select:none}.ng-select .ng-arrow-wrapper .ng-arrow{pointer-events:none;display:inline-block;height:0;width:0;position:relative}.ng-dropdown-panel{box-sizing:border-box;position:absolute;opacity:0;width:100%;z-index:1050;-webkit-overflow-scrolling:touch}.ng-dropdown-panel .ng-dropdown-panel-items{display:block;height:auto;box-sizing:border-box;max-height:240px;overflow-y:auto}.ng-dropdown-panel .ng-dropdown-panel-items .ng-optgroup{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option{box-sizing:border-box;cursor:pointer;display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option .ng-option-label:empty:before{content:"\\200b"}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option .highlighted{font-weight:700;text-decoration:underline}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.disabled{cursor:default}.ng-dropdown-panel .scroll-host{overflow:hidden;overflow-y:auto;position:relative;display:block;-webkit-overflow-scrolling:touch}.ng-dropdown-panel .scrollable-content{top:0;left:0;width:100%;height:100%;position:absolute}.ng-dropdown-panel .total-padding{width:1px;opacity:0}\n']
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["class"]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["autofocus"]
    }]
  }, {
    type: NgSelectConfig
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [SELECTION_MODEL_FACTORY]
    }]
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: ConsoleService
  }], {
    bindLabel: [{
      type: Input
    }],
    bindValue: [{
      type: Input
    }],
    markFirst: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    notFoundText: [{
      type: Input
    }],
    typeToSearchText: [{
      type: Input
    }],
    addTagText: [{
      type: Input
    }],
    loadingText: [{
      type: Input
    }],
    clearAllText: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    dropdownPosition: [{
      type: Input
    }],
    appendTo: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    closeOnSelect: [{
      type: Input
    }],
    hideSelected: [{
      type: Input
    }],
    selectOnTab: [{
      type: Input
    }],
    openOnEnter: [{
      type: Input
    }],
    maxSelectedItems: [{
      type: Input
    }],
    groupBy: [{
      type: Input
    }],
    groupValue: [{
      type: Input
    }],
    bufferAmount: [{
      type: Input
    }],
    virtualScroll: [{
      type: Input
    }],
    selectableGroup: [{
      type: Input
    }],
    selectableGroupAsModel: [{
      type: Input
    }],
    searchFn: [{
      type: Input
    }],
    trackByFn: [{
      type: Input
    }],
    clearOnBackspace: [{
      type: Input
    }],
    labelForId: [{
      type: Input
    }],
    inputAttrs: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    searchWhileComposing: [{
      type: Input
    }],
    minTermLength: [{
      type: Input
    }],
    editableSearchTerm: [{
      type: Input
    }],
    keyDownFn: [{
      type: Input
    }],
    typeahead: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.ng-select-typeahead"]
    }],
    multiple: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.ng-select-multiple"]
    }],
    addTag: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.ng-select-taggable"]
    }],
    searchable: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.ng-select-searchable"]
    }],
    clearable: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.ng-select-clearable"]
    }],
    isOpen: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.ng-select-opened"]
    }],
    items: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    clearSearchOnAdd: [{
      type: Input
    }],
    deselectOnClick: [{
      type: Input
    }],
    blurEvent: [{
      type: Output,
      args: ["blur"]
    }],
    focusEvent: [{
      type: Output,
      args: ["focus"]
    }],
    changeEvent: [{
      type: Output,
      args: ["change"]
    }],
    openEvent: [{
      type: Output,
      args: ["open"]
    }],
    closeEvent: [{
      type: Output,
      args: ["close"]
    }],
    searchEvent: [{
      type: Output,
      args: ["search"]
    }],
    clearEvent: [{
      type: Output,
      args: ["clear"]
    }],
    addEvent: [{
      type: Output,
      args: ["add"]
    }],
    removeEvent: [{
      type: Output,
      args: ["remove"]
    }],
    scroll: [{
      type: Output,
      args: ["scroll"]
    }],
    scrollToEnd: [{
      type: Output,
      args: ["scrollToEnd"]
    }],
    optionTemplate: [{
      type: ContentChild,
      args: [NgOptionTemplateDirective, {
        read: TemplateRef
      }]
    }],
    optgroupTemplate: [{
      type: ContentChild,
      args: [NgOptgroupTemplateDirective, {
        read: TemplateRef
      }]
    }],
    labelTemplate: [{
      type: ContentChild,
      args: [NgLabelTemplateDirective, {
        read: TemplateRef
      }]
    }],
    multiLabelTemplate: [{
      type: ContentChild,
      args: [NgMultiLabelTemplateDirective, {
        read: TemplateRef
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [NgHeaderTemplateDirective, {
        read: TemplateRef
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [NgFooterTemplateDirective, {
        read: TemplateRef
      }]
    }],
    notFoundTemplate: [{
      type: ContentChild,
      args: [NgNotFoundTemplateDirective, {
        read: TemplateRef
      }]
    }],
    typeToSearchTemplate: [{
      type: ContentChild,
      args: [NgTypeToSearchTemplateDirective, {
        read: TemplateRef
      }]
    }],
    loadingTextTemplate: [{
      type: ContentChild,
      args: [NgLoadingTextTemplateDirective, {
        read: TemplateRef
      }]
    }],
    tagTemplate: [{
      type: ContentChild,
      args: [NgTagTemplateDirective, {
        read: TemplateRef
      }]
    }],
    loadingSpinnerTemplate: [{
      type: ContentChild,
      args: [NgLoadingSpinnerTemplateDirective, {
        read: TemplateRef
      }]
    }],
    dropdownPanel: [{
      type: ViewChild,
      args: [forwardRef(() => NgDropdownPanelComponent)]
    }],
    searchInput: [{
      type: ViewChild,
      args: ["searchInput", {
        static: true
      }]
    }],
    clearButton: [{
      type: ViewChild,
      args: ["clearButton"]
    }],
    ngOptions: [{
      type: ContentChildren,
      args: [NgOptionComponent, {
        descendants: true
      }]
    }],
    useDefaultClass: [{
      type: HostBinding,
      args: ["class.ng-select"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.ng-select-disabled"]
    }],
    filtered: [{
      type: HostBinding,
      args: ["class.ng-select-filtered"]
    }],
    single: [{
      type: HostBinding,
      args: ["class.ng-select-single"]
    }],
    handleKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
function DefaultSelectionModelFactory() {
  return new DefaultSelectionModel();
}
var DefaultSelectionModel = class {
  constructor() {
    this._selected = [];
  }
  get value() {
    return this._selected;
  }
  select(item, multiple, groupAsModel) {
    item.selected = true;
    if (!item.children || !multiple && groupAsModel) {
      this._selected.push(item);
    }
    if (multiple) {
      if (item.parent) {
        const childrenCount = item.parent.children.length;
        const selectedCount = item.parent.children.filter((x) => x.selected).length;
        item.parent.selected = childrenCount === selectedCount;
      } else if (item.children) {
        this._setChildrenSelectedState(item.children, true);
        this._removeChildren(item);
        if (groupAsModel && this._activeChildren(item)) {
          this._selected = [...this._selected.filter((x) => x.parent !== item), item];
        } else {
          this._selected = [...this._selected, ...item.children.filter((x) => !x.disabled)];
        }
      }
    }
  }
  unselect(item, multiple) {
    this._selected = this._selected.filter((x) => x !== item);
    item.selected = false;
    if (multiple) {
      if (item.parent && item.parent.selected) {
        const children = item.parent.children;
        this._removeParent(item.parent);
        this._removeChildren(item.parent);
        this._selected.push(...children.filter((x) => x !== item && !x.disabled));
        item.parent.selected = false;
      } else if (item.children) {
        this._setChildrenSelectedState(item.children, false);
        this._removeChildren(item);
      }
    }
  }
  clear(keepDisabled) {
    this._selected = keepDisabled ? this._selected.filter((x) => x.disabled) : [];
  }
  _setChildrenSelectedState(children, selected) {
    for (const child of children) {
      if (child.disabled) {
        continue;
      }
      child.selected = selected;
    }
  }
  _removeChildren(parent) {
    this._selected = [...this._selected.filter((x) => x.parent !== parent), ...parent.children.filter((x) => x.parent === parent && x.disabled && x.selected)];
  }
  _removeParent(parent) {
    this._selected = this._selected.filter((x) => x !== parent);
  }
  _activeChildren(item) {
    return item.children.every((x) => !x.disabled || x.selected);
  }
};
var _NgSelectModule = class _NgSelectModule {
};
_NgSelectModule.\u0275fac = function NgSelectModule_Factory(t) {
  return new (t || _NgSelectModule)();
};
_NgSelectModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NgSelectModule
});
_NgSelectModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: SELECTION_MODEL_FACTORY,
    useValue: DefaultSelectionModelFactory
  }],
  imports: [CommonModule]
});
var NgSelectModule = _NgSelectModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectModule, [{
    type: NgModule,
    args: [{
      declarations: [NgDropdownPanelComponent, NgOptionComponent, NgSelectComponent, NgOptgroupTemplateDirective, NgOptionTemplateDirective, NgLabelTemplateDirective, NgMultiLabelTemplateDirective, NgHeaderTemplateDirective, NgFooterTemplateDirective, NgNotFoundTemplateDirective, NgTypeToSearchTemplateDirective, NgLoadingTextTemplateDirective, NgTagTemplateDirective, NgLoadingSpinnerTemplateDirective, NgItemLabelDirective],
      imports: [CommonModule],
      exports: [NgSelectComponent, NgOptionComponent, NgOptgroupTemplateDirective, NgOptionTemplateDirective, NgLabelTemplateDirective, NgMultiLabelTemplateDirective, NgHeaderTemplateDirective, NgFooterTemplateDirective, NgNotFoundTemplateDirective, NgTypeToSearchTemplateDirective, NgLoadingTextTemplateDirective, NgTagTemplateDirective, NgLoadingSpinnerTemplateDirective],
      providers: [{
        provide: SELECTION_MODEL_FACTORY,
        useValue: DefaultSelectionModelFactory
      }]
    }]
  }], null, null);
})();

// node_modules/ngx-infinite-scroll/fesm2022/ngx-infinite-scroll.mjs
var _NgxInfiniteScrollService = class _NgxInfiniteScrollService {
  constructor() {
  }
};
_NgxInfiniteScrollService.\u0275fac = function NgxInfiniteScrollService_Factory(t) {
  return new (t || _NgxInfiniteScrollService)();
};
_NgxInfiniteScrollService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NgxInfiniteScrollService,
  factory: _NgxInfiniteScrollService.\u0275fac,
  providedIn: "root"
});
var NgxInfiniteScrollService = _NgxInfiniteScrollService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxInfiniteScrollService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {
  const hasWindow = window && !!window.document && window.document.documentElement;
  let container = hasWindow && scrollWindow ? window : defaultElement;
  if (selector) {
    const containerIsString = selector && hasWindow && typeof selector === "string";
    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;
    if (!container) {
      throw new Error("ngx-infinite-scroll {resolveContainerElement()}: selector for");
    }
  }
  return container;
}
function findElement(selector, customRoot, fromRoot) {
  const rootEl = fromRoot ? window.document : customRoot;
  return rootEl.querySelector(selector);
}
function inputPropChanged(prop) {
  return prop && !prop.firstChange;
}
function hasWindowDefined() {
  return typeof window !== "undefined";
}
var VerticalProps = {
  clientHeight: "clientHeight",
  offsetHeight: "offsetHeight",
  scrollHeight: "scrollHeight",
  pageYOffset: "pageYOffset",
  offsetTop: "offsetTop",
  scrollTop: "scrollTop",
  top: "top"
};
var HorizontalProps = {
  clientHeight: "clientWidth",
  offsetHeight: "offsetWidth",
  scrollHeight: "scrollWidth",
  pageYOffset: "pageXOffset",
  offsetTop: "offsetLeft",
  scrollTop: "scrollLeft",
  top: "left"
};
var AxisResolver = class {
  constructor(vertical = true) {
    this.vertical = vertical;
    this.propsMap = vertical ? VerticalProps : HorizontalProps;
  }
  clientHeightKey() {
    return this.propsMap.clientHeight;
  }
  offsetHeightKey() {
    return this.propsMap.offsetHeight;
  }
  scrollHeightKey() {
    return this.propsMap.scrollHeight;
  }
  pageYOffsetKey() {
    return this.propsMap.pageYOffset;
  }
  offsetTopKey() {
    return this.propsMap.offsetTop;
  }
  scrollTopKey() {
    return this.propsMap.scrollTop;
  }
  topKey() {
    return this.propsMap.top;
  }
};
function shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent2, isTriggeredCurrentTotal) {
  if (alwaysCallback && shouldFireScrollEvent2) {
    return true;
  }
  if (!isTriggeredCurrentTotal && shouldFireScrollEvent2) {
    return true;
  }
  return false;
}
function createResolver({
  windowElement,
  axis
}) {
  return createResolverWithContainer({
    axis,
    isWindow: isElementWindow(windowElement)
  }, windowElement);
}
function createResolverWithContainer(resolver, windowElement) {
  const container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;
  return __spreadProps(__spreadValues({}, resolver), {
    container
  });
}
function isElementWindow(windowElement) {
  const isWindow = ["Window", "global"].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));
  return isWindow;
}
function getDocumentElement(isContainerWindow, windowElement) {
  return isContainerWindow ? windowElement.document.documentElement : null;
}
function calculatePoints(element, resolver) {
  const height = extractHeightForElement(resolver);
  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);
}
function calculatePointsForWindow(height, element, resolver) {
  const {
    axis,
    container,
    isWindow
  } = resolver;
  const {
    offsetHeightKey,
    clientHeightKey
  } = extractHeightPropKeys(axis);
  const scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);
  const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);
  const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;
  return {
    height,
    scrolled,
    totalToScroll,
    isWindow
  };
}
function calculatePointsForElement(height, element, resolver) {
  const {
    axis,
    container
  } = resolver;
  const scrolled = container[axis.scrollTopKey()];
  const totalToScroll = container[axis.scrollHeightKey()];
  return {
    height,
    scrolled,
    totalToScroll,
    isWindow: false
  };
}
function extractHeightPropKeys(axis) {
  return {
    offsetHeightKey: axis.offsetHeightKey(),
    clientHeightKey: axis.clientHeightKey()
  };
}
function extractHeightForElement({
  container,
  isWindow,
  axis
}) {
  const {
    offsetHeightKey,
    clientHeightKey
  } = extractHeightPropKeys(axis);
  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);
}
function getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {
  if (isNaN(elem[offsetHeightKey])) {
    const docElem = getDocumentElement(isWindow, elem);
    return docElem ? docElem[clientHeightKey] : 0;
  } else {
    return elem[offsetHeightKey];
  }
}
function getElementOffsetTop(elem, axis, isWindow) {
  const topKey = axis.topKey();
  if (!elem.getBoundingClientRect) {
    return;
  }
  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);
}
function getElementPageYOffset(elem, axis, isWindow) {
  const pageYOffset = axis.pageYOffsetKey();
  const scrollTop = axis.scrollTopKey();
  const offsetTop = axis.offsetTopKey();
  if (isNaN(window.pageYOffset)) {
    return getDocumentElement(isWindow, elem)[scrollTop];
  } else if (elem.ownerDocument) {
    return elem.ownerDocument.defaultView[pageYOffset];
  } else {
    return elem[offsetTop];
  }
}
function shouldFireScrollEvent(container, distance = {
  down: 0,
  up: 0
}, scrollingDown) {
  let remaining;
  let containerBreakpoint;
  if (container.totalToScroll <= 0) {
    return false;
  }
  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;
  if (scrollingDown) {
    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;
    const distanceDown = distance?.down ? distance.down : 0;
    containerBreakpoint = distanceDown / 10;
  } else {
    const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);
    remaining = container.scrolled / totalHiddenContentHeight;
    const distanceUp = distance?.up ? distance.up : 0;
    containerBreakpoint = distanceUp / 10;
  }
  const shouldFireEvent = remaining <= containerBreakpoint;
  return shouldFireEvent;
}
function isScrollingDownwards(lastScrollPosition, container) {
  return lastScrollPosition < container.scrolled;
}
function getScrollStats(lastScrollPosition, container, distance) {
  const scrollDown = isScrollingDownwards(lastScrollPosition, container);
  return {
    fire: shouldFireScrollEvent(container, distance, scrollDown),
    scrollDown
  };
}
var ScrollState = class {
  constructor(attrs) {
    this.lastScrollPosition = 0;
    this.lastTotalToScroll = 0;
    this.totalToScroll = 0;
    this.triggered = {
      down: 0,
      up: 0
    };
    Object.assign(this, attrs);
  }
  updateScrollPosition(position) {
    return this.lastScrollPosition = position;
  }
  updateTotalToScroll(totalToScroll) {
    if (this.lastTotalToScroll !== totalToScroll) {
      this.lastTotalToScroll = this.totalToScroll;
      this.totalToScroll = totalToScroll;
    }
  }
  updateScroll(scrolledUntilNow, totalToScroll) {
    this.updateScrollPosition(scrolledUntilNow);
    this.updateTotalToScroll(totalToScroll);
  }
  updateTriggeredFlag(scroll, isScrollingDown) {
    if (isScrollingDown) {
      this.triggered.down = scroll;
    } else {
      this.triggered.up = scroll;
    }
  }
  isTriggeredScroll(totalToScroll, isScrollingDown) {
    return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;
  }
};
function createScroller(config) {
  const {
    scrollContainer,
    scrollWindow,
    element,
    fromRoot
  } = config;
  const resolver = createResolver({
    axis: new AxisResolver(!config.horizontal),
    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)
  });
  const scrollState = new ScrollState({
    totalToScroll: calculatePoints(element, resolver).totalToScroll
  });
  const options = {
    container: resolver.container,
    throttle: config.throttle
  };
  const distance = {
    up: config.upDistance,
    down: config.downDistance
  };
  return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({
    stats
  }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({
    fire,
    scrollDown,
    stats: {
      totalToScroll
    }
  }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({
    scrollDown,
    stats: {
      totalToScroll
    }
  }) => {
    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);
  }), map(toInfiniteScrollAction));
}
function attachScrollEvent(options) {
  let obs = fromEvent(options.container, "scroll");
  if (options.throttle) {
    obs = obs.pipe(throttleTime(options.throttle, void 0, {
      leading: true,
      trailing: true
    }));
  }
  return obs;
}
function toInfiniteScrollParams(lastScrollPosition, stats, distance) {
  const {
    scrollDown,
    fire
  } = getScrollStats(lastScrollPosition, stats, distance);
  return {
    scrollDown,
    fire,
    stats
  };
}
var InfiniteScrollActions = {
  DOWN: "[NGX_ISE] DOWN",
  UP: "[NGX_ISE] UP"
};
function toInfiniteScrollAction(response) {
  const {
    scrollDown,
    stats: {
      scrolled: currentScrollPosition
    }
  } = response;
  return {
    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,
    payload: {
      currentScrollPosition
    }
  };
}
var _InfiniteScrollDirective = class _InfiniteScrollDirective {
  constructor(element, zone) {
    this.element = element;
    this.zone = zone;
    this.scrolled = new EventEmitter();
    this.scrolledUp = new EventEmitter();
    this.infiniteScrollDistance = 2;
    this.infiniteScrollUpDistance = 1.5;
    this.infiniteScrollThrottle = 150;
    this.infiniteScrollDisabled = false;
    this.infiniteScrollContainer = null;
    this.scrollWindow = true;
    this.immediateCheck = false;
    this.horizontal = false;
    this.alwaysCallback = false;
    this.fromRoot = false;
  }
  ngAfterViewInit() {
    if (!this.infiniteScrollDisabled) {
      this.setup();
    }
  }
  ngOnChanges({
    infiniteScrollContainer,
    infiniteScrollDisabled,
    infiniteScrollDistance
  }) {
    const containerChanged = inputPropChanged(infiniteScrollContainer);
    const disabledChanged = inputPropChanged(infiniteScrollDisabled);
    const distanceChanged = inputPropChanged(infiniteScrollDistance);
    const shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;
    if (containerChanged || disabledChanged || distanceChanged) {
      this.destroyScroller();
      if (shouldSetup) {
        this.setup();
      }
    }
  }
  setup() {
    if (hasWindowDefined()) {
      this.zone.runOutsideAngular(() => {
        this.disposeScroller = createScroller({
          fromRoot: this.fromRoot,
          alwaysCallback: this.alwaysCallback,
          disable: this.infiniteScrollDisabled,
          downDistance: this.infiniteScrollDistance,
          element: this.element,
          horizontal: this.horizontal,
          scrollContainer: this.infiniteScrollContainer,
          scrollWindow: this.scrollWindow,
          throttle: this.infiniteScrollThrottle,
          upDistance: this.infiniteScrollUpDistance
        }).subscribe((payload) => this.handleOnScroll(payload));
      });
    }
  }
  handleOnScroll({
    type,
    payload
  }) {
    const emitter = type === InfiniteScrollActions.DOWN ? this.scrolled : this.scrolledUp;
    if (hasObservers(emitter)) {
      this.zone.run(() => emitter.emit(payload));
    }
  }
  ngOnDestroy() {
    this.destroyScroller();
  }
  destroyScroller() {
    if (this.disposeScroller) {
      this.disposeScroller.unsubscribe();
    }
  }
};
_InfiniteScrollDirective.\u0275fac = function InfiniteScrollDirective_Factory(t) {
  return new (t || _InfiniteScrollDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone));
};
_InfiniteScrollDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _InfiniteScrollDirective,
  selectors: [["", "infiniteScroll", ""], ["", "infinite-scroll", ""], ["", "data-infinite-scroll", ""]],
  inputs: {
    infiniteScrollDistance: "infiniteScrollDistance",
    infiniteScrollUpDistance: "infiniteScrollUpDistance",
    infiniteScrollThrottle: "infiniteScrollThrottle",
    infiniteScrollDisabled: "infiniteScrollDisabled",
    infiniteScrollContainer: "infiniteScrollContainer",
    scrollWindow: "scrollWindow",
    immediateCheck: "immediateCheck",
    horizontal: "horizontal",
    alwaysCallback: "alwaysCallback",
    fromRoot: "fromRoot"
  },
  outputs: {
    scrolled: "scrolled",
    scrolledUp: "scrolledUp"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var InfiniteScrollDirective = _InfiniteScrollDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InfiniteScrollDirective, [{
    type: Directive,
    args: [{
      selector: "[infiniteScroll], [infinite-scroll], [data-infinite-scroll]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }], {
    scrolled: [{
      type: Output
    }],
    scrolledUp: [{
      type: Output
    }],
    infiniteScrollDistance: [{
      type: Input
    }],
    infiniteScrollUpDistance: [{
      type: Input
    }],
    infiniteScrollThrottle: [{
      type: Input
    }],
    infiniteScrollDisabled: [{
      type: Input
    }],
    infiniteScrollContainer: [{
      type: Input
    }],
    scrollWindow: [{
      type: Input
    }],
    immediateCheck: [{
      type: Input
    }],
    horizontal: [{
      type: Input
    }],
    alwaysCallback: [{
      type: Input
    }],
    fromRoot: [{
      type: Input
    }]
  });
})();
function hasObservers(emitter) {
  return emitter.observed ?? emitter.observers.length > 0;
}
var _InfiniteScrollModule = class _InfiniteScrollModule {
};
_InfiniteScrollModule.\u0275fac = function InfiniteScrollModule_Factory(t) {
  return new (t || _InfiniteScrollModule)();
};
_InfiniteScrollModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _InfiniteScrollModule
});
_InfiniteScrollModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var InfiniteScrollModule = _InfiniteScrollModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InfiniteScrollModule, [{
    type: NgModule,
    args: [{
      declarations: [InfiniteScrollDirective],
      exports: [InfiniteScrollDirective],
      imports: [],
      providers: []
    }]
  }], null, null);
})();

// node_modules/@spartacus/storefront/fesm2022/spartacus-storefront.mjs
var _c02 = (a0) => ({
  "anonymous-consent-banner-hidden": a0
});
function AnonymousConsentManagementBannerComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5);
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 6);
    \u0275\u0275text(9);
    \u0275\u0275pipe(10, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 7)(12, "button", 8);
    \u0275\u0275listener("click", function AnonymousConsentManagementBannerComponent_ng_container_0_Template_button_click_12_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.viewDetails());
    });
    \u0275\u0275text(13);
    \u0275\u0275pipe(14, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "button", 9);
    \u0275\u0275listener("click", function AnonymousConsentManagementBannerComponent_ng_container_0_Template_button_click_15_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.allowAll());
    });
    \u0275\u0275text(16);
    \u0275\u0275pipe(17, "cxTranslate");
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const bannerVisible_r3 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(13, _c02, !bannerVisible_r3));
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 5, "anonymousConsents.banner.title"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(10, 7, "anonymousConsents.banner.description"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(14, 9, "anonymousConsents.banner.viewDetails"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(17, 11, "anonymousConsents.banner.allowAll"), " ");
  }
}
var _c12 = ["*"];
function ConsentManagementFormComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275element(2, "br");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.consentTemplate == null ? null : ctx_r0.consentTemplate.name, " ");
  }
}
function AnonymousConsentDialogComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
function AnonymousConsentDialogComponent_ng_template_4_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275element(3, "div", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "anonymousConsents.dialog.legalDescription"), " ");
  }
}
function AnonymousConsentDialogComponent_ng_template_4_div_18_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 18)(1, "cx-consent-management-form", 19);
    \u0275\u0275listener("consentChanged", function AnonymousConsentDialogComponent_ng_template_4_div_18_ng_container_1_div_1_Template_cx_consent_management_form_consentChanged_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r2.onConsentChange($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const template_r5 = ctx.$implicit;
    const consents_r6 = \u0275\u0275nextContext().ngIf;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("consentTemplate", template_r5)("requiredConsents", ctx_r2.requiredConsents)("consent", ctx_r2.getCorrespondingConsent(template_r5, consents_r6));
  }
}
function AnonymousConsentDialogComponent_ng_template_4_div_18_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, AnonymousConsentDialogComponent_ng_template_4_div_18_ng_container_1_div_1_Template, 2, 3, "div", 17);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const templates_r7 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", templates_r7);
  }
}
function AnonymousConsentDialogComponent_ng_template_4_div_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275template(1, AnonymousConsentDialogComponent_ng_template_4_div_18_ng_container_1_Template, 2, 1, "ng-container", 16);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(2, 1, ctx_r2.consents$));
  }
}
function AnonymousConsentDialogComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275element(0, "div", 4);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275elementStart(2, "div", 5)(3, "h3");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 6);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275listener("click", function AnonymousConsentDialogComponent_ng_template_4_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.close("Cross click"));
    });
    \u0275\u0275elementStart(8, "span", 7);
    \u0275\u0275element(9, "cx-icon", 8);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(10, AnonymousConsentDialogComponent_ng_template_4_div_10_Template, 4, 3, "div", 9);
    \u0275\u0275elementStart(11, "div", 10)(12, "a", 11);
    \u0275\u0275listener("click", function AnonymousConsentDialogComponent_ng_template_4_Template_a_click_12_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.rejectAll());
    });
    \u0275\u0275text(13);
    \u0275\u0275pipe(14, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "a", 11);
    \u0275\u0275listener("click", function AnonymousConsentDialogComponent_ng_template_4_Template_a_click_15_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.allowAll());
    });
    \u0275\u0275text(16);
    \u0275\u0275pipe(17, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(18, AnonymousConsentDialogComponent_ng_template_4_div_18_Template, 3, 3, "div", 12);
    \u0275\u0275pipe(19, "async");
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 8, "common.loaded"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 10, "anonymousConsents.dialog.title"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(7, 12, "common.close"));
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r2.iconTypes.CLOSE);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showLegalDescription);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(14, 14, "anonymousConsents.dialog.clearAll"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(17, 16, "anonymousConsents.dialog.selectAll"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(19, 18, ctx_r2.templates$));
  }
}
var _c22 = ["open"];
var _c32 = (a0) => ({
  components$: a0
});
var _c42 = (a0) => ({
  component: a0
});
function PageSlotComponent_0_ng_template_0_ng_container_0_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 4);
  }
  if (rf & 2) {
    const component_r2 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("cxComponentWrapper", component_r2);
  }
}
function PageSlotComponent_0_ng_template_0_ng_container_0_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275template(0, PageSlotComponent_0_ng_template_0_ng_container_0_1_ng_template_0_Template, 1, 1, "ng-template", 3);
    \u0275\u0275listener("loaded", function PageSlotComponent_0_ng_template_0_ng_container_0_1_Template_ng_template_loaded_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r2.isLoaded($event));
    });
  }
  if (rf & 2) {
    const component_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275property("cxOutlet", component_r2.flexType)("cxOutletContext", \u0275\u0275pureFunction1(3, _c42, component_r2))("cxOutletDefer", ctx_r2.getComponentDeferOptions(component_r2.flexType));
  }
}
function PageSlotComponent_0_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, PageSlotComponent_0_ng_template_0_ng_container_0_1_Template, 1, 5, null, 0);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const component_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", component_r2.flexType);
  }
}
function PageSlotComponent_0_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PageSlotComponent_0_ng_template_0_ng_container_0_Template, 2, 1, "ng-container", 2);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngForOf", ctx_r2.components);
  }
}
function PageSlotComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PageSlotComponent_0_ng_template_0_Template, 1, 1, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("cxOutlet", ctx_r2.position)("cxOutletContext", \u0275\u0275pureFunction1(2, _c32, ctx_r2.components$));
  }
}
var _c52 = (a0, a1, a2) => ({
  templateName$: a0,
  slots$: a1,
  section$: a2
});
function PageLayoutComponent_0_ng_template_0_cx_page_slot_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-page-slot", 3);
    \u0275\u0275pipe(1, "async");
  }
  if (rf & 2) {
    const slot_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("position", slot_r1)("isPageFold", slot_r1 === \u0275\u0275pipeBind1(1, 2, ctx_r1.pageFoldSlot$));
  }
}
function PageLayoutComponent_0_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
    \u0275\u0275template(1, PageLayoutComponent_0_ng_template_0_cx_page_slot_1_Template, 2, 4, "cx-page-slot", 2);
    \u0275\u0275pipe(2, "async");
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", \u0275\u0275pipeBind1(2, 1, ctx_r1.slots$));
  }
}
function PageLayoutComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PageLayoutComponent_0_ng_template_0_Template, 3, 3, "ng-template", 1);
  }
  if (rf & 2) {
    const layoutName_r3 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("cxPageTemplateStyle", layoutName_r3)("cxOutlet", layoutName_r3)("cxOutletContext", \u0275\u0275pureFunction3(3, _c52, ctx_r1.templateName$, ctx_r1.slots$, ctx_r1.section$));
  }
}
function AddToHomeScreenBannerComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "div", 1)(2, "div", 2)(3, "p");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "ul")(7, "li");
    \u0275\u0275text(8);
    \u0275\u0275pipe(9, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "li");
    \u0275\u0275text(11);
    \u0275\u0275pipe(12, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "button", 3);
    \u0275\u0275listener("click", function AddToHomeScreenBannerComponent_div_0_Template_button_click_13_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.prompt());
    });
    \u0275\u0275text(14);
    \u0275\u0275pipe(15, "cxTranslate");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 4, "pwa.addToHomeScreenDescription"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(9, 6, "pwa.noInstallationNeeded"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(12, 8, "pwa.fastAccessToApplication"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(15, 10, "pwa.addToHomeScreen"), " ");
  }
}
function AddToHomeScreenBtnComponent_ng_content_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 0, ["*ngIf", "canPrompt$ | async"]);
  }
}
var _c62 = (a0) => ({
  item: a0
});
var _c72 = (a0) => ({
  currentSlideNumber: a0
});
function CarouselComponent_ng_container_0_h2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "h2");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function CarouselComponent_ng_container_0_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275listener("click", function CarouselComponent_ng_container_0_button_3_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const size_r3 = \u0275\u0275nextContext().ngIf;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activeSlide = ctx_r0.activeSlide - size_r3);
    });
    \u0275\u0275element(2, "cx-icon", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("disabled", ctx_r0.activeSlide === 0);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 3, "carousel.previousSlide"));
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r0.previousIcon);
  }
}
function CarouselComponent_ng_container_0_ng_container_5_div_1_ng_container_1_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function CarouselComponent_ng_container_0_ng_container_5_div_1_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12);
    \u0275\u0275template(1, CarouselComponent_ng_container_0_ng_container_5_div_1_ng_container_1_div_1_ng_container_1_Template, 1, 0, "ng-container", 13);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const data_r4 = ctx.ngIf;
    const i_r5 = \u0275\u0275nextContext(3).index;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("active", i_r5 === ctx_r0.activeSlide);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c62, data_r4));
  }
}
function CarouselComponent_ng_container_0_ng_container_5_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, CarouselComponent_ng_container_0_ng_container_5_div_1_ng_container_1_div_1_Template, 2, 6, "div", 11);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(2, 1, item_r6));
  }
}
function CarouselComponent_ng_container_0_ng_container_5_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275template(1, CarouselComponent_ng_container_0_ng_container_5_div_1_ng_container_1_Template, 3, 3, "ng-container", 4);
    \u0275\u0275pipe(2, "slice");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r5 = \u0275\u0275nextContext().index;
    const size_r3 = \u0275\u0275nextContext().ngIf;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", i_r5 === ctx_r0.activeSlide);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", \u0275\u0275pipeBind3(2, 3, ctx_r0.items, i_r5, i_r5 + size_r3));
  }
}
function CarouselComponent_ng_container_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, CarouselComponent_ng_container_0_ng_container_5_div_1_Template, 3, 7, "div", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const i_r5 = ctx.index;
    const size_r3 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", i_r5 % size_r3 === 0);
  }
}
function CarouselComponent_ng_container_0_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 14);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275listener("click", function CarouselComponent_ng_container_0_button_6_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const size_r3 = \u0275\u0275nextContext().ngIf;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activeSlide = ctx_r0.activeSlide + size_r3);
    });
    \u0275\u0275element(2, "cx-icon", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const size_r3 = \u0275\u0275nextContext().ngIf;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("disabled", ctx_r0.activeSlide > ctx_r0.items.length - size_r3 - 1);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 3, "carousel.nextSlide"));
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r0.nextIcon);
  }
}
function CarouselComponent_ng_container_0_div_7_ng_container_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 17);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275listener("click", function CarouselComponent_ng_container_0_div_7_ng_container_1_button_1_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const i_r9 = \u0275\u0275nextContext().index;
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.activeSlide = i_r9);
    });
    \u0275\u0275element(2, "cx-icon", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r9 = \u0275\u0275nextContext().index;
    const size_r3 = \u0275\u0275nextContext(2).ngIf;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("disabled", i_r9 === ctx_r0.activeSlide);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind2(1, 3, "carousel.slideNumber", \u0275\u0275pureFunction1(6, _c72, ctx_r0.getSlideNumber(size_r3, i_r9))));
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r0.indicatorIcon);
  }
}
function CarouselComponent_ng_container_0_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, CarouselComponent_ng_container_0_div_7_ng_container_1_button_1_Template, 3, 8, "button", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const i_r9 = ctx.index;
    const size_r3 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", i_r9 % size_r3 === 0);
  }
}
function CarouselComponent_ng_container_0_div_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275template(1, CarouselComponent_ng_container_0_div_7_ng_container_1_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.items);
  }
}
function CarouselComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, CarouselComponent_ng_container_0_h2_1_Template, 2, 1, "h2", 0);
    \u0275\u0275elementStart(2, "div", 1);
    \u0275\u0275template(3, CarouselComponent_ng_container_0_button_3_Template, 3, 5, "button", 2);
    \u0275\u0275elementStart(4, "div", 3);
    \u0275\u0275template(5, CarouselComponent_ng_container_0_ng_container_5_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, CarouselComponent_ng_container_0_button_6_Template, 3, 5, "button", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275template(7, CarouselComponent_ng_container_0_div_7_Template, 2, 1, "div", 6);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const size_r3 = ctx.ngIf;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", "size-" + size_r3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", size_r3 < ctx_r0.items.length);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r0.items);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", size_r3 < ctx_r0.items.length);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.hideIndicators && size_r3 < ctx_r0.items.length);
  }
}
var _c82 = (a0, a1, a2) => ({
  flexType: a0,
  typeCode: a1,
  uid: a2
});
function BannerCarouselComponent_cx_carousel_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-carousel", 2);
  }
  if (rf & 2) {
    const items_r1 = ctx.ngIf;
    \u0275\u0275nextContext();
    const template_r2 = \u0275\u0275reference(3);
    \u0275\u0275property("items", items_r1)("template", template_r2);
  }
}
function BannerCarouselComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 3);
  }
  if (rf & 2) {
    const item_r3 = ctx.item;
    \u0275\u0275property("cxComponentWrapper", \u0275\u0275pureFunction3(1, _c82, item_r3.typeCode, item_r3.typeCode, item_r3 == null ? null : item_r3.uid));
  }
}
function ConsentManagementComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 2);
    \u0275\u0275element(2, "cx-spinner");
    \u0275\u0275elementEnd()();
  }
}
function ConsentManagementComponent_ng_template_2_ng_container_2_cx_consent_management_form_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "cx-consent-management-form", 10);
    \u0275\u0275listener("consentChanged", function ConsentManagementComponent_ng_template_2_ng_container_2_cx_consent_management_form_11_Template_cx_consent_management_form_consentChanged_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.onConsentChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const consentTemplate_r5 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275property("consentTemplate", consentTemplate_r5)("requiredConsents", ctx_r2.requiredConsents);
  }
}
function ConsentManagementComponent_ng_template_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 5)(2, "div", 6)(3, "button", 7);
    \u0275\u0275listener("click", function ConsentManagementComponent_ng_template_2_ng_container_2_Template_button_click_3_listener() {
      const templateList_r2 = \u0275\u0275restoreView(_r1).ngIf;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.rejectAll(templateList_r2));
    });
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 7);
    \u0275\u0275listener("click", function ConsentManagementComponent_ng_template_2_ng_container_2_Template_button_click_6_listener() {
      const templateList_r2 = \u0275\u0275restoreView(_r1).ngIf;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.allowAll(templateList_r2));
    });
    \u0275\u0275text(7);
    \u0275\u0275pipe(8, "cxTranslate");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(9, "div", 8)(10, "div", 6);
    \u0275\u0275template(11, ConsentManagementComponent_ng_template_2_ng_container_2_cx_consent_management_form_11_Template, 1, 2, "cx-consent-management-form", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const templateList_r2 = ctx.ngIf;
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 3, "consentManagementForm.clearAll"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(8, 5, "consentManagementForm.selectAll"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", templateList_r2);
  }
}
function ConsentManagementComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 3);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275template(2, ConsentManagementComponent_ng_template_2_ng_container_2_Template, 12, 7, "ng-container", 4);
    \u0275\u0275pipe(3, "async");
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 2, "common.loaded"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(3, 4, ctx_r2.templateList$));
  }
}
function PopoverComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 5);
    \u0275\u0275listener("keydown.enter", function PopoverComponent_button_3_Template_button_keydown_enter_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.close($event));
    })("keydown.space", function PopoverComponent_button_3_Template_button_keydown_space_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.close($event));
    })("click", function PopoverComponent_button_3_Template_button_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.close($event));
    });
    \u0275\u0275element(1, "cx-icon", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.iconTypes.CLOSE);
  }
}
function PopoverComponent_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function PopoverComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, PopoverComponent_ng_container_4_ng_container_1_Template, 1, 0, "ng-container", 7);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.content);
  }
}
function PopoverComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.content);
  }
}
var _c92 = (a0) => [a0];
var _c10 = () => ({
  placement: "auto",
  appendToBody: true,
  displayCloseButton: true
});
function TruncateTextPopoverComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate1(" ", ctx_r0.content, " ");
  }
}
function TruncateTextPopoverComponent_button_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 3);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const fullText_r2 = \u0275\u0275reference(6);
    \u0275\u0275property("cxPopover", fullText_r2)("cxPopoverOptions", \u0275\u0275pureFunction0(5, _c10));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 3, "common.more"), " ");
  }
}
var _c11 = [[["", "label_container_bottom", ""]]];
var _c122 = ["[label_container_bottom]"];
var _c13 = (a0) => ({
  number: a0
});
var _c14 = () => ({
  autofocus: true
});
function CardComponent_div_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", "content-header" + (ctx_r0.index >= 0 ? "-" + ctx_r0.index : ""));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.content.header, " ");
  }
}
function CardComponent_div_0_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.content.deleteMsg, " ");
  }
}
function CardComponent_div_0_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 17);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.content.title, " ");
  }
}
function CardComponent_div_0_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.content.textBold, " ");
  }
}
function CardComponent_div_0_div_9_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const line_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", ctx_r0.content.customClass);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", line_r2, " ");
  }
}
function CardComponent_div_0_div_9_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-truncate-text-popover", 21);
  }
  if (rf & 2) {
    const line_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("charactersLimit", ctx_r0.charactersLimit)("content", line_r2)("customClass", ctx_r0.content.customClass);
  }
}
function CardComponent_div_0_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275template(1, CardComponent_div_0_div_9_div_1_Template, 2, 2, "div", 19)(2, CardComponent_div_0_div_9_ng_template_2_Template, 1, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const truncate_r3 = \u0275\u0275reference(3);
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.truncateText)("ngIfElse", truncate_r3);
  }
}
function CardComponent_div_0_div_10_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 24);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const text_r4 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", text_r4, " ");
  }
}
function CardComponent_div_0_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22)(1, "div", 23);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, CardComponent_div_0_div_10_div_3_Template, 3, 1, "div", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r5.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", item_r5.text);
  }
}
function CardComponent_div_0_div_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 25);
    \u0275\u0275element(1, "cx-icon", 26);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r0.content.img);
  }
}
function CardComponent_div_0_div_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 27)(1, "div", 28)(2, "button", 29);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275listener("click", function CardComponent_div_0_div_13_Template_button_click_2_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.cancelEdit());
    });
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 30)(7, "button", 31);
    \u0275\u0275listener("click", function CardComponent_div_0_div_13_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.delete());
    });
    \u0275\u0275text(8);
    \u0275\u0275pipe(9, "cxTranslate");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275property("cxAtMessage", \u0275\u0275pipeBind1(3, 4, "assistiveMessage.actionCancelled"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 6, "common.cancel"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("cxFocus", \u0275\u0275pureFunction0(10, _c14));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(9, 8, "common.delete"), " ");
  }
}
function CardComponent_div_0_div_14_div_1_ng_container_2_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 37);
    \u0275\u0275listener("click", function CardComponent_div_0_div_14_div_1_ng_container_2_button_1_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r0 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r0.delete());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const action_r8 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", action_r8.name, " ");
  }
}
function CardComponent_div_0_div_14_div_1_ng_container_2_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 37);
    \u0275\u0275listener("click", function CardComponent_div_0_div_14_div_1_ng_container_2_button_2_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r0 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r0.setDefault());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const action_r8 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", action_r8.name, " ");
  }
}
function CardComponent_div_0_div_14_div_1_ng_container_2_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 37);
    \u0275\u0275listener("click", function CardComponent_div_0_div_14_div_1_ng_container_2_button_3_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r0.send());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const action_r8 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275attribute("aria-describedby", ctx_r0.index >= 0 && ctx_r0.content.header && !ctx_r0.editMode ? "content-header-" + ctx_r0.index : null);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", action_r8.name, " ");
  }
}
function CardComponent_div_0_div_14_div_1_ng_container_2_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 37);
    \u0275\u0275listener("click", function CardComponent_div_0_div_14_div_1_ng_container_2_button_4_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r0 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r0.edit());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const action_r8 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", action_r8.name, " ");
  }
}
function CardComponent_div_0_div_14_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 35);
    \u0275\u0275template(1, CardComponent_div_0_div_14_div_1_ng_container_2_button_1_Template, 2, 1, "button", 36)(2, CardComponent_div_0_div_14_div_1_ng_container_2_button_2_Template, 2, 1, "button", 36)(3, CardComponent_div_0_div_14_div_1_ng_container_2_button_3_Template, 2, 2, "button", 36)(4, CardComponent_div_0_div_14_div_1_ng_container_2_button_4_Template, 2, 1, "button", 36);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const action_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("ngSwitch", action_r8.event);
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "delete");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "default");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "send");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "edit");
  }
}
function CardComponent_div_0_div_14_div_1_a_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 38);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const action_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275propertyInterpolate("href", action_r8.link, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", action_r8.name, " ");
  }
}
function CardComponent_div_0_div_14_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div");
    \u0275\u0275template(2, CardComponent_div_0_div_14_div_1_ng_container_2_Template, 5, 5, "ng-container", 33)(3, CardComponent_div_0_div_14_div_1_a_3_Template, 2, 2, "a", 34);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const action_r8 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.isCardAction(action_r8));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.isCardLinkAction(action_r8));
  }
}
function CardComponent_div_0_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 32);
    \u0275\u0275template(1, CardComponent_div_0_div_14_div_1_Template, 4, 2, "div", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.content.actions);
  }
}
function CardComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275template(2, CardComponent_div_0_div_2_Template, 2, 2, "div", 3);
    \u0275\u0275elementStart(3, "div", 4);
    \u0275\u0275template(4, CardComponent_div_0_div_4_Template, 2, 1, "div", 5)(5, CardComponent_div_0_span_5_Template, 2, 1, "span", 6);
    \u0275\u0275elementStart(6, "div", 7)(7, "div", 8);
    \u0275\u0275template(8, CardComponent_div_0_div_8_Template, 2, 1, "div", 9)(9, CardComponent_div_0_div_9_Template, 4, 2, "div", 10)(10, CardComponent_div_0_div_10_Template, 4, 2, "div", 11);
    \u0275\u0275projection(11);
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, CardComponent_div_0_div_12_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275template(13, CardComponent_div_0_div_13_Template, 10, 11, "div", 13)(14, CardComponent_div_0_div_14_Template, 2, 1, "div", 14);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_4_0;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("cx-card-border", ctx_r0.border)("cx-card-fit-to-container", ctx_r0.fitToContainer);
    \u0275\u0275property("tabindex", ctx_r0.border ? 0 : -1);
    \u0275\u0275attribute("role", (tmp_4_0 = ctx_r0.content.role) !== null && tmp_4_0 !== void 0 ? tmp_4_0 : null)("aria-label", ctx_r0.content.label ? \u0275\u0275pipeBind2(1, 18, ctx_r0.content.label, \u0275\u0275pureFunction1(21, _c13, ctx_r0.index)) : null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.content.header && !ctx_r0.editMode);
    \u0275\u0275advance();
    \u0275\u0275classProp("cx-card-delete", ctx_r0.editMode);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.editMode);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.content.title);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r0.content.textBold);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.content.text);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.content.paragraphs);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.content.img);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.editMode);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.content.actions && !ctx_r0.editMode);
  }
}
function MediaComponent_picture_0_source_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "source", 4);
  }
  if (rf & 2) {
    const source_r1 = ctx.$implicit;
    \u0275\u0275property("srcset", source_r1.srcset)("media", source_r1.media);
  }
}
function MediaComponent_picture_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "picture");
    \u0275\u0275template(1, MediaComponent_picture_0_source_1_Template, 1, 2, "source", 2);
    \u0275\u0275pipe(2, "cxMediaSources");
    \u0275\u0275elementContainer(3, 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const tmpImg_r3 = \u0275\u0275reference(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", \u0275\u0275pipeBind1(2, 3, ctx_r1.media.srcset))("ngForTrackBy", ctx_r1.trackByMedia);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", tmpImg_r3);
  }
}
function MediaComponent_ng_template_1_img_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "img", 6);
    \u0275\u0275listener("load", function MediaComponent_ng_template_1_img_0_Template_img_load_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.loadHandler());
    })("error", function MediaComponent_ng_template_1_img_0_Template_img_error_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.errorHandler());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("alt", ctx_r1.media.alt)("src", ctx_r1.media.src, \u0275\u0275sanitizeUrl)("srcset", ctx_r1.media.srcset || ctx_r1.media.src)("loading", ctx_r1.loading);
    \u0275\u0275attribute("role", ctx_r1.media.role);
  }
}
function MediaComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, MediaComponent_ng_template_1_img_0_Template, 1, 5, "img", 5);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r1.media && ctx_r1.media.src);
  }
}
function FormErrorsComponent_ng_container_0_ng_container_1_p_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const error_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(2, 1, ctx_r1.prefix + "." + error_r1[0], ctx_r1.getTranslationParams(error_r1[1])), " ");
  }
}
function FormErrorsComponent_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, FormErrorsComponent_ng_container_0_ng_container_1_p_1_Template, 3, 4, "p", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const errorDetails_r3 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", errorDetails_r3);
  }
}
function FormErrorsComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, FormErrorsComponent_ng_container_0_ng_container_1_Template, 2, 1, "ng-container", 0);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.hidden);
  }
}
var _c15 = (a0, a1) => ({
  max: a0,
  min: a1
});
var _c16 = ["fileInput"];
function FileUploadComponent_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 5);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275listener("click", function FileUploadComponent_button_2_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      \u0275\u0275nextContext();
      const fileInput_r3 = \u0275\u0275reference(1);
      return \u0275\u0275resetView(fileInput_r3.click());
    });
    \u0275\u0275projection(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 1, "common.selectFile"));
  }
}
function FileUploadComponent_button_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function FileUploadComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 6);
    \u0275\u0275listener("click", function FileUploadComponent_button_3_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      \u0275\u0275nextContext();
      const fileInput_r3 = \u0275\u0275reference(1);
      return \u0275\u0275resetView(fileInput_r3.click());
    });
    \u0275\u0275template(1, FileUploadComponent_button_3_ng_container_1_Template, 1, 0, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r4.customButton);
  }
}
function FileUploadComponent_p_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const file_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", file_r6 == null ? null : file_r6.name, "\n");
  }
}
function GenericLinkComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function GenericLinkComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "a", 3);
    \u0275\u0275template(2, GenericLinkComponent_ng_container_0_ng_container_2_Template, 1, 0, "ng-container", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const content_r2 = \u0275\u0275reference(4);
    \u0275\u0275advance();
    \u0275\u0275property("href", ctx_r0.url, \u0275\u0275sanitizeUrl);
    \u0275\u0275attribute("target", ctx_r0.target)("rel", ctx_r0.rel)("id", ctx_r0.id)("class", ctx_r0.class)("style", ctx_r0.style, \u0275\u0275sanitizeStyle)("title", ctx_r0.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", content_r2);
  }
}
function GenericLinkComponent_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function GenericLinkComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5);
    \u0275\u0275template(1, GenericLinkComponent_ng_template_1_ng_container_1_Template, 1, 0, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const content_r2 = \u0275\u0275reference(4);
    \u0275\u0275property("routerLink", ctx_r0.routerUrl)("queryParams", ctx_r0.queryParams)("fragment", ctx_r0.fragment)("target", ctx_r0.target || void 0);
    \u0275\u0275attribute("id", ctx_r0.id)("class", ctx_r0.class)("style", ctx_r0.style, \u0275\u0275sanitizeStyle)("title", ctx_r0.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", content_r2);
  }
}
function GenericLinkComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c17 = ["qty"];
var _c18 = (a0, a1) => ({
  ariaLabel: a0,
  ariaControls: a1
});
function SortingComponent_ng_option_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ng-option", 2);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const sort_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("value", sort_r1.code);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(sort_r1.name ? sort_r1.name : ctx_r1.sortLabels && sort_r1.code ? ctx_r1.sortLabels[sort_r1.code] : "");
  }
}
function PaginationComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 1);
    \u0275\u0275listener("click", function PaginationComponent_a_0_Template_a_click_0_listener() {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.pageChange(item_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(item_r2.type);
    \u0275\u0275classProp("disabled", ctx_r2.isInactive(item_r2))("current", ctx_r2.isCurrent(item_r2));
    \u0275\u0275property("routerLink", ctx_r2.pageRoute)("queryParams", ctx_r2.getQueryParams(item_r2))("tabIndex", ctx_r2.isInactive(item_r2) ? -1 : 0);
    \u0275\u0275attribute("aria-label", ctx_r2.getAriaLabel(item_r2.label, item_r2.type));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", item_r2.label, "\n");
  }
}
function TotalComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "div", 1);
    \u0275\u0275elementStart(5, "div");
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2("", ctx_r0.totalResults, " ", \u0275\u0275pipeBind1(3, 6, "common.results"), "");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate4(" ", ctx_r0.fromItem, "-", ctx_r0.toItem, " ", \u0275\u0275pipeBind1(7, 8, "common.of"), " ", ctx_r0.totalResults, " ");
  }
}
function ProgressButtonComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3)(1, "div", 4);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(3, 1, "spinner.loading"));
  }
}
function GlobalMessageComponent_div_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6)(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const assistiveMsg_r1 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(3, 1, assistiveMsg_r1));
  }
}
function GlobalMessageComponent_div_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7)(1, "span", 8);
    \u0275\u0275element(2, "cx-icon", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 10);
    \u0275\u0275listener("click", function GlobalMessageComponent_div_0_div_2_Template_button_click_6_listener() {
      const i_r3 = \u0275\u0275restoreView(_r2).index;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.clear(ctx_r3.messageType.MSG_TYPE_CONFIRMATION, i_r3));
    });
    \u0275\u0275element(7, "cx-icon", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const confMsg_r5 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r3.iconTypes.SUCCESS);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 3, confMsg_r5));
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r3.iconTypes.CLOSE);
  }
}
function GlobalMessageComponent_div_0_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 11)(1, "span", 8);
    \u0275\u0275element(2, "cx-icon", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 10);
    \u0275\u0275listener("click", function GlobalMessageComponent_div_0_div_3_Template_button_click_6_listener() {
      const i_r7 = \u0275\u0275restoreView(_r6).index;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.clear(ctx_r3.messageType.MSG_TYPE_INFO, i_r7));
    });
    \u0275\u0275element(7, "cx-icon", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const infoMsg_r8 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r3.iconTypes.INFO);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 3, infoMsg_r8));
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r3.iconTypes.CLOSE);
  }
}
function GlobalMessageComponent_div_0_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 12)(1, "span", 8);
    \u0275\u0275element(2, "cx-icon", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 10);
    \u0275\u0275listener("click", function GlobalMessageComponent_div_0_div_4_Template_button_click_6_listener() {
      const i_r10 = \u0275\u0275restoreView(_r9).index;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.clear(ctx_r3.messageType.MSG_TYPE_WARNING, i_r10));
    });
    \u0275\u0275element(7, "cx-icon", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const infoMsg_r11 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r3.iconTypes.WARNING);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 3, infoMsg_r11));
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r3.iconTypes.CLOSE);
  }
}
function GlobalMessageComponent_div_0_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 13)(1, "span", 8);
    \u0275\u0275element(2, "cx-icon", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 10);
    \u0275\u0275listener("click", function GlobalMessageComponent_div_0_div_5_Template_button_click_6_listener() {
      const i_r13 = \u0275\u0275restoreView(_r12).index;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.clear(ctx_r3.messageType.MSG_TYPE_ERROR, i_r13));
    });
    \u0275\u0275element(7, "cx-icon", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const errorMsg_r14 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r3.iconTypes.ERROR);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 3, errorMsg_r14));
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r3.iconTypes.CLOSE);
  }
}
function GlobalMessageComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275template(1, GlobalMessageComponent_div_0_div_1_Template, 4, 3, "div", 1)(2, GlobalMessageComponent_div_0_div_2_Template, 8, 5, "div", 2)(3, GlobalMessageComponent_div_0_div_3_Template, 8, 5, "div", 3)(4, GlobalMessageComponent_div_0_div_4_Template, 8, 5, "div", 4)(5, GlobalMessageComponent_div_0_div_5_Template, 8, 5, "div", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const messages_r15 = ctx.ngIf;
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", messages_r15[ctx_r3.messageType.MSG_TYPE_ASSISTIVE]);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", messages_r15[ctx_r3.messageType.MSG_TYPE_CONFIRMATION]);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", messages_r15[ctx_r3.messageType.MSG_TYPE_INFO]);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", messages_r15[ctx_r3.messageType.MSG_TYPE_WARNING]);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", messages_r15[ctx_r3.messageType.MSG_TYPE_ERROR]);
  }
}
function MessageComponent_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 10);
    \u0275\u0275listener("click", function MessageComponent_button_7_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showBody = !ctx_r1.showBody);
    });
    \u0275\u0275text(1);
    \u0275\u0275element(2, "cx-icon", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("aria-expanded", ctx_r1.showBody)("aria-label", ctx_r1.accordionText);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.accordionText, " ");
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.showBody ? "CARET_UP" : "CARET_DOWN");
  }
}
function MessageComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 12);
    \u0275\u0275listener("click", function MessageComponent_button_8_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.buttonAction.emit());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("cxAtMessage", ctx_r1.actionButtonMessage);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.actionButtonText, " ");
  }
}
function MessageComponent_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 13);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275listener("click", function MessageComponent_button_9_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closeMessage.emit());
    });
    \u0275\u0275element(3, "cx-icon", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("cxAtMessage", \u0275\u0275pipeBind1(1, 3, "common.close"));
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 5, "common.close"));
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r1.iconTypes.CLOSE);
  }
}
function MessageComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14);
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
  }
}
function PromotionsComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "p");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.promotions[0].description);
  }
}
function PromotionsComponent_div_0_ng_container_2_li_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const promotion_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", promotion_r2.description, " ");
  }
}
function PromotionsComponent_div_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "ul");
    \u0275\u0275template(2, PromotionsComponent_div_0_ng_container_2_li_2_Template, 2, 1, "li", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r0.promotions);
  }
}
function PromotionsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275template(1, PromotionsComponent_div_0_ng_container_1_Template, 3, 1, "ng-container", 2)(2, PromotionsComponent_div_0_ng_container_2_Template, 3, 1, "ng-container", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.promotions.length === 1);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.promotions.length > 1);
  }
}
function SiteContextSelectorComponent_label_0_option_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 4);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275propertyInterpolate("value", item_r3.isocode);
    \u0275\u0275property("selected", \u0275\u0275pipeBind1(1, 3, ctx_r1.activeItem$) === item_r3.isocode);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", item_r3.label, " ");
  }
}
function SiteContextSelectorComponent_label_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label")(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "async");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "select", 1);
    \u0275\u0275listener("change", function SiteContextSelectorComponent_label_0_Template_select_change_4_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.active = $event.target.value);
    });
    \u0275\u0275template(5, SiteContextSelectorComponent_label_0_option_5_Template, 3, 5, "option", 2);
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "cx-icon", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const items_r4 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(3, 3, ctx_r1.label$), ":");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", items_r4);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.iconTypes.CARET_DOWN);
  }
}
var _c19 = () => [1, 2, 3, 4, 5];
var _c20 = (a0) => ({
  count: a0
});
function StarRatingComponent_cx_icon_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "cx-icon", 1);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275listener("mouseover", function StarRatingComponent_cx_icon_0_Template_cx_icon_mouseover_0_listener() {
      const i_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.setRate(i_r2));
    })("click", function StarRatingComponent_cx_icon_0_Template_cx_icon_click_0_listener() {
      const i_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.saveRate(i_r2));
    })("keydown.space", function StarRatingComponent_cx_icon_0_Template_cx_icon_keydown_space_0_listener() {
      const i_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.saveRate(i_r2));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("type", ctx_r2.icon);
    \u0275\u0275attribute("tabindex", ctx_r2.disabled ? null : 0)("aria-label", \u0275\u0275pipeBind2(1, 3, "productReview.addRate", \u0275\u0275pureFunction1(6, _c20, i_r2)));
  }
}
function TableComponent_table_0_ng_container_1_tbody_1_tr_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const cell_r4 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", cell_r4, " ");
  }
}
function TableComponent_table_0_ng_container_1_tbody_1_tr_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const cell_r4 = \u0275\u0275nextContext().$implicit;
    const item_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", item_r2[cell_r4], " ");
  }
}
function TableComponent_table_0_ng_container_1_tbody_1_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "th");
    \u0275\u0275template(2, TableComponent_table_0_ng_container_1_tbody_1_tr_1_ng_template_2_Template, 1, 1, "ng-template", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td");
    \u0275\u0275template(4, TableComponent_table_0_ng_container_1_tbody_1_tr_1_ng_template_4_Template, 1, 1, "ng-template", 4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const cell_r4 = ctx.$implicit;
    const item_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(cell_r4);
    \u0275\u0275advance(2);
    \u0275\u0275property("cxOutlet", ctx_r2.getHeaderOutletRef(cell_r4))("cxOutletContext", ctx_r2.getHeaderOutletContext(cell_r4));
    \u0275\u0275advance(2);
    \u0275\u0275property("cxOutlet", ctx_r2.getDataOutletRef(cell_r4))("cxOutletContext", ctx_r2.getDataOutletContext(cell_r4, item_r2));
  }
}
function TableComponent_table_0_ng_container_1_tbody_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tbody", 2);
    \u0275\u0275listener("click", function TableComponent_table_0_ng_container_1_tbody_1_Template_tbody_click_0_listener() {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.launchItem(item_r2));
    });
    \u0275\u0275template(1, TableComponent_table_0_ng_container_1_tbody_1_tr_1_Template, 5, 6, "tr", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("is-current", ctx_r2.isCurrentItem(item_r2));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r2.structure.cells);
  }
}
function TableComponent_table_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TableComponent_table_0_ng_container_1_tbody_1_Template, 2, 3, "tbody", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r2.data)("ngForTrackBy", ctx_r2.trackData);
  }
}
function TableComponent_table_0_ng_container_2_th_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const cell_r5 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", cell_r5, " ");
  }
}
function TableComponent_table_0_ng_container_2_th_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 6);
    \u0275\u0275template(1, TableComponent_table_0_ng_container_2_th_3_ng_template_1_Template, 1, 1, "ng-template", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r5 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(cell_r5);
    \u0275\u0275advance();
    \u0275\u0275property("cxOutlet", ctx_r2.getHeaderOutletRef(cell_r5))("cxOutletContext", ctx_r2.getHeaderOutletContext(cell_r5));
  }
}
function TableComponent_table_0_ng_container_2_tr_4_td_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const cell_r8 = \u0275\u0275nextContext().$implicit;
    const item_r7 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", item_r7[cell_r8], " ");
  }
}
function TableComponent_table_0_ng_container_2_tr_4_td_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td");
    \u0275\u0275template(1, TableComponent_table_0_ng_container_2_tr_4_td_1_ng_template_1_Template, 1, 1, "ng-template", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r8 = ctx.$implicit;
    const item_r7 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(cell_r8);
    \u0275\u0275advance();
    \u0275\u0275property("cxOutlet", ctx_r2.getDataOutletRef(cell_r8))("cxOutletContext", ctx_r2.getDataOutletContext(cell_r8, item_r7));
  }
}
function TableComponent_table_0_ng_container_2_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr", 2);
    \u0275\u0275listener("click", function TableComponent_table_0_ng_container_2_tr_4_Template_tr_click_0_listener() {
      const item_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.launchItem(item_r7));
    });
    \u0275\u0275template(1, TableComponent_table_0_ng_container_2_tr_4_td_1_Template, 2, 4, "td", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("is-current", ctx_r2.isCurrentItem(item_r7));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r2.structure.cells);
  }
}
function TableComponent_table_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "thead")(2, "tr");
    \u0275\u0275template(3, TableComponent_table_0_ng_container_2_th_3_Template, 2, 4, "th", 5);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(4, TableComponent_table_0_ng_container_2_tr_4_Template, 2, 3, "tr", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r2.structure.cells);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r2.data)("ngForTrackBy", ctx_r2.trackData);
  }
}
function TableComponent_table_0_ng_container_3_tr_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", cell_r9, " ");
  }
}
function TableComponent_table_0_ng_container_3_tr_1_td_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const item_r11 = \u0275\u0275nextContext().$implicit;
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", item_r11[cell_r9], " ");
  }
}
function TableComponent_table_0_ng_container_3_tr_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 2);
    \u0275\u0275listener("click", function TableComponent_table_0_ng_container_3_tr_1_td_3_Template_td_click_0_listener() {
      const item_r11 = \u0275\u0275restoreView(_r10).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r2.launchItem(item_r11));
    });
    \u0275\u0275template(1, TableComponent_table_0_ng_container_3_tr_1_td_3_ng_template_1_Template, 1, 1, "ng-template", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r11 = ctx.$implicit;
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("is-current", ctx_r2.isCurrentItem(item_r11));
    \u0275\u0275advance();
    \u0275\u0275property("cxOutlet", ctx_r2.getDataOutletRef(cell_r9))("cxOutletContext", ctx_r2.getDataOutletContext(cell_r9, item_r11));
  }
}
function TableComponent_table_0_ng_container_3_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "th", 6);
    \u0275\u0275template(2, TableComponent_table_0_ng_container_3_tr_1_ng_template_2_Template, 1, 1, "ng-template", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, TableComponent_table_0_ng_container_3_tr_1_td_3_Template, 2, 4, "td", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(cell_r9);
    \u0275\u0275advance(2);
    \u0275\u0275property("cxOutlet", ctx_r2.getHeaderOutletRef(cell_r9))("cxOutletContext", ctx_r2.getHeaderOutletContext(cell_r9));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r2.data)("ngForTrackBy", ctx_r2.trackData);
  }
}
function TableComponent_table_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TableComponent_table_0_ng_container_3_tr_1_Template, 4, 6, "tr", 3);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r2.structure.cells);
  }
}
function TableComponent_table_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "table");
    \u0275\u0275template(1, TableComponent_table_0_ng_container_1_Template, 2, 2, "ng-container", 0)(2, TableComponent_table_0_ng_container_2_Template, 5, 3, "ng-container", 0)(3, TableComponent_table_0_ng_container_3_Template, 2, 1, "ng-container", 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.verticalStackedLayout);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.verticalLayout);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.horizontalLayout);
  }
}
var _c21 = (a0) => ({
  "right-align": a0
});
function AvatarComponent_div_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.getInitials((ctx_r0.message == null ? null : ctx_r0.message.author) || ""), " ");
  }
}
function AvatarComponent_div_0_cx_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("type", ctx_r0.iconTypes.USER);
  }
}
function AvatarComponent_div_0_cx_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("type", ctx_r0.iconTypes.HEADSET);
  }
}
function AvatarComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275template(1, AvatarComponent_div_0_span_1_Template, 2, 1, "span", 2)(2, AvatarComponent_div_0_cx_icon_2_Template, 1, 1, "cx-icon", 3)(3, AvatarComponent_div_0_cx_icon_3_Template, 1, 1, "cx-icon", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(4, _c21, ctx_r0.message.rightAlign));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.message.rightAlign && (ctx_r0.message == null ? null : ctx_r0.message.author));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.message.rightAlign && !(ctx_r0.message == null ? null : ctx_r0.message.author));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.message.rightAlign);
  }
}
var _c222 = (a0) => ({
  "cx-message-display": a0
});
var _c23 = (a0, a1, a2) => ({
  author: a0,
  text: a1,
  date: a2
});
var _c24 = () => [];
function MessagingComponent_ng_container_0_ng_container_5_a_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 10);
    \u0275\u0275listener("click", function MessagingComponent_ng_container_0_ng_container_5_a_11_Template_a_click_0_listener() {
      const attachment_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const message_r5 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.triggerDownload(message_r5 == null ? null : message_r5.code, attachment_r4 == null ? null : attachment_r4.id, attachment_r4 == null ? null : attachment_r4.filename));
    });
    \u0275\u0275element(1, "cx-icon", 11);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const attachment_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.iconTypes.ATTACHMENT);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", attachment_r4.filename, " ");
  }
}
function MessagingComponent_ng_container_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 6);
    \u0275\u0275element(2, "cx-avatar", 7);
    \u0275\u0275elementStart(3, "div")(4, "label");
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "cxDate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 8);
    \u0275\u0275pipe(8, "cxDate");
    \u0275\u0275pipe(9, "cxTranslate");
    \u0275\u0275text(10);
    \u0275\u0275elementEnd();
    \u0275\u0275template(11, MessagingComponent_ng_container_0_ng_container_5_a_11_Template, 3, 2, "a", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_7_0;
    let tmp_8_0;
    let tmp_10_0;
    let tmp_12_0;
    const message_r5 = ctx.$implicit;
    const i_r6 = ctx.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(17, _c222, (tmp_5_0 = message_r5 == null ? null : message_r5.rightAlign) !== null && tmp_5_0 !== void 0 ? tmp_5_0 : false));
    \u0275\u0275advance();
    \u0275\u0275property("message", message_r5);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate((tmp_7_0 = \u0275\u0275pipeBind2(6, 8, message_r5 == null ? null : message_r5.createdAt, ctx_r1.messagingConfigs == null ? null : ctx_r1.messagingConfigs.dateFormat)) !== null && tmp_7_0 !== void 0 ? tmp_7_0 : ctx_r1.dateFormat);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", ((tmp_8_0 = message_r5 == null ? null : message_r5.rightAlign) !== null && tmp_8_0 !== void 0 ? tmp_8_0 : false) ? "cx-message-right-align-text" : "cx-message-left-align-text")("tabindex", i_r6 ? -1 : 0);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind2(9, 14, "chatMessaging.informationLabel", \u0275\u0275pureFunction3(19, _c23, message_r5 == null ? null : message_r5.author, message_r5 == null ? null : message_r5.text, (tmp_10_0 = \u0275\u0275pipeBind2(8, 11, message_r5 == null ? null : message_r5.createdAt, ctx_r1.messagingConfigs == null ? null : ctx_r1.messagingConfigs.dateFormat)) !== null && tmp_10_0 !== void 0 ? tmp_10_0 : ctx_r1.dateFormat)));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", message_r5 == null ? null : message_r5.text, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", (tmp_12_0 = message_r5 == null ? null : message_r5.attachments) !== null && tmp_12_0 !== void 0 ? tmp_12_0 : \u0275\u0275pureFunction0(23, _c24));
  }
}
function MessagingComponent_ng_container_0_div_6_span_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 23);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "chatMessaging.characterLimitAlert"), " ");
  }
}
function MessagingComponent_ng_container_0_div_6_cx_file_upload_14_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-icon", 11);
    \u0275\u0275elementStart(1, "span", 25);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("type", ctx_r1.iconTypes.UPLOAD);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(3, 2, "chatMessaging.uploadFile"), " ");
  }
}
function MessagingComponent_ng_container_0_div_6_cx_file_upload_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "cx-file-upload", 24);
    \u0275\u0275template(1, MessagingComponent_ng_container_0_div_6_cx_file_upload_14_ng_template_1_Template, 4, 4, "ng-template");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("formControl", ctx_r1.form.get("file"))("accept", ctx_r1.allowedTypes);
  }
}
function MessagingComponent_ng_container_0_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 12)(1, "div", 13)(2, "label", 14)(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 15)(7, "input", 16);
    \u0275\u0275pipe(8, "cxTranslate");
    \u0275\u0275listener("keydown.enter", function MessagingComponent_ng_container_0_div_6_Template_input_keydown_enter_7_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onSend());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(9, MessagingComponent_ng_container_0_div_6_span_9_Template, 3, 3, "span", 17);
    \u0275\u0275elementStart(10, "button", 18);
    \u0275\u0275listener("click", function MessagingComponent_ng_container_0_div_6_Template_button_click_10_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onSend());
    });
    \u0275\u0275text(11);
    \u0275\u0275pipe(12, "cxTranslate");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(13, "div", 19);
    \u0275\u0275template(14, MessagingComponent_ng_container_0_div_6_cx_file_upload_14_Template, 2, 2, "cx-file-upload", 20);
    \u0275\u0275elementStart(15, "p", 21);
    \u0275\u0275text(16);
    \u0275\u0275pipe(17, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(18, "cx-form-errors", 22);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("formGroup", ctx_r1.form);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 9, "chatMessaging.addNewMessage"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275propertyInterpolate("placeholder", (ctx_r1.messagingConfigs == null ? null : ctx_r1.messagingConfigs.newMessagePlaceHolder) || \u0275\u0275pipeBind1(8, 11, "chatMessaging.addMessagePlaceHolder"));
    \u0275\u0275property("maxLength", (ctx_r1.messagingConfigs == null ? null : ctx_r1.messagingConfigs.charactersLimit) || ctx_r1.MAX_INPUT_CHARACTERS);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.inputCharacterLeft === 0);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(12, 13, "chatMessaging.send"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r1.messagingConfigs == null ? null : ctx_r1.messagingConfigs.enableFileUploadOption);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(17, 15, "chatMessaging.charactersLeft", \u0275\u0275pureFunction1(18, _c20, ctx_r1.inputCharacterLeft)), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.form.get("file"));
  }
}
function MessagingComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 1);
    \u0275\u0275element(2, "div", 2);
    \u0275\u0275elementStart(3, "div", 3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275listener("keydown.arrowdown", function MessagingComponent_ng_container_0_Template_div_keydown_arrowdown_3_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.focusNextChild($event));
    })("keydown.arrowup", function MessagingComponent_ng_container_0_Template_div_keydown_arrowup_3_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.focusPreviousChild($event));
    });
    \u0275\u0275template(5, MessagingComponent_ng_container_0_ng_container_5_Template, 12, 24, "ng-container", 4);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(6, MessagingComponent_ng_container_0_div_6_Template, 19, 20, "div", 5);
    \u0275\u0275pipe(7, "async");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const messageEvents_r8 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(4, 3, "chatMessaging.messages"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", messageEvents_r8);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(7, 5, ctx_r1.messagingConfigs == null ? null : ctx_r1.messagingConfigs.displayAddMessageSection));
  }
}
function BannerComponent_ng_container_0_cx_generic_link_1_p_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p", 6);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275property("innerHTML", data_r1.headline, \u0275\u0275sanitizeHtml);
  }
}
function BannerComponent_ng_container_0_cx_generic_link_1_p_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p", 7);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275property("innerHTML", data_r1.content, \u0275\u0275sanitizeHtml);
  }
}
function BannerComponent_ng_container_0_cx_generic_link_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "cx-generic-link", 2);
    \u0275\u0275template(1, BannerComponent_ng_container_0_cx_generic_link_1_p_1_Template, 1, 1, "p", 3);
    \u0275\u0275element(2, "cx-media", 4);
    \u0275\u0275template(3, BannerComponent_ng_container_0_cx_generic_link_1_p_3_Template, 1, 1, "p", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("url", ctx_r1.routerLink)("target", ctx_r1.getTarget(data_r1));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", data_r1.headline);
    \u0275\u0275advance();
    \u0275\u0275property("container", ctx_r1.getImage(data_r1));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", data_r1.content);
  }
}
function BannerComponent_ng_container_0_ng_container_2_p_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p", 6);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275property("innerHTML", data_r1.headline, \u0275\u0275sanitizeHtml);
  }
}
function BannerComponent_ng_container_0_ng_container_2_p_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p", 7);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275property("innerHTML", data_r1.content, \u0275\u0275sanitizeHtml);
  }
}
function BannerComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 8);
    \u0275\u0275template(2, BannerComponent_ng_container_0_ng_container_2_p_2_Template, 1, 1, "p", 3);
    \u0275\u0275element(3, "cx-media", 4);
    \u0275\u0275template(4, BannerComponent_ng_container_0_ng_container_2_p_4_Template, 1, 1, "p", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", data_r1.headline);
    \u0275\u0275advance();
    \u0275\u0275property("container", ctx_r1.getImage(data_r1));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", data_r1.content);
  }
}
function BannerComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, BannerComponent_ng_container_0_cx_generic_link_1_Template, 4, 5, "cx-generic-link", 1)(2, BannerComponent_ng_container_0_ng_container_2_Template, 5, 3, "ng-container", 0);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.routerLink);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.routerLink);
  }
}
function LinkComponent_cx_generic_link_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "cx-generic-link", 1);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_3_0;
    const data_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(data_r1.styleAttributes);
    \u0275\u0275property("url", (tmp_3_0 = data_r1.url) !== null && tmp_3_0 !== void 0 ? tmp_3_0 : "")("target", ctx_r1.getTarget(data_r1));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(data_r1.linkName);
  }
}
function ParagraphComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 1);
    \u0275\u0275pipe(1, "cxSupplementHashAnchors");
  }
  if (rf & 2) {
    const data_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r1.bypassSecurityTrustHtml(\u0275\u0275pipeBind1(1, 1, data_r1.content)), \u0275\u0275sanitizeHtml);
  }
}
function PDFComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 1)(2, "a", 2)(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "span", 3);
    \u0275\u0275element(7, "cx-icon", 4);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const data_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("href", ctx_r1.url, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.addPdfExtension((data_r1 == null ? null : data_r1.title) || (data_r1 == null ? null : data_r1.pdfFile == null ? null : data_r1.pdfFile.altText) || \u0275\u0275pipeBind1(5, 3, "pdf.defaultTitle")));
    \u0275\u0275advance(3);
    \u0275\u0275property("type", "PDF_FILE");
  }
}
var _c25 = (a0) => ({
  param: a0
});
var _c26 = () => ({});
function TabParagraphContainerComponent_ng_container_0_ng_container_3_ng_container_1_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0, 7);
    \u0275\u0275listener("cxComponentRef", function TabParagraphContainerComponent_ng_container_0_ng_container_3_ng_container_1_ng_template_7_Template_ng_container_cxComponentRef_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r2.tabCompLoaded($event));
    });
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const component_r5 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("cxComponentWrapper", component_r5);
  }
}
function TabParagraphContainerComponent_ng_container_0_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 3);
    \u0275\u0275listener("click", function TabParagraphContainerComponent_ng_container_0_ng_container_3_ng_container_1_Template_button_click_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const i_r2 = \u0275\u0275nextContext().index;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.select(i_r2, $event));
    });
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "async");
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275element(5, "span", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 5);
    \u0275\u0275template(7, TabParagraphContainerComponent_ng_container_0_ng_container_3_ng_container_1_ng_template_7_Template, 1, 1, "ng-template", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    const component_r5 = ctx_r5.$implicit;
    const i_r2 = ctx_r5.index;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275classProp("active", i_r2 === ctx_r2.activeTabNum);
    \u0275\u0275attribute("aria-expanded", i_r2 === ctx_r2.activeTabNum);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(4, 10, component_r5.title, \u0275\u0275pureFunction1(13, _c25, \u0275\u0275pipeBind1(3, 8, ctx_r2.tabTitleParams[i_r2]))), " ");
    \u0275\u0275advance(4);
    \u0275\u0275classProp("active", i_r2 === ctx_r2.activeTabNum);
    \u0275\u0275advance();
    \u0275\u0275property("cxOutlet", component_r5.flexType)("cxOutletContext", \u0275\u0275pureFunction0(15, _c26));
  }
}
function TabParagraphContainerComponent_ng_container_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TabParagraphContainerComponent_ng_container_0_ng_container_3_ng_container_1_Template, 8, 16, "ng-container", 0);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const component_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", component_r5);
  }
}
function TabParagraphContainerComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275template(3, TabParagraphContainerComponent_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const components_r7 = ctx.ngIf;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 2, ctx_r2.ariaLabel));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", components_r7);
  }
}
function VideoComponent_div_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("routerLink", ctx_r1.routerLink);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(data_r1.overlayTitle);
  }
}
function VideoComponent_div_0_video_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "video", 6);
    \u0275\u0275pipe(1, "cxTranslate");
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("height", data_r1.videoContainerHeight, "px");
    \u0275\u0275property("poster", ctx_r1.thumbnail == null ? null : ctx_r1.thumbnail.src, \u0275\u0275sanitizeUrl)("loop", ctx_r1.loop)("autoplay", ctx_r1.autoPlay)("muted", ctx_r1.mute)("src", ctx_r1.source, \u0275\u0275sanitizeUrl);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 8, "player.label"));
  }
}
function VideoComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275template(1, VideoComponent_div_0_a_1_Template, 2, 2, "a", 3)(2, VideoComponent_div_0_video_2_Template, 2, 10, "video", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const data_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", data_r1.overlayTitle);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.source);
  }
}
function VideoComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
var _c27 = () => ({
  tab: true
});
function SkipLinkComponent_div_0_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 3);
    \u0275\u0275listener("click", function SkipLinkComponent_div_0_button_1_Template_button_click_0_listener() {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.scrollToTarget(link_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" ", \u0275\u0275pipeBind1(2, 2, "skipLink.skipTo"), " ", \u0275\u0275pipeBind1(3, 4, link_r2.i18nKey), " ");
  }
}
function SkipLinkComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275template(1, SkipLinkComponent_div_0_button_1_Template, 4, 6, "button", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const links_r4 = ctx.ngIf;
    \u0275\u0275property("cxFocus", \u0275\u0275pureFunction0(2, _c27));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", links_r4);
  }
}
var _c28 = () => ({
  disableMouseFocus: true
});
function StorefrontComponent_ng_template_0_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "header", 4);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275listener("keydown.escape", function StorefrontComponent_ng_template_0_ng_template_0_Template_header_keydown_escape_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.collapseMenu());
    })("click", function StorefrontComponent_ng_template_0_ng_template_0_Template_header_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.collapseMenuIfClickOutside($event));
    });
    \u0275\u0275element(2, "cx-page-layout", 5)(3, "cx-page-layout", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "cx-page-slot", 7)(5, "cx-global-message", 8);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("is-expanded", \u0275\u0275pipeBind1(1, 3, ctx_r1.isExpanded$));
    \u0275\u0275property("cxFocus", \u0275\u0275pureFunction0(5, _c28));
  }
}
function StorefrontComponent_ng_template_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "footer", 9);
    \u0275\u0275element(1, "cx-page-layout", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("cxFocus", \u0275\u0275pureFunction0(1, _c28));
  }
}
function StorefrontComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, StorefrontComponent_ng_template_0_ng_template_0_Template, 6, 6, "ng-template", 1);
    \u0275\u0275elementStart(1, "main", 2);
    \u0275\u0275element(2, "router-outlet");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, StorefrontComponent_ng_template_0_ng_template_3_Template, 2, 2, "ng-template", 3);
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("cxFocus", \u0275\u0275pureFunction0(1, _c28));
  }
}
var _c29 = ["element"];
var _c30 = () => ["/my-account/notification-preference"];
function MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_div_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 21)(1, "cx-coupon-card", 22);
    \u0275\u0275listener("notificationChanged", function MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_div_12_Template_cx_coupon_card_notificationChanged_1_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.notificationChange($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const coupon_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275property("coupon", coupon_r4)("couponSubscriptionLoading$", ctx_r1.couponSubscriptionLoading$);
  }
}
function MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 7)(2, "label", 8)(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "cx-sorting", 9);
    \u0275\u0275pipe(7, "async");
    \u0275\u0275pipe(8, "cxTranslate");
    \u0275\u0275listener("sortListEvent", function MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_Template_cx_sorting_sortListEvent_6_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.sortChange($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 10)(10, "cx-pagination", 11);
    \u0275\u0275listener("viewPageEvent", function MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_Template_cx_pagination_viewPageEvent_10_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.pageChange($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(11, "div", 12);
    \u0275\u0275template(12, MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_div_12_Template, 2, 2, "div", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 14)(14, "label", 15)(15, "span");
    \u0275\u0275text(16);
    \u0275\u0275pipe(17, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "cx-sorting", 16);
    \u0275\u0275pipe(19, "cxTranslate");
    \u0275\u0275pipe(20, "async");
    \u0275\u0275pipe(21, "cxTranslate");
    \u0275\u0275listener("sortListEvent", function MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_Template_cx_sorting_sortListEvent_18_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.sortChange($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 17)(23, "cx-pagination", 11);
    \u0275\u0275listener("viewPageEvent", function MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_Template_cx_pagination_viewPageEvent_23_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.pageChange($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(24, "div", 18)(25, "span");
    \u0275\u0275element(26, "cx-icon", 19);
    \u0275\u0275text(27);
    \u0275\u0275pipe(28, "cxTranslate");
    \u0275\u0275elementStart(29, "a", 20);
    \u0275\u0275text(30);
    \u0275\u0275pipe(31, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275text(32);
    \u0275\u0275pipe(33, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const couponResult_r5 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 19, "myCoupons.sortBy"));
    \u0275\u0275advance(2);
    \u0275\u0275property("sortOptions", ctx_r1.sortOptions)("sortLabels", \u0275\u0275pipeBind1(7, 21, ctx_r1.sortLabels))("selectedOption", ctx_r1.sort)("ariaLabel", \u0275\u0275pipeBind1(8, 23, "myCoupons.sortCoupons"));
    \u0275\u0275advance(4);
    \u0275\u0275property("pagination", ctx_r1.pagination);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", couponResult_r5.coupons);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(17, 25, "myCoupons.sortBy"));
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate("placeholder", \u0275\u0275pipeBind1(19, 27, "myCoupons.sortBy"));
    \u0275\u0275property("sortOptions", ctx_r1.sortOptions)("sortLabels", \u0275\u0275pipeBind1(20, 29, ctx_r1.sortLabels))("selectedOption", ctx_r1.sort)("ariaLabel", \u0275\u0275pipeBind1(21, 31, "myCoupons.sortCoupons"));
    \u0275\u0275advance(5);
    \u0275\u0275property("pagination", ctx_r1.pagination);
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r1.iconTypes.INFO);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(28, 33, "myCoupons.notesPreffix"), "");
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(39, _c30));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(31, 35, "myCoupons.notesLink"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(33, 37, "myCoupons.notesSuffix"));
  }
}
function MyCouponsComponent_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 6)(2, "h2");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(5, MyCouponsComponent_ng_container_1_ng_container_3_ng_container_5_Template, 34, 40, "ng-container", 3);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const couponResult_r5 = ctx.ngIf;
    \u0275\u0275nextContext();
    const noCoupons_r6 = \u0275\u0275reference(6);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 3, "myCoupons.myCoupons"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", couponResult_r5.pagination && couponResult_r5.pagination.totalCount && couponResult_r5.pagination.totalCount > 0)("ngIfElse", noCoupons_r6);
  }
}
function MyCouponsComponent_ng_container_1_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "section")(1, "p", 23);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(3, 1, "myCoupons.noCouponsMessage"), " ");
  }
}
function MyCouponsComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 4);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275template(3, MyCouponsComponent_ng_container_1_ng_container_3_Template, 6, 5, "ng-container", 5);
    \u0275\u0275pipe(4, "async");
    \u0275\u0275template(5, MyCouponsComponent_ng_container_1_ng_template_5_Template, 4, 3, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 2, "common.loaded"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(4, 4, ctx_r1.couponResult$));
  }
}
function MyCouponsComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 24);
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
var _c31 = (a0) => ({
  cxRoute: "product",
  params: a0
});
var _c322 = (a0) => ({
  code: a0
});
var _c33 = (a0) => ({
  expirationDate: a0
});
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 42)(1, "a", 43);
    \u0275\u0275pipe(2, "cxUrl");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const product_r4 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(2, 2, \u0275\u0275pureFunction1(4, _c31, product_r4)));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", product_r4.name, " ");
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 44)(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const product_r4 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(3, 1, "myInterests.productId", \u0275\u0275pureFunction1(4, _c322, product_r4.code)));
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_ng_container_12_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 46)(1, "div", 47);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 48);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const variant_r5 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", variant_r5.name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", variant_r5.value, " ");
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_ng_container_12_div_1_Template, 5, 2, "div", 45);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const baseOptions_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", baseOptions_r6.selected == null ? null : baseOptions_r6.selected.variantOptionQualifiers);
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 46)(1, "div", 49);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(3, 1, "myInterests.outOfStock"), " ");
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 50)(1, "span", 51);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "span", 52);
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "cxDate");
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const interestEntry_r7 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(3, 2, "myInterests." + interestEntry_r7.interestType), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(7, 6, "myInterests.expirationDate", \u0275\u0275pureFunction1(9, _c33, \u0275\u0275pipeBind1(6, 4, interestEntry_r7.expirationDate))), " ");
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "td", 25)(2, "div", 26)(3, "div", 27)(4, "a", 28);
    \u0275\u0275pipe(5, "cxUrl");
    \u0275\u0275element(6, "cx-media", 29);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 30)(8, "div", 31)(9, "div");
    \u0275\u0275template(10, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_10_Template, 4, 6, "div", 32)(11, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_11_Template, 4, 6, "div", 33)(12, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_ng_container_12_Template, 2, 1, "ng-container", 34)(13, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_13_Template, 4, 3, "div", 35);
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275elementStart(14, "td", 25)(15, "div", 36)(16, "div", 37);
    \u0275\u0275text(17);
    \u0275\u0275pipe(18, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "span");
    \u0275\u0275text(20);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(21, "td", 25)(22, "div", 38)(23, "div", 37);
    \u0275\u0275text(24);
    \u0275\u0275pipe(25, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(26, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_div_26_Template, 8, 11, "div", 39);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(27, "td", 25)(28, "div", 40)(29, "button", 41);
    \u0275\u0275pipe(30, "cxTranslate");
    \u0275\u0275pipe(31, "async");
    \u0275\u0275listener("click", function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_Template_button_click_29_listener() {
      \u0275\u0275restoreView(_r3);
      const interest_r8 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.removeInterest(interest_r8));
    });
    \u0275\u0275text(32);
    \u0275\u0275pipe(33, "cxTranslate");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const product_r4 = ctx.ngIf;
    const interest_r8 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(4);
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(5, 13, \u0275\u0275pureFunction1(25, _c31, product_r4)));
    \u0275\u0275advance(2);
    \u0275\u0275property("container", product_r4.images == null ? null : product_r4.images.PRIMARY);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", product_r4.name);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", product_r4.code);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", product_r4.baseOptions);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (product_r4.stock == null ? null : product_r4.stock.stockLevelStatus) === "outOfStock");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(18, 15, "myInterests.price"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(product_r4.price == null ? null : product_r4.price.formattedValue);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(25, 17, "myInterests.notifications"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", interest_r8.productInterestEntry);
    \u0275\u0275advance(3);
    \u0275\u0275property("cxAtMessage", \u0275\u0275pipeBind1(30, 19, "myInterests.itemRemoved"))("disabled", \u0275\u0275pipeBind1(31, 21, ctx_r1.isRemoveDisabled$));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(33, 23, "myInterests.remove"), " ");
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 23);
    \u0275\u0275template(1, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_ng_container_1_Template, 34, 27, "ng-container", 24);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const interest_r8 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(2, 1, interest_r8.product$));
  }
}
function MyInterestsComponent_div_0_div_5_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 9)(2, "label", 10)(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "cx-sorting", 11);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275pipe(8, "async");
    \u0275\u0275pipe(9, "cxTranslate");
    \u0275\u0275listener("sortListEvent", function MyInterestsComponent_div_0_div_5_ng_container_3_Template_cx_sorting_sortListEvent_6_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.sortChange($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "div", 12)(11, "cx-pagination", 13);
    \u0275\u0275listener("viewPageEvent", function MyInterestsComponent_div_0_div_5_ng_container_3_Template_cx_pagination_viewPageEvent_11_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.pageChange($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(12, "table", 14)(13, "caption", 15);
    \u0275\u0275text(14);
    \u0275\u0275pipe(15, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "thead", 16)(17, "th", 17);
    \u0275\u0275text(18);
    \u0275\u0275pipe(19, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "th", 17);
    \u0275\u0275text(21);
    \u0275\u0275pipe(22, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "th", 17);
    \u0275\u0275text(24);
    \u0275\u0275pipe(25, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "th", 18);
    \u0275\u0275text(27);
    \u0275\u0275pipe(28, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(29, "tbody");
    \u0275\u0275template(30, MyInterestsComponent_div_0_div_5_ng_container_3_tr_30_Template, 3, 3, "tr", 19);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(31, "div", 20)(32, "label", 21)(33, "span");
    \u0275\u0275text(34);
    \u0275\u0275pipe(35, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "cx-sorting", 11);
    \u0275\u0275pipe(37, "cxTranslate");
    \u0275\u0275pipe(38, "async");
    \u0275\u0275pipe(39, "cxTranslate");
    \u0275\u0275listener("sortListEvent", function MyInterestsComponent_div_0_div_5_ng_container_3_Template_cx_sorting_sortListEvent_36_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.sortChange($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(40, "div", 22)(41, "cx-pagination", 13);
    \u0275\u0275listener("viewPageEvent", function MyInterestsComponent_div_0_div_5_ng_container_3_Template_cx_pagination_viewPageEvent_41_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.pageChange($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const interests_r9 = \u0275\u0275nextContext(2).ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 20, "myInterests.sortBy"));
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate("placeholder", \u0275\u0275pipeBind1(7, 22, "myInterests.sortBy"));
    \u0275\u0275property("sortOptions", ctx_r1.sortOptions)("sortLabels", \u0275\u0275pipeBind1(8, 24, ctx_r1.sortLabels))("selectedOption", ctx_r1.sort)("ariaLabel", \u0275\u0275pipeBind1(9, 26, "myInterests.sortInterests"));
    \u0275\u0275advance(5);
    \u0275\u0275property("pagination", ctx_r1.pagination);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(15, 28, "myInterests.caption"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(19, 30, "myInterests.item"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(22, 32, "myInterests.price"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(25, 34, "myInterests.notifications"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(28, 36, "myInterests.actions"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", interests_r9.results);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(35, 38, "myInterests.sortBy"));
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate("placeholder", \u0275\u0275pipeBind1(37, 40, "myInterests.sortBy"));
    \u0275\u0275property("sortOptions", ctx_r1.sortOptions)("sortLabels", \u0275\u0275pipeBind1(38, 42, ctx_r1.sortLabels))("selectedOption", ctx_r1.sort)("ariaLabel", \u0275\u0275pipeBind1(39, 44, "myInterests.sortInterests"));
    \u0275\u0275advance(5);
    \u0275\u0275property("pagination", ctx_r1.pagination);
  }
}
function MyInterestsComponent_div_0_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275element(1, "div", 7);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275template(3, MyInterestsComponent_div_0_div_5_ng_container_3_Template, 42, 46, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const interests_r9 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275nextContext();
    const noInterest_r10 = \u0275\u0275reference(3);
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 3, "common.loaded"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", interests_r9.pagination && interests_r9.pagination.totalCount && interests_r9.pagination.totalCount > 0)("ngIfElse", noInterest_r10);
  }
}
function MyInterestsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3)(1, "div", 4)(2, "h2");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(5, MyInterestsComponent_div_0_div_5_Template, 4, 5, "div", 5);
    \u0275\u0275pipe(6, "async");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const loading_r11 = \u0275\u0275reference(5);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 3, "myInterests.header"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !\u0275\u0275pipeBind1(6, 5, ctx_r1.getInterestsloading$))("ngIfElse", loading_r11);
  }
}
function MyInterestsComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 53);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "myInterests.noInterests"), " ");
  }
}
function MyInterestsComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 54);
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
function NotificationPreferenceComponent_ng_container_0_div_1_ng_container_9_label_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 11)(1, "input", 12);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275listener("change", function NotificationPreferenceComponent_ng_container_0_div_1_ng_container_9_label_1_Template_input_change_1_listener() {
      \u0275\u0275restoreView(_r1);
      const preference_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.updatePreference(preference_r2));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 13);
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const preference_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("checked", preference_r2.enabled)("disabled", \u0275\u0275pipeBind1(2, 4, ctx_r2.isLoading$));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate2(" ", \u0275\u0275pipeBind1(5, 6, "notificationPreference." + preference_r2.channel), " ", preference_r2.value, " ");
  }
}
function NotificationPreferenceComponent_ng_container_0_div_1_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NotificationPreferenceComponent_ng_container_0_div_1_ng_container_9_label_1_Template, 6, 8, "label", 10);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const preference_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", preference_r2.visible);
  }
}
function NotificationPreferenceComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "div", 3);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementStart(3, "div", 4)(4, "div", 5)(5, "div", 6);
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 7);
    \u0275\u0275template(9, NotificationPreferenceComponent_ng_container_0_div_1_ng_container_9_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "label", 9)(11, "strong");
    \u0275\u0275text(12);
    \u0275\u0275pipe(13, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275text(14);
    \u0275\u0275pipe(15, "cxTranslate");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const preferences_r4 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 5, "common.loaded"));
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 7, "notificationPreference.message"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", preferences_r4);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(13, 9, "notificationPreference.note"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(15, 11, "notificationPreference.noteMessage"), " ");
  }
}
function NotificationPreferenceComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14);
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
function NotificationPreferenceComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NotificationPreferenceComponent_ng_container_0_div_1_Template, 16, 13, "div", 2)(2, NotificationPreferenceComponent_ng_container_0_ng_template_2_Template, 2, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const preferences_r4 = ctx.ngIf;
    const loading_r5 = \u0275\u0275reference(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", preferences_r4.length > 0)("ngIfElse", loading_r5);
  }
}
function PaymentMethodsComponent_ng_container_0_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
function PaymentMethodsComponent_ng_container_0_ng_template_12_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 10)(1, "div", 11)(2, "cx-card", 12);
    \u0275\u0275pipe(3, "async");
    \u0275\u0275listener("deleteCard", function PaymentMethodsComponent_ng_container_0_ng_template_12_div_3_Template_cx_card_deleteCard_2_listener() {
      const paymentMethod_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.deletePaymentMethod(paymentMethod_r2));
    })("setDefaultCard", function PaymentMethodsComponent_ng_container_0_ng_template_12_div_3_Template_cx_card_setDefaultCard_2_listener() {
      const paymentMethod_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.setDefaultPaymentMethod(paymentMethod_r2));
    })("editCard", function PaymentMethodsComponent_ng_container_0_ng_template_12_div_3_Template_cx_card_editCard_2_listener() {
      const paymentMethod_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.setEdit(paymentMethod_r2));
    })("cancelCard", function PaymentMethodsComponent_ng_container_0_ng_template_12_div_3_Template_cx_card_cancelCard_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.cancelCard());
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const paymentMethod_r2 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275property("index", i_r4)("border", true)("fitToContainer", true)("content", \u0275\u0275pipeBind1(3, 5, ctx_r2.getCardContent(paymentMethod_r2)))("editMode", ctx_r2.editCard === paymentMethod_r2.id);
  }
}
function PaymentMethodsComponent_ng_container_0_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 7);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275elementStart(2, "div", 8);
    \u0275\u0275template(3, PaymentMethodsComponent_ng_container_0_ng_template_12_div_3_Template, 4, 7, "div", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const paymentMethods_r5 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 2, "common.loaded"));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", paymentMethods_r5);
  }
}
function PaymentMethodsComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 2)(2, "div", 3)(3, "h2");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 4)(7, "div", 5);
    \u0275\u0275text(8);
    \u0275\u0275pipe(9, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(10, PaymentMethodsComponent_ng_container_0_div_10_Template, 2, 0, "div", 6);
    \u0275\u0275pipe(11, "async");
    \u0275\u0275template(12, PaymentMethodsComponent_ng_container_0_ng_template_12_Template, 4, 4, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cards_r6 = \u0275\u0275reference(13);
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 4, "paymentMethods.paymentMethods"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(9, 6, "paymentMethods.newPaymentMethodsAreAddedDuringCheckout"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(11, 8, ctx_r2.loading$))("ngIfElse", cards_r6);
  }
}
var _c34 = (a0) => ({
  nav: a0
});
function BreadcrumbComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li");
    \u0275\u0275element(1, "a", 3);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const crumb_r1 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", crumb_r1.link)("innerHTML", crumb_r1.label, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind2(2, 3, "navigation.navigateTo", \u0275\u0275pureFunction1(6, _c34, crumb_r1.label)));
  }
}
var _c35 = (a0) => ({
  node: a0,
  depth: 0
});
var _c36 = (a0, a1) => ({
  node: a0,
  depth: a1
});
function NavigationUIComponent_li_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 5)(1, "button", 6);
    \u0275\u0275listener("click", function NavigationUIComponent_li_2_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.back());
    });
    \u0275\u0275element(2, "cx-icon", 7);
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r1.iconType.CARET_LEFT);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 2, "common.back"), " ");
  }
}
function NavigationUIComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NavigationUIComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NavigationUIComponent_ng_container_3_ng_container_1_Template, 1, 0, "ng-container", 8);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const child_r3 = ctx.$implicit;
    \u0275\u0275nextContext();
    const nav_r4 = \u0275\u0275reference(5);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", nav_r4)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c35, child_r3));
  }
}
function NavigationUIComponent_ng_template_4_cx_generic_link_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "cx-generic-link", 11);
    \u0275\u0275listener("click", function NavigationUIComponent_ng_template_4_cx_generic_link_1_Template_cx_generic_link_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const node_r6 = \u0275\u0275nextContext().node;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closeIfClickedTheSameLink(node_r6));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const node_r6 = \u0275\u0275nextContext().node;
    \u0275\u0275styleMap(node_r6.styleAttributes);
    \u0275\u0275classMap(node_r6.styleClasses);
    \u0275\u0275property("url", node_r6.url)("target", node_r6.target);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r6.title, " ");
  }
}
function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_cx_generic_link_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "cx-generic-link", 11);
    \u0275\u0275listener("click", function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_cx_generic_link_1_Template_cx_generic_link_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const node_r6 = \u0275\u0275nextContext(3).node;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closeIfClickedTheSameLink(node_r6));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const node_r6 = \u0275\u0275nextContext(3).node;
    \u0275\u0275property("url", node_r6.url)("target", node_r6.target);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r6.title, " ");
  }
}
function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const node_r6 = \u0275\u0275nextContext(3).node;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r6.title, " ");
  }
}
function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_cx_generic_link_1_Template, 2, 3, "cx-generic-link", 13);
    \u0275\u0275elementStart(2, "button", 14);
    \u0275\u0275listener("click", function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_Template_button_click_2_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.toggleOpen($event));
    })("mouseenter", function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_Template_button_mouseenter_2_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onMouseEnter($event));
    })("keydown.space", function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_Template_button_keydown_space_2_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.toggleOpen($event));
    })("keydown.esc", function NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_Template_button_keydown_esc_2_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.back());
    });
    \u0275\u0275template(3, NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 15);
    \u0275\u0275element(4, "cx-icon", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    const node_r6 = ctx_r8.node;
    const depth_r10 = ctx_r8.depth;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", node_r6.url);
    \u0275\u0275advance();
    \u0275\u0275attribute("tabindex", depth_r10 < 1 ? 0 : -1)("aria-haspopup", true)("aria-expanded", false)("aria-label", node_r6.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !node_r6.url);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.iconType.CARET_DOWN);
  }
}
function NavigationUIComponent_ng_template_4_ng_template_2_ng_template_1_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const node_r6 = \u0275\u0275nextContext(3).node;
    \u0275\u0275attribute("tabindex", -1);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r6.title, " ");
  }
}
function NavigationUIComponent_ng_template_4_ng_template_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NavigationUIComponent_ng_template_4_ng_template_2_ng_template_1_span_0_Template, 2, 2, "span", 15);
  }
  if (rf & 2) {
    const node_r6 = \u0275\u0275nextContext(2).node;
    \u0275\u0275property("ngIf", node_r6.title);
  }
}
function NavigationUIComponent_ng_template_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NavigationUIComponent_ng_template_4_ng_template_2_ng_container_0_Template, 5, 7, "ng-container", 12)(1, NavigationUIComponent_ng_template_4_ng_template_2_ng_template_1_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const title_r11 = \u0275\u0275reference(2);
    const node_r6 = \u0275\u0275nextContext().node;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r1.flyout && (node_r6.children == null ? null : node_r6.children.length) > 0)("ngIfElse", title_r11);
  }
}
function NavigationUIComponent_ng_template_4_div_4_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NavigationUIComponent_ng_template_4_div_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NavigationUIComponent_ng_template_4_div_4_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 8);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const child_r12 = ctx.$implicit;
    const depth_r10 = \u0275\u0275nextContext(2).depth;
    \u0275\u0275nextContext();
    const nav_r4 = \u0275\u0275reference(5);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", nav_r4)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c36, child_r12, depth_r10 + 1));
  }
}
function NavigationUIComponent_ng_template_4_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16)(1, "ul", 17);
    \u0275\u0275template(2, NavigationUIComponent_ng_template_4_div_4_ng_container_2_Template, 2, 5, "ng-container", 4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const node_r6 = \u0275\u0275nextContext().node;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("depth", ctx_r1.getTotalDepth(node_r6))("wrap-after", node_r6.children.length > ctx_r1.wrapAfter ? ctx_r1.wrapAfter : null)("columns", ctx_r1.getColumnCount(node_r6.children.length));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", node_r6.children);
  }
}
function NavigationUIComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li");
    \u0275\u0275template(1, NavigationUIComponent_ng_template_4_cx_generic_link_1_Template, 2, 7, "cx-generic-link", 9)(2, NavigationUIComponent_ng_template_4_ng_template_2_Template, 3, 2, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(4, NavigationUIComponent_ng_template_4_div_4_Template, 3, 4, "div", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const node_r6 = ctx.node;
    const heading_r13 = \u0275\u0275reference(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", node_r6.url && (!node_r6.children || (node_r6.children == null ? null : node_r6.children.length) === 0))("ngIfElse", heading_r13);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", node_r6.children && node_r6.children.length > 0);
  }
}
function CategoryNavigationComponent_cx_navigation_ui_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-navigation-ui", 1);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275pipe(2, "cxTranslate");
  }
  if (rf & 2) {
    let tmp_3_0;
    let tmp_4_0;
    const data_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("node", \u0275\u0275pipeBind1(1, 5, ctx_r1.node$))("ngClass", (tmp_3_0 = data_r1.styleClass) !== null && tmp_3_0 !== void 0 ? tmp_3_0 : "")("wrapAfter", +((tmp_4_0 = data_r1.wrapAfter) !== null && tmp_4_0 !== void 0 ? tmp_4_0 : ""))("resetMenuOnClose", data_r1.resetMenuOnClose)("navAriaLabel", \u0275\u0275pipeBind1(2, 7, "navigation.categoryNavLabel"));
  }
}
function FooterNavigationComponent_cx_navigation_ui_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-navigation-ui", 1);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275pipe(2, "cxTranslate");
  }
  if (rf & 2) {
    let tmp_4_0;
    const node_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("node", node_r1)("flyout", false)("ngClass", (tmp_4_0 = \u0275\u0275pipeBind1(1, 4, ctx_r1.styleClass$)) !== null && tmp_4_0 !== void 0 ? tmp_4_0 : "")("navAriaLabel", \u0275\u0275pipeBind1(2, 6, "navigation.footerNavLabel"));
  }
}
var _c37 = (a0) => ({
  query: a0
});
var _c38 = (a0) => ({
  cxRoute: "search",
  params: a0
});
function SearchBoxComponent_div_15_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 16);
  }
  if (rf & 2) {
    const result_r5 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275property("innerHTML", result_r5.message, \u0275\u0275sanitizeHtml);
  }
}
function SearchBoxComponent_div_15_li_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li")(1, "a", 17);
    \u0275\u0275pipe(2, "cxHighlight");
    \u0275\u0275pipe(3, "cxUrl");
    \u0275\u0275listener("keydown.arrowup", function SearchBoxComponent_div_15_li_4_Template_a_keydown_arrowup_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.focusPreviousChild($event));
    })("keydown.arrowdown", function SearchBoxComponent_div_15_li_4_Template_a_keydown_arrowdown_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.focusNextChild($event));
    })("keydown.enter", function SearchBoxComponent_div_15_li_4_Template_a_keydown_enter_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.close($event, true));
    })("keydown.escape", function SearchBoxComponent_div_15_li_4_Template_a_keydown_escape_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.close($event, true));
    })("blur", function SearchBoxComponent_div_15_li_4_Template_a_blur_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.close($event));
    })("mousedown", function SearchBoxComponent_div_15_li_4_Template_a_mousedown_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.preventDefault($event));
    })("click", function SearchBoxComponent_div_15_li_4_Template_a_click_1_listener() {
      let tmp_6_0;
      const suggestion_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const result_r5 = \u0275\u0275nextContext().ngIf;
      const ctx_r3 = \u0275\u0275nextContext();
      const searchInput_r2 = \u0275\u0275reference(4);
      ctx_r3.dispatchSuggestionEvent({
        freeText: searchInput_r2.value,
        selectedSuggestion: suggestion_r7,
        searchSuggestions: (tmp_6_0 = result_r5.suggestions) !== null && tmp_6_0 !== void 0 ? tmp_6_0 : []
      });
      return \u0275\u0275resetView(ctx_r3.updateChosenWord(suggestion_r7));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const suggestion_r7 = ctx.$implicit;
    \u0275\u0275nextContext(2);
    const searchInput_r2 = \u0275\u0275reference(4);
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind2(2, 2, suggestion_r7, searchInput_r2.value), \u0275\u0275sanitizeHtml)("routerLink", \u0275\u0275pipeBind1(3, 5, \u0275\u0275pureFunction1(9, _c38, \u0275\u0275pureFunction1(7, _c37, suggestion_r7))));
  }
}
function SearchBoxComponent_div_15_ul_5_li_2_cx_media_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-media", 23);
  }
  if (rf & 2) {
    const product_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("container", product_r9.images == null ? null : product_r9.images.PRIMARY);
  }
}
function SearchBoxComponent_div_15_ul_5_li_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li")(1, "a", 19);
    \u0275\u0275pipe(2, "cxUrl");
    \u0275\u0275listener("keydown.arrowup", function SearchBoxComponent_div_15_ul_5_li_2_Template_a_keydown_arrowup_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.focusPreviousChild($event));
    })("keydown.arrowdown", function SearchBoxComponent_div_15_ul_5_li_2_Template_a_keydown_arrowdown_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.focusNextChild($event));
    })("keydown.enter", function SearchBoxComponent_div_15_ul_5_li_2_Template_a_keydown_enter_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.close($event, true));
    })("keydown.escape", function SearchBoxComponent_div_15_ul_5_li_2_Template_a_keydown_escape_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.close($event, true));
    })("blur", function SearchBoxComponent_div_15_ul_5_li_2_Template_a_blur_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.close($event));
    })("mousedown", function SearchBoxComponent_div_15_ul_5_li_2_Template_a_mousedown_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.preventDefault($event));
    })("click", function SearchBoxComponent_div_15_ul_5_li_2_Template_a_click_1_listener() {
      const product_r9 = \u0275\u0275restoreView(_r8).$implicit;
      const ctx_r3 = \u0275\u0275nextContext(3);
      const searchInput_r2 = \u0275\u0275reference(4);
      return \u0275\u0275resetView(ctx_r3.dispatchProductEvent({
        freeText: searchInput_r2.value,
        productCode: product_r9.code
      }));
    });
    \u0275\u0275template(3, SearchBoxComponent_div_15_ul_5_li_2_cx_media_3_Template, 1, 1, "cx-media", 20);
    \u0275\u0275element(4, "div", 21);
    \u0275\u0275elementStart(5, "span", 22);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const product_r9 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275classProp("has-media", ctx_r3.config.displayProductImages);
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(2, 6, \u0275\u0275pureFunction1(8, _c31, product_r9)));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r3.config.displayProductImages);
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", product_r9.nameHtml, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(product_r9.price == null ? null : product_r9.price.formattedValue);
  }
}
function SearchBoxComponent_div_15_ul_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 18);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275template(2, SearchBoxComponent_div_15_ul_5_li_2_Template, 7, 10, "li", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const result_r5 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 2, "searchBox.ariaLabelProducts"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", result_r5.products);
  }
}
function SearchBoxComponent_div_15_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 24);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const result_r5 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate3(" ", \u0275\u0275pipeBind2(2, 3, "searchBox.suggestionsResult", \u0275\u0275pureFunction1(11, _c20, result_r5.suggestions == null ? null : result_r5.suggestions.length)), " ", \u0275\u0275pipeBind2(3, 6, "searchBox.productsResult", \u0275\u0275pureFunction1(13, _c20, result_r5.products == null ? null : result_r5.products.length)), " ", \u0275\u0275pipeBind1(4, 9, "searchBox.initialDescription"), " ");
  }
}
function SearchBoxComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275listener("click", function SearchBoxComponent_div_15_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.close($event, true));
    });
    \u0275\u0275template(1, SearchBoxComponent_div_15_div_1_Template, 1, 1, "div", 10);
    \u0275\u0275elementStart(2, "ul", 11);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275template(4, SearchBoxComponent_div_15_li_4_Template, 4, 11, "li", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, SearchBoxComponent_div_15_ul_5_Template, 3, 4, "ul", 13);
    \u0275\u0275elementStart(6, "span", 14);
    \u0275\u0275text(7);
    \u0275\u0275pipe(8, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(9, SearchBoxComponent_div_15_div_9_Template, 5, 15, "div", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const result_r5 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", result_r5.message);
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(3, 6, "searchBox.ariaLabelSuggestions"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", result_r5.suggestions);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", result_r5.products);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(8, 8, "searchBox.initialDescription"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", (result_r5.suggestions == null ? null : result_r5.suggestions.length) || (result_r5.products == null ? null : result_r5.products.length));
  }
}
function MyAccountV2NavigationComponent_cx_navigation_ui_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-navigation-ui", 1);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275pipe(2, "async");
  }
  if (rf & 2) {
    let tmp_4_0;
    const node_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("node", node_r1)("flyout", false)("ngClass", (tmp_4_0 = \u0275\u0275pipeBind1(1, 4, ctx_r1.styleClass$)) !== null && tmp_4_0 !== void 0 ? tmp_4_0 : "")("navAriaLabel", \u0275\u0275pipeBind1(2, 6, ctx_r1.name$));
  }
}
function ProductViewComponent_cx_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-icon", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("type", ctx_r0.iconTypes.GRID);
  }
}
function ProductViewComponent_cx_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-icon", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("type", ctx_r0.iconTypes.LIST);
  }
}
var _c39 = (a0) => ({
  product: a0
});
function ProductListItemComponent_ng_template_10_cx_star_rating_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-star-rating", 14);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("rating", ctx_r0.product == null ? null : ctx_r0.product.averageRating);
  }
}
function ProductListItemComponent_ng_template_10_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productDetails.noReviews"), " ");
  }
}
function ProductListItemComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ProductListItemComponent_ng_template_10_cx_star_rating_0_Template, 1, 1, "cx-star-rating", 11)(1, ProductListItemComponent_ng_template_10_div_1_Template, 3, 3, "div", 12);
    \u0275\u0275elementStart(2, "div", 13);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r0.product.averageRating);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.product.averageRating);
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(3, 4, "productDetails.productPrice"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r0.product.price == null ? null : ctx_r0.product.price.formattedValue, " ");
  }
}
function ProductListItemComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 16);
  }
}
function ProductGridItemComponent_ng_template_5_cx_star_rating_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-star-rating", 9);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("rating", ctx_r0.product == null ? null : ctx_r0.product.averageRating);
  }
}
function ProductGridItemComponent_ng_template_5_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productDetails.noReviews"), " ");
  }
}
function ProductGridItemComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275template(1, ProductGridItemComponent_ng_template_5_cx_star_rating_1_Template, 1, 1, "cx-star-rating", 5)(2, ProductGridItemComponent_ng_template_5_div_2_Template, 3, 3, "div", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 7)(4, "div", 8);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.product.averageRating);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.product.averageRating);
    \u0275\u0275advance(2);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(5, 4, "productDetails.productPrice"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r0.product.price == null ? null : ctx_r0.product.price.formattedValue, " ");
  }
}
function ProductGridItemComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 10);
  }
}
function ProductScrollComponent_ng_container_0_cx_product_grid_item_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-product-grid-item", 8);
  }
  if (rf & 2) {
    const product_r3 = ctx.$implicit;
    \u0275\u0275property("product", product_r3);
  }
}
function ProductScrollComponent_ng_container_0_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275listener("click", function ProductScrollComponent_ng_container_0_div_5_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.scrollToTop());
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productList.backToTopBtn"), " ");
  }
}
function ProductScrollComponent_ng_container_0_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275listener("click", function ProductScrollComponent_ng_container_0_div_6_Template_div_click_0_listener() {
      let tmp_3_0;
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.loadNextPage(((tmp_3_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_3_0 !== void 0 ? tmp_3_0 : 0) + 1));
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productList.showMoreBtn"), " ");
  }
}
function ProductScrollComponent_ng_container_0_div_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
function ProductScrollComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 1);
    \u0275\u0275listener("scrolled", function ProductScrollComponent_ng_container_0_Template_div_scrolled_1_listener() {
      let tmp_2_0;
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.scrollPage(((tmp_2_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_2_0 !== void 0 ? tmp_2_0 : 0) + 1));
    });
    \u0275\u0275elementStart(2, "div", 2);
    \u0275\u0275template(3, ProductScrollComponent_ng_container_0_cx_product_grid_item_3_Template, 1, 1, "cx-product-grid-item", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 4);
    \u0275\u0275template(5, ProductScrollComponent_ng_container_0_div_5_Template, 3, 3, "div", 5)(6, ProductScrollComponent_ng_container_0_div_6_Template, 3, 3, "div", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275template(7, ProductScrollComponent_ng_container_0_div_7_Template, 2, 0, "div", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_6_0;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("infiniteScrollDistance", 5)("infiniteScrollThrottle", 50)("infiniteScrollDisabled", ctx_r1.isMaxProducts || ctx_r1.isLastPage || ctx_r1.isEmpty);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.model == null ? null : ctx_r1.model.products);
    \u0275\u0275advance();
    \u0275\u0275property("className", !ctx_r1.isLastPage && ((tmp_5_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_5_0 !== void 0 ? tmp_5_0 : 0) > 0 ? "cx-double-btn-container grid-btn-padding" : "cx-single-btn-container grid-btn-padding");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (ctx_r1.isMaxProducts || ctx_r1.isLastPage) && ((tmp_6_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_6_0 !== void 0 ? tmp_6_0 : 0) > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isMaxProducts && !ctx_r1.isLastPage);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.appendProducts);
  }
}
function ProductScrollComponent_ng_container_1_cx_product_list_item_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-product-list-item", 13);
  }
  if (rf & 2) {
    const product_r7 = ctx.$implicit;
    \u0275\u0275property("product", product_r7);
  }
}
function ProductScrollComponent_ng_container_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275listener("click", function ProductScrollComponent_ng_container_1_div_4_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.scrollToTop());
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productList.backToTopBtn"), " ");
  }
}
function ProductScrollComponent_ng_container_1_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275listener("click", function ProductScrollComponent_ng_container_1_div_5_Template_div_click_0_listener() {
      let tmp_3_0;
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.loadNextPage(((tmp_3_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_3_0 !== void 0 ? tmp_3_0 : 0) + 1));
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productList.showMoreBtn"), " ");
  }
}
function ProductScrollComponent_ng_container_1_div_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275element(1, "cx-spinner");
    \u0275\u0275elementEnd();
  }
}
function ProductScrollComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 1);
    \u0275\u0275listener("scrolled", function ProductScrollComponent_ng_container_1_Template_div_scrolled_1_listener() {
      let tmp_2_0;
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.scrollPage(((tmp_2_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_2_0 !== void 0 ? tmp_2_0 : 0) + 1));
    });
    \u0275\u0275template(2, ProductScrollComponent_ng_container_1_cx_product_list_item_2_Template, 1, 1, "cx-product-list-item", 12);
    \u0275\u0275elementStart(3, "div", 4);
    \u0275\u0275template(4, ProductScrollComponent_ng_container_1_div_4_Template, 3, 3, "div", 5)(5, ProductScrollComponent_ng_container_1_div_5_Template, 3, 3, "div", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, ProductScrollComponent_ng_container_1_div_6_Template, 2, 0, "div", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_6_0;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("infiniteScrollDistance", 3)("infiniteScrollThrottle", 50)("infiniteScrollDisabled", ctx_r1.isMaxProducts || ctx_r1.isLastPage || ctx_r1.isEmpty);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.model == null ? null : ctx_r1.model.products);
    \u0275\u0275advance();
    \u0275\u0275property("className", !ctx_r1.isLastPage && ((tmp_5_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_5_0 !== void 0 ? tmp_5_0 : 0) > 0 ? "cx-double-btn-container" : "cx-single-btn-container");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (ctx_r1.isMaxProducts || ctx_r1.isLastPage) && ((tmp_6_0 = ctx_r1.model == null ? null : ctx_r1.model.pagination == null ? null : ctx_r1.model.pagination.currentPage) !== null && tmp_6_0 !== void 0 ? tmp_6_0 : 0) > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isMaxProducts && !ctx_r1.isLastPage);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.appendProducts);
  }
}
function ProductListComponent_div_0_div_5_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17)(1, "div", 18);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275element(3, "cx-pagination", 19);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const model_r3 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 3, "productList.productSearchPagination"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pagination", model_r3.pagination)("defaultPage", 0);
  }
}
function ProductListComponent_div_0_div_5_ng_container_14_ng_container_1_cx_product_grid_item_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-product-grid-item", 22);
  }
  if (rf & 2) {
    const product_r4 = ctx.$implicit;
    \u0275\u0275property("product", product_r4);
  }
}
function ProductListComponent_div_0_div_5_ng_container_14_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 5);
    \u0275\u0275template(2, ProductListComponent_div_0_div_5_ng_container_14_ng_container_1_cx_product_grid_item_2_Template, 1, 1, "cx-product-grid-item", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const model_r3 = \u0275\u0275nextContext(3).ngIf;
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", model_r3 == null ? null : model_r3.products);
  }
}
function ProductListComponent_div_0_div_5_ng_container_14_ng_container_2_cx_product_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-product-list-item", 24);
  }
  if (rf & 2) {
    const product_r5 = ctx.$implicit;
    \u0275\u0275property("product", product_r5);
  }
}
function ProductListComponent_div_0_div_5_ng_container_14_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductListComponent_div_0_div_5_ng_container_14_ng_container_2_cx_product_list_item_1_Template, 1, 1, "cx-product-list-item", 23);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const model_r3 = \u0275\u0275nextContext(3).ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", model_r3 == null ? null : model_r3.products);
  }
}
function ProductListComponent_div_0_div_5_ng_container_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductListComponent_div_0_div_5_ng_container_14_ng_container_1_Template, 3, 1, "ng-container", 20)(2, ProductListComponent_div_0_div_5_ng_container_14_ng_container_2_Template, 2, 1, "ng-container", 20);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const viewMode_r6 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", viewMode_r6 === ctx_r1.ViewModes.Grid);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", viewMode_r6 === ctx_r1.ViewModes.List);
  }
}
function ProductListComponent_div_0_div_5_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-product-scroll", 25);
  }
  if (rf & 2) {
    const viewMode_r6 = \u0275\u0275nextContext().ngIf;
    const model_r3 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("scrollConfig", ctx_r1.scrollConfig)("model", model_r3)("inputViewMode", viewMode_r6);
  }
}
function ProductListComponent_div_0_div_5_div_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275elementStart(2, "div", 18);
    \u0275\u0275element(3, "cx-pagination", 19);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const model_r3 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 3, "productList.productSearchPagination"));
    \u0275\u0275advance(3);
    \u0275\u0275property("pagination", model_r3.pagination)("defaultPage", 0);
  }
}
function ProductListComponent_div_0_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7)(1, "div", 8)(2, "div", 5)(3, "label", 9)(4, "span");
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "cx-sorting", 10);
    \u0275\u0275pipe(8, "cxTranslate");
    \u0275\u0275pipe(9, "cxTranslate");
    \u0275\u0275listener("sortListEvent", function ProductListComponent_div_0_div_5_Template_cx_sorting_sortListEvent_7_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.sortList($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(10, ProductListComponent_div_0_div_5_div_10_Template, 4, 5, "div", 11);
    \u0275\u0275elementStart(11, "div", 12)(12, "cx-product-view", 13);
    \u0275\u0275listener("modeChange", function ProductListComponent_div_0_div_5_Template_cx_product_view_modeChange_12_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.setViewMode($event));
    });
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(13, "div", 14);
    \u0275\u0275template(14, ProductListComponent_div_0_div_5_ng_container_14_Template, 3, 2, "ng-container", 15)(15, ProductListComponent_div_0_div_5_ng_template_15_Template, 1, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "div", 16)(18, "div", 5)(19, "label", 9)(20, "span");
    \u0275\u0275text(21);
    \u0275\u0275pipe(22, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "cx-sorting", 10);
    \u0275\u0275pipe(24, "cxTranslate");
    \u0275\u0275pipe(25, "cxTranslate");
    \u0275\u0275listener("sortListEvent", function ProductListComponent_div_0_div_5_Template_cx_sorting_sortListEvent_23_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.sortList($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(26, ProductListComponent_div_0_div_5_div_26_Template, 4, 5, "div", 11);
    \u0275\u0275elementStart(27, "div", 12)(28, "cx-product-view", 13);
    \u0275\u0275listener("modeChange", function ProductListComponent_div_0_div_5_Template_cx_product_view_modeChange_28_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.setViewMode($event));
    });
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    const viewMode_r6 = ctx.ngIf;
    const infiniteScroll_r7 = \u0275\u0275reference(16);
    const model_r3 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(6, 16, "productList.sortBy"));
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate("placeholder", \u0275\u0275pipeBind1(8, 18, "productList.sortBy"));
    \u0275\u0275property("sortOptions", model_r3.sorts)("selectedOption", model_r3.pagination == null ? null : model_r3.pagination.sort)("ariaLabel", \u0275\u0275pipeBind1(9, 20, "productList.sortResults"));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", !ctx_r1.isInfiniteScroll);
    \u0275\u0275advance(2);
    \u0275\u0275property("mode", viewMode_r6);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r1.isInfiniteScroll)("ngIfElse", infiniteScroll_r7);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(22, 22, "productList.sortBy"));
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate("placeholder", \u0275\u0275pipeBind1(24, 24, "productList.sortBy"));
    \u0275\u0275property("sortOptions", model_r3.sorts)("selectedOption", model_r3.pagination == null ? null : model_r3.pagination.sort)("ariaLabel", \u0275\u0275pipeBind1(25, 26, "productList.sortResults"));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", !ctx_r1.isInfiniteScroll);
    \u0275\u0275advance(2);
    \u0275\u0275property("mode", viewMode_r6);
  }
}
function ProductListComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "section", 3);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementStart(3, "div", 4)(4, "div", 5);
    \u0275\u0275template(5, ProductListComponent_div_0_div_5_Template, 29, 28, "div", 6);
    \u0275\u0275pipe(6, "async");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 2, "productList.productListResults"));
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(6, 4, ctx_r1.viewMode$));
  }
}
var _c40 = (a0) => ({
  key: a0
});
var _c41 = (a0) => ({
  filter: a0
});
function ActiveFacetsComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productList.appliedFilter"), " ");
  }
}
function ActiveFacetsComponent_ng_container_0_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 4);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275listener("keydown.space", function ActiveFacetsComponent_ng_container_0_a_2_Template_a_keydown_space_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.removeFilterWithSpacebar($event));
    });
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "cx-icon", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const facet_r3 = ctx.$implicit;
    const facetList_r4 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("queryParams", ctx_r1.getLinkParams(facet_r3))("cxFocus", \u0275\u0275pureFunction1(8, _c40, ctx_r1.getFocusKey(facetList_r4, facet_r3)));
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind2(1, 5, "productList.activeFilter", \u0275\u0275pureFunction1(10, _c41, facet_r3.facetValueName)));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(facet_r3.facetValueName);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.closeIcon);
  }
}
function ActiveFacetsComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ActiveFacetsComponent_ng_container_0_div_1_Template, 3, 3, "div", 1)(2, ActiveFacetsComponent_ng_container_0_a_2_Template, 5, 12, "a", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const facetList_r4 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", facetList_r4.activeFacets && facetList_r4.activeFacets.length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", facetList_r4 == null ? null : facetList_r4.activeFacets);
  }
}
var _c422 = ["facetValue"];
var _c43 = (a0) => ({
  name: a0
});
var _c44 = (a0, a1) => ({
  name: a0,
  count: a1
});
var _c45 = () => ({
  key: "moreorless"
});
function FacetComponent_ng_container_0_a_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 9, 0);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275listener("keydown.space", function FacetComponent_ng_container_0_a_7_Template_a_keydown_space_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.openLink($event));
    });
    \u0275\u0275elementStart(3, "span", 10);
    \u0275\u0275text(4);
    \u0275\u0275elementStart(5, "span", 11);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const value_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("selected", value_r4.selected);
    \u0275\u0275property("queryParams", ctx_r1.getLinkParams(value_r4))("cxFocus", \u0275\u0275pureFunction1(12, _c40, value_r4.name));
    \u0275\u0275attribute("role", ctx_r1.facet.multiSelect ? "checkbox" : null)("aria-checked", ctx_r1.facet.multiSelect ? value_r4.selected : null)("aria-label", \u0275\u0275pipeBind2(2, 9, "productFacetNavigation.ariaLabelItemsAvailable", \u0275\u0275pureFunction2(14, _c44, value_r4.name, value_r4.count)));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(value_r4.name);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(value_r4.count);
  }
}
function FacetComponent_ng_container_0_a_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 9, 0);
    \u0275\u0275listener("keydown.space", function FacetComponent_ng_container_0_a_10_Template_a_keydown_space_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.openLink($event));
    });
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementStart(4, "span", 12);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const value_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("selected", value_r6.selected);
    \u0275\u0275property("queryParams", ctx_r1.getLinkParams(value_r6))("cxFocus", \u0275\u0275pureFunction1(6, _c40, value_r6.name));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(value_r6.name);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(value_r6.count);
  }
}
function FacetComponent_ng_container_0_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 13);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275listener("click", function FacetComponent_ng_container_0_button_12_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.decreaseVisibleValues());
    });
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("cxAtMessage", \u0275\u0275pipeBind1(1, 4, "productFacetNavigation.decreaseOptionsVisibility"))("cxFocus", \u0275\u0275pureFunction0(10, _c45));
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 6, "productFacetNavigation.ariaLabelShowLess"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 8, "productList.showLess"), " ");
  }
}
function FacetComponent_ng_container_0_button_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 14);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275listener("click", function FacetComponent_ng_container_0_button_13_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.increaseVisibleValues());
    });
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("cxAtMessage", \u0275\u0275pipeBind1(1, 4, "productFacetNavigation.increaseOptionsVisibility"))("cxFocus", \u0275\u0275pureFunction0(10, _c45));
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 6, "productFacetNavigation.ariaLabelShowMore"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 8, "productList.showMore"), " ");
  }
}
function FacetComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 2);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275listener("click", function FacetComponent_ng_container_0_Template_button_click_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleGroup($event));
    });
    \u0275\u0275text(3);
    \u0275\u0275element(4, "cx-icon", 3)(5, "cx-icon", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div");
    \u0275\u0275template(7, FacetComponent_ng_container_0_a_7_Template, 7, 17, "a", 5);
    \u0275\u0275pipe(8, "slice");
    \u0275\u0275elementStart(9, "div", 6);
    \u0275\u0275template(10, FacetComponent_ng_container_0_a_10_Template, 6, 8, "a", 5);
    \u0275\u0275pipe(11, "slice");
    \u0275\u0275template(12, FacetComponent_ng_container_0_button_12_Template, 5, 11, "button", 7)(13, FacetComponent_ng_container_0_button_13_Template, 5, 11, "button", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    let tmp_8_0;
    const state_r9 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-expanded", ctx_r1.isExpanded)("aria-label", \u0275\u0275pipeBind2(2, 9, "productFacetNavigation.filterBy.name", \u0275\u0275pureFunction1(20, _c43, ctx_r1.facet.name)));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.facet.name, " ");
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.collapseIcon);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.expandIcon);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", \u0275\u0275pipeBind3(8, 12, ctx_r1.facet.values, 0, state_r9.topVisible));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", \u0275\u0275pipeBind3(11, 16, ctx_r1.facet.values, (tmp_8_0 = state_r9.topVisible) !== null && tmp_8_0 !== void 0 ? tmp_8_0 : 0, state_r9.maxVisible));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", state_r9.maxVisible && state_r9.topVisible && state_r9.maxVisible > state_r9.topVisible);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", state_r9.maxVisible && ctx_r1.facet.values && state_r9.maxVisible > 0 && state_r9.maxVisible < ctx_r1.facet.values.length);
  }
}
function FacetListComponent_section_0_cx_facet_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-facet", 7, 0);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275pipe(3, "async");
    \u0275\u0275pipe(4, "cxTranslate");
  }
  if (rf & 2) {
    const facet_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("expanded", \u0275\u0275pipeBind1(2, 6, ctx_r1.isExpanded(facet_r3)))("collapsed", \u0275\u0275pipeBind1(3, 8, ctx_r1.isCollapsed(facet_r3)));
    \u0275\u0275property("facet", facet_r3);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind2(4, 10, "productFacetNavigation.ariaLabelItemsAvailable", \u0275\u0275pureFunction2(13, _c44, facet_r3.name, facet_r3 == null ? null : facet_r3.values == null ? null : facet_r3.values.length)));
  }
}
function FacetListComponent_section_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "section", 2);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275listener("esc", function FacetListComponent_section_0_Template_section_esc_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.close($event));
    })("click", function FacetListComponent_section_0_Template_section_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.block($event));
    });
    \u0275\u0275elementStart(2, "div", 3)(3, "h4");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 4);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275listener("click", function FacetListComponent_section_0_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.close());
    });
    \u0275\u0275element(8, "cx-icon", 5);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(9, FacetListComponent_section_0_cx_facet_9_Template, 5, 16, "cx-facet", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const facets_r4 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("cxFocus", ctx_r1.isDialog ? ctx_r1.dialogFocusConfig : \u0275\u0275pureFunction0(13, _c26))("tabindex", -1);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 7, "productFacetNavigation.filterBy.facet"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 9, "productList.filterBy.label"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(7, 11, "common.close"));
    \u0275\u0275advance(2);
    \u0275\u0275property("type", ctx_r1.iconTypes.CLOSE);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", facets_r4);
  }
}
var _c46 = ["trigger"];
function ProductFacetNavigationComponent_cx_facet_list_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "cx-facet-list", 4);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275listener("closeList", function ProductFacetNavigationComponent_cx_facet_list_6_Template_cx_facet_list_closeList_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.close());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", \u0275\u0275pipeBind1(1, 5, ctx_r2.isActive$))("dialog", ctx_r2.hasTrigger);
    \u0275\u0275property("isDialog", ctx_r2.hasTrigger);
  }
}
var _c47 = (a0) => ({
  title: a0
});
function ProductCarouselComponent_cx_carousel_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-carousel", 2);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275pipe(2, "async");
    \u0275\u0275pipe(3, "cxTranslate");
  }
  if (rf & 2) {
    const items_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    const carouselItem_r3 = \u0275\u0275reference(3);
    \u0275\u0275property("items", items_r1)("title", \u0275\u0275pipeBind1(1, 4, ctx_r1.title$))("template", carouselItem_r3);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind2(3, 8, "productCarousel.carouselLabel", \u0275\u0275pureFunction1(11, _c47, \u0275\u0275pipeBind1(2, 6, ctx_r1.title$))));
  }
}
function ProductCarouselComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-product-carousel-item", 3);
  }
  if (rf & 2) {
    const item_r4 = ctx.item;
    \u0275\u0275property("item", item_r4);
  }
}
function ProductReferencesComponent_cx_carousel_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-carousel", 2);
    \u0275\u0275pipe(1, "async");
  }
  if (rf & 2) {
    const items_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    const carouselItem_r3 = \u0275\u0275reference(3);
    \u0275\u0275property("title", \u0275\u0275pipeBind1(1, 3, ctx_r1.title$))("items", items_r1)("template", carouselItem_r3);
  }
}
function ProductReferencesComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 3);
    \u0275\u0275pipe(1, "cxUrl");
    \u0275\u0275element(2, "cx-media", 4);
    \u0275\u0275elementStart(3, "h4");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 5);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r4 = ctx.item;
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(1, 4, \u0275\u0275pureFunction1(6, _c31, item_r4)));
    \u0275\u0275advance(2);
    \u0275\u0275property("container", item_r4.images == null ? null : item_r4.images.PRIMARY);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r4.name);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r4.price == null ? null : item_r4.price.formattedValue);
  }
}
function ProductImagesComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "cx-media", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const main_r1 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("container", main_r1);
  }
}
function ProductImagesComponent_ng_container_2_cx_carousel_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-carousel", 4);
  }
  if (rf & 2) {
    const thumbs_r2 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275nextContext();
    const thumb_r3 = \u0275\u0275reference(5);
    \u0275\u0275property("items", thumbs_r2)("hideIndicators", false)("template", thumb_r3);
  }
}
function ProductImagesComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductImagesComponent_ng_container_2_cx_carousel_1_Template, 1, 3, "cx-carousel", 3);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const thumbs_r2 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", thumbs_r2.length);
  }
}
function ProductImagesComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "cx-media", 5);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275listener("focus", function ProductImagesComponent_ng_template_4_Template_cx_media_focus_0_listener() {
      const item_r5 = \u0275\u0275restoreView(_r4).item;
      const ctx_r5 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r5.openImage(item_r5.container));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.item;
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275classProp("is-active", \u0275\u0275pipeBind1(1, 3, ctx_r5.isActive(item_r5.container)));
    \u0275\u0275property("container", item_r5.container);
  }
}
var _c48 = (a0, a1) => ({
  rating: a0,
  count: a1
});
function ProductIntroComponent_ng_container_0_div_1_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275pipe(1, "number");
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275listener("click", function ProductIntroComponent_ng_container_0_div_1_button_4_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.showReviews());
    });
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const product_r3 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind2(2, 5, "productSummary.showReviewsDetailed", \u0275\u0275pureFunction2(10, _c48, \u0275\u0275pipeBind2(1, 2, product_r3 == null ? null : product_r3.averageRating, "1.0-1"), product_r3 == null ? null : product_r3.numberOfReviews)));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 8, "productSummary.showReviews"), " ");
  }
}
function ProductIntroComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275element(1, "cx-star-rating", 4);
    \u0275\u0275elementStart(2, "div", 5);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, ProductIntroComponent_ng_container_0_div_1_button_4_Template, 5, 13, "button", 6);
    \u0275\u0275pipe(5, "async");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_3_0;
    const product_r3 = \u0275\u0275nextContext().ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("rating", (tmp_3_0 = product_r3 == null ? null : product_r3.averageRating) !== null && tmp_3_0 !== void 0 ? tmp_3_0 : 0);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("(", product_r3 == null ? null : product_r3.numberOfReviews, ")");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(5, 3, ctx_r1.areReviewsAvailable$));
  }
}
function ProductIntroComponent_ng_container_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productDetails.noReviews"), " ");
  }
}
function ProductIntroComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductIntroComponent_ng_container_0_div_1_Template, 6, 5, "div", 1)(2, ProductIntroComponent_ng_container_0_div_2_Template, 3, 3, "div", 1);
    \u0275\u0275elementStart(3, "div", 2);
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const product_r3 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", product_r3 == null ? null : product_r3.averageRating);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !(product_r3 == null ? null : product_r3.averageRating));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2(" ", \u0275\u0275pipeBind1(5, 4, "productSummary.id"), " ", product_r3 == null ? null : product_r3.code, " ");
  }
}
function ProductSummaryComponent_ng_container_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const product_r1 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 2, "productSummary.newItemPrice"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", product_r1 == null ? null : product_r1.price == null ? null : product_r1.price.formattedValue, " ");
  }
}
function ProductSummaryComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p", 3);
  }
  if (rf & 2) {
    const product_r1 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275property("innerHTML", product_r1 == null ? null : product_r1.summary, \u0275\u0275sanitizeHtml);
  }
}
function ProductSummaryComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductSummaryComponent_ng_container_0_ng_template_1_Template, 3, 4, "ng-template", 1)(2, ProductSummaryComponent_ng_container_0_ng_template_2_Template, 1, 1, "ng-template", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const product_r1 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("cxOutlet", ctx_r1.outlets.PRICE)("cxOutletContext", \u0275\u0275pureFunction1(4, _c39, product_r1));
    \u0275\u0275advance();
    \u0275\u0275property("cxOutlet", ctx_r1.outlets.SUMMARY)("cxOutletContext", \u0275\u0275pureFunction1(6, _c39, product_r1));
  }
}
function ProductAttributesComponent_ng_container_0_table_5_tr_4_li_5_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const feature_r1 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", feature_r1.featureUnit == null ? null : feature_r1.featureUnit.symbol, " ");
  }
}
function ProductAttributesComponent_ng_container_0_table_5_tr_4_li_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li");
    \u0275\u0275text(1);
    \u0275\u0275template(2, ProductAttributesComponent_ng_container_0_table_5_tr_4_li_5_span_2_Template, 2, 1, "span", 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const featureValue_r2 = ctx.$implicit;
    const feature_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", featureValue_r2 == null ? null : featureValue_r2.value, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", feature_r1.featureUnit && feature_r1.featureUnit.symbol && feature_r1.featureUnit.symbol.length > 0 && (feature_r1.featureUnit == null ? null : feature_r1.featureUnit.unitType) !== "300");
  }
}
function ProductAttributesComponent_ng_container_0_table_5_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td")(4, "ul");
    \u0275\u0275template(5, ProductAttributesComponent_ng_container_0_table_5_tr_4_li_5_Template, 3, 2, "li", 2);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const feature_r1 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(feature_r1.name);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", feature_r1 == null ? null : feature_r1.featureValues);
  }
}
function ProductAttributesComponent_ng_container_0_table_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "table")(1, "th")(2, "h2");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(4, ProductAttributesComponent_ng_container_0_table_5_tr_4_Template, 6, 2, "tr", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const class_r3 = ctx.$implicit;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(class_r3.name);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", class_r3.features);
  }
}
function ProductAttributesComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 1)(2, "h2");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, ProductAttributesComponent_ng_container_0_table_5_Template, 5, 2, "table", 2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const product_r4 = ctx.ngIf;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 2, "productDetails.specification"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", product_r4 == null ? null : product_r4.classifications);
  }
}
function ProductDetailsTabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const product_r1 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", product_r1 == null ? null : product_r1.description, \u0275\u0275sanitizeHtml);
  }
}
function ProductDetailsTabComponent_ng_container_2_ng_container_1_ng_container_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275elementContainer(1, 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const child_r2 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("cxComponentWrapper", child_r2);
  }
}
function ProductDetailsTabComponent_ng_container_2_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductDetailsTabComponent_ng_container_2_ng_container_1_ng_container_1_ng_template_1_Template, 2, 1, "ng-template", 3);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const child_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("cxOutlet", child_r2.flexType)("cxOutletContext", \u0275\u0275pureFunction0(2, _c26));
  }
}
function ProductDetailsTabComponent_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductDetailsTabComponent_ng_container_2_ng_container_1_ng_container_1_Template, 2, 3, "ng-container", 0);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const child_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", child_r2);
  }
}
function ProductDetailsTabComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductDetailsTabComponent_ng_container_2_ng_container_1_Template, 2, 1, "ng-container", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const children_r3 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", children_r3);
  }
}
var _c49 = ["titleInput"];
var _c50 = ["writeReviewButton"];
function ProductReviewsComponent_div_0_ng_container_4_cx_star_rating_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cx-star-rating", 10);
  }
  if (rf & 2) {
    const product_r3 = \u0275\u0275nextContext(2).ngIf;
    \u0275\u0275property("rating", product_r3.averageRating);
  }
}
function ProductReviewsComponent_div_0_ng_container_4_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productDetails.noReviews"), " ");
  }
}
function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14)(1, "div", 15);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "cx-star-rating", 16);
    \u0275\u0275elementStart(4, "div", 17);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 18);
    \u0275\u0275text(7);
    \u0275\u0275pipe(8, "cxDate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 19);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_11_0;
    const review_r4 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(review_r4.headline);
    \u0275\u0275advance();
    \u0275\u0275property("rating", (tmp_11_0 = review_r4.rating) !== null && tmp_11_0 !== void 0 ? tmp_11_0 : 0);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", review_r4.alias ? review_r4.alias : review_r4.principal == null ? null : review_r4.principal.name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(8, 5, review_r4.date));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(review_r4.comment);
  }
}
function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275listener("click", function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_button_1_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const reviews_r6 = \u0275\u0275nextContext(2).ngIf;
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.maxListItems = reviews_r6.length);
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productReview.more"), " ");
  }
}
function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275listener("click", function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_button_2_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(6);
      return \u0275\u0275resetView(ctx_r1.maxListItems = ctx_r1.initialMaxListItems);
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "productReview.less"), " ");
  }
}
function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275template(1, ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_button_1_Template, 3, 3, "button", 20)(2, ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_button_2_Template, 3, 3, "button", 20);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.maxListItems === ctx_r1.initialMaxListItems);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.maxListItems !== ctx_r1.initialMaxListItems);
  }
}
function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_1_Template, 11, 7, "div", 13);
    \u0275\u0275pipe(2, "slice");
    \u0275\u0275template(3, ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_div_3_Template, 3, 2, "div", 12);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const reviews_r6 = ctx.ngIf;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", \u0275\u0275pipeBind3(2, 2, reviews_r6, 0, ctx_r1.maxListItems));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", reviews_r6.length > ctx_r1.initialMaxListItems);
  }
}
function ProductReviewsComponent_div_0_ng_container_4_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ProductReviewsComponent_div_0_ng_container_4_ng_container_11_ng_container_1_Template, 4, 6, "ng-container", 12);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(2, 1, ctx_r1.reviews$));
  }
}
function ProductReviewsComponent_div_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 6)(2, "h3");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 7, 1);
    \u0275\u0275listener("click", function ProductReviewsComponent_div_0_ng_container_4_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.initiateWriteReview());
    });
    \u0275\u0275text(7);
    \u0275\u0275pipe(8, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(9, ProductReviewsComponent_div_0_ng_container_4_cx_star_rating_9_Template, 1, 1, "cx-star-rating", 8)(10, ProductReviewsComponent_div_0_ng_container_4_div_10_Template, 3, 3, "div", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275template(11, ProductReviewsComponent_div_0_ng_container_4_ng_container_11_Template, 3, 3, "ng-container", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const product_r3 = \u0275\u0275nextContext().ngIf;
    const writeReview_r8 = \u0275\u0275reference(6);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 6, "productReview.overallRating"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(8, 8, "productReview.writeReview"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", product_r3.averageRating);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !product_r3.averageRating);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isWritingReview)("ngIfElse", writeReview_r8);
  }
}
function ProductReviewsComponent_div_0_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 21);
    \u0275\u0275listener("ngSubmit", function ProductReviewsComponent_div_0_ng_template_5_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r9);
      const product_r3 = \u0275\u0275nextContext().ngIf;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.submitReview(product_r3));
    });
    \u0275\u0275elementStart(1, "div", 22)(2, "label")(3, "span", 23);
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "input", 24, 2)(8, "cx-form-errors", 25);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 22)(10, "label")(11, "span", 23);
    \u0275\u0275text(12);
    \u0275\u0275pipe(13, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "textarea", 26)(15, "cx-form-errors", 25);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "div", 22)(17, "label")(18, "span", 23);
    \u0275\u0275text(19);
    \u0275\u0275pipe(20, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275element(21, "input", 27);
    \u0275\u0275elementStart(22, "cx-star-rating", 28);
    \u0275\u0275pipe(23, "cxTranslate");
    \u0275\u0275listener("change", function ProductReviewsComponent_div_0_ng_template_5_Template_cx_star_rating_change_22_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.setRating($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275element(24, "cx-form-errors", 25);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(25, "div", 22)(26, "label")(27, "span", 23);
    \u0275\u0275text(28);
    \u0275\u0275pipe(29, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275element(30, "input", 29);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(31, "div", 30)(32, "div", 31)(33, "button", 32);
    \u0275\u0275listener("click", function ProductReviewsComponent_div_0_ng_template_5_Template_button_click_33_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.cancelWriteReview());
    });
    \u0275\u0275text(34);
    \u0275\u0275pipe(35, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(36, "div", 31)(37, "button", 33);
    \u0275\u0275text(38);
    \u0275\u0275pipe(39, "cxTranslate");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("formGroup", ctx_r1.reviewForm);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 12, "productReview.reviewTitle"));
    \u0275\u0275advance(4);
    \u0275\u0275property("control", ctx_r1.reviewForm.get("title"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(13, 14, "productReview.writeYourComments"));
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.reviewForm.get("comment"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(20, 16, "productReview.rating"));
    \u0275\u0275advance(3);
    \u0275\u0275property("disabled", false);
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(23, 18, "productReview.ratingRequired"));
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.reviewForm.get("rating"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(29, 20, "productReview.reviewerName"));
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(35, 22, "common.cancel"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(39, 24, "common.submit"), " ");
  }
}
function ProductReviewsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4)(1, "h2");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, ProductReviewsComponent_div_0_ng_container_4_Template, 12, 10, "ng-container", 5)(5, ProductReviewsComponent_div_0_ng_template_5_Template, 40, 26, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const product_r3 = ctx.ngIf;
    const writeReview_r8 = \u0275\u0275reference(6);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2(" ", \u0275\u0275pipeBind1(3, 4, "productDetails.reviews"), " (", product_r3.numberOfReviews, ") ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r1.isWritingReview)("ngIfElse", writeReview_r8);
  }
}
var _c51 = () => ({
  cxRoute: "notificationPreference"
});
var _c522 = () => ({
  cxRoute: "myInterests"
});
function StockNotificationDialogComponent_ng_container_10_p_8_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const preference_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(": " + preference_r3.value);
  }
}
function StockNotificationDialogComponent_ng_container_10_p_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 19)(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, StockNotificationDialogComponent_ng_container_10_p_8_span_3_Template, 2, 1, "span", 20);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const preference_r3 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(preference_r3.channel);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", preference_r3.value);
  }
}
function StockNotificationDialogComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 8);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementStart(3, "div", 9)(4, "div", 10)(5, "p", 11);
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(8, StockNotificationDialogComponent_ng_container_10_p_8_Template, 4, 2, "p", 12);
    \u0275\u0275elementStart(9, "p", 11);
    \u0275\u0275text(10);
    \u0275\u0275pipe(11, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "p", 11);
    \u0275\u0275text(13);
    \u0275\u0275pipe(14, "cxTranslate");
    \u0275\u0275elementStart(15, "a", 13);
    \u0275\u0275pipe(16, "cxUrl");
    \u0275\u0275listener("click", function StockNotificationDialogComponent_ng_container_10_Template_a_click_15_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.close("Link clicked"));
    });
    \u0275\u0275text(17);
    \u0275\u0275pipe(18, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275text(19);
    \u0275\u0275pipe(20, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "p", 11);
    \u0275\u0275text(22);
    \u0275\u0275pipe(23, "cxTranslate");
    \u0275\u0275elementStart(24, "a", 14);
    \u0275\u0275pipe(25, "cxUrl");
    \u0275\u0275listener("click", function StockNotificationDialogComponent_ng_container_10_Template_a_click_24_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.close("Link clicked"));
    });
    \u0275\u0275text(26);
    \u0275\u0275pipe(27, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275text(28);
    \u0275\u0275pipe(29, "cxTranslate");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(30, "div", 15)(31, "div", 16)(32, "div", 17)(33, "button", 18);
    \u0275\u0275listener("click", function StockNotificationDialogComponent_ng_container_10_Template_button_click_33_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.close("Button clicked"));
    });
    \u0275\u0275text(34);
    \u0275\u0275pipe(35, "cxTranslate");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 13, "common.loaded"));
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 15, "stockNotification.subscriptionDialog.notifiedPrefix"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r3.enabledPrefs);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(11, 17, "stockNotification.subscriptionDialog.notifiedSuffix"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(14, 19, "stockNotification.subscriptionDialog.manageChannelsPrefix"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(16, 21, \u0275\u0275pureFunction0(37, _c51)));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(18, 23, "stockNotification.subscriptionDialog.manageChannelsLink"), "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(20, 25, "stockNotification.subscriptionDialog.manageChannelsSuffix"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(23, 27, "stockNotification.subscriptionDialog.manageSubscriptionsPrefix"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(25, 29, \u0275\u0275pureFunction0(38, _c522)));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(27, 31, "stockNotification.subscriptionDialog.manageSubscriptionsLink"), "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(29, 33, "stockNotification.subscriptionDialog.manageSubscriptionsSuffix"), " ");
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(35, 35, "stockNotification.subscriptionDialog.okBtn"), " ");
  }
}
function StockNotificationDialogComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9)(1, "p");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 21)(5, "div", 22);
    \u0275\u0275element(6, "cx-spinner");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(3, 1, "stockNotification.subscriptionDialog.subscribing"), " ");
  }
}
var _c53 = () => ({
  cxRoute: "login"
});
function StockNotificationComponent_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 6)(2, "p");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "button", 7);
    \u0275\u0275listener("click", function StockNotificationComponent_ng_container_0_ng_container_1_ng_container_1_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.subscribe());
    });
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 2, "stockNotification.getNotified"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 4, "stockNotification.notifyMe"), " ");
  }
}
function StockNotificationComponent_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, StockNotificationComponent_ng_container_0_ng_container_1_ng_container_1_Template, 8, 6, "ng-container", 5);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    const disableNotify_r3 = \u0275\u0275reference(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(2, 2, ctx_r1.prefsEnabled$))("ngIfElse", disableNotify_r3);
  }
}
function StockNotificationComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, StockNotificationComponent_ng_container_0_ng_container_1_Template, 3, 4, "ng-container", 5);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const stopNotify_r4 = \u0275\u0275reference(5);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !\u0275\u0275pipeBind1(2, 2, ctx_r1.hasProductInterests$))("ngIfElse", stopNotify_r4);
  }
}
function StockNotificationComponent_ng_template_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "a", 10);
    \u0275\u0275pipe(2, "cxUrl");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "cxTranslate");
    \u0275\u0275element(7, "br");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(2, 3, \u0275\u0275pureFunction0(9, _c53)));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 5, "miniLogin.signInRegister"), "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(6, 7, "stockNotification.getNotifySuffix"), "");
  }
}
function StockNotificationComponent_ng_template_2_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "cxTranslate");
    \u0275\u0275element(2, "br");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "cxTranslate");
    \u0275\u0275elementStart(5, "a", 10);
    \u0275\u0275pipe(6, "cxUrl");
    \u0275\u0275text(7);
    \u0275\u0275pipe(8, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275text(9);
    \u0275\u0275pipe(10, "cxTranslate");
  }
  if (rf & 2) {
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(1, 5, "stockNotification.getNotify"), "");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 7, "stockNotification.activateChannelsPrefix"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(6, 9, \u0275\u0275pureFunction0(15, _c51)));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(8, 11, "stockNotification.channelsLink"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(10, 13, "stockNotification.activateChannelsSuffix"), " ");
  }
}
function StockNotificationComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8)(1, "p");
    \u0275\u0275template(2, StockNotificationComponent_ng_template_2_ng_container_2_Template, 8, 10, "ng-container", 5)(3, StockNotificationComponent_ng_template_2_ng_template_3_Template, 11, 16, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "button", 9);
    \u0275\u0275listener("click", function StockNotificationComponent_ng_template_2_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.subscribe());
    });
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "cxTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const loggedIn_r6 = \u0275\u0275reference(4);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.anonymous)("ngIfElse", loggedIn_r6);
    \u0275\u0275advance(3);
    \u0275\u0275attribute("disabled", ctx_r1.anonymous ? true : null);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 4, "stockNotification.notifyMe"), " ");
  }
}
function StockNotificationComponent_ng_template_4_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 11);
    \u0275\u0275pipe(2, "cxTranslate");
    \u0275\u0275elementStart(3, "div", 6)(4, "p");
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "cxTranslate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "button", 12);
    \u0275\u0275listener("click", function StockNotificationComponent_ng_template_4_ng_container_0_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.unsubscribe());
    });
    \u0275\u0275text(8);
    \u0275\u0275pipe(9, "cxTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(2, 3, "common.loaded"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(6, 5, "stockNotification.notified"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(9, 7, "stockNotification.stopNotify"), " ");
  }
}
function StockNotificationComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, StockNotificationComponent_ng_template_4_ng_container_0_Template, 10, 9, "ng-container", 5);
    \u0275\u0275pipe(1, "async");
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const loading_r8 = \u0275\u0275reference(7);
    \u0275\u0275property("ngIf", !\u0275\u0275pipeBind1(1, 2, ctx_r1.isRemoveInterestLoading$))("ngIfElse", loading_r8);
  }
}
function StockNotificationComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13)(1, "div", 14)(2, "div", 15);
    \u0275\u0275element(3, "cx-spinner");
    \u0275\u0275elementEnd()()();
  }
}
var FOCUS_ATTR = "data-cx-focus";
var FOCUS_GROUP_ATTR = "data-cx-focus-group";
var TrapFocus;
(function(TrapFocus2) {
  TrapFocus2["start"] = "start";
  TrapFocus2["end"] = "end";
  TrapFocus2["both"] = "both";
})(TrapFocus || (TrapFocus = {}));
var _BaseFocusService = class _BaseFocusService {
};
_BaseFocusService.\u0275fac = function BaseFocusService_Factory(t) {
  return new (t || _BaseFocusService)();
};
_BaseFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _BaseFocusService,
  factory: _BaseFocusService.\u0275fac,
  providedIn: "root"
});
var BaseFocusService = _BaseFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _BaseFocusDirective = class _BaseFocusDirective {
  constructor(elementRef, service) {
    this.elementRef = elementRef;
    this.service = service;
    this.defaultConfig = {};
  }
  ngOnInit() {
    this.setDefaultConfiguration();
    this.requiredTabindex = -1;
  }
  // empty, but sub classes might have an implementation
  /* eslint @angular-eslint/no-empty-lifecycle-method: 1 */
  ngOnChanges(_changes) {
  }
  /**
   * Override the (input) config if it undefined or an empty string, with the
   * `defaultConfig`. The `defaultConfig` might be specified for each directive
   * differently. If a specific directive is used (i.e. `cxAutoFocus`), the
   * specific (inherited) defaultConfig will be used.
   */
  setDefaultConfiguration() {
    if ((!this.config || this.config === "") && this.defaultConfig) {
      this.config = this.defaultConfig;
    }
  }
  /**
   * Helper method to return the host element for the directive
   * given by the `elementRef`.
   */
  get host() {
    return this.elementRef.nativeElement;
  }
  /**
   * Force a tabindex on the host element if it is _required_ to make the element
   * focusable. If the element is focusable by nature or by a given tabindex, the
   * `tabindex` is not applied.
   *
   * Buttons, active links, etc. do no need an explicit tabindex to receive focus.
   */
  set requiredTabindex(tabindex) {
    if (this.requiresExplicitTabIndex) {
      this.tabindex = tabindex;
    }
  }
  /**
   * Returns true if the host element does not have a tabindex defined
   * and it also doesn't get focus by browsers nature (i.e. button or
   * active link).
   */
  get requiresExplicitTabIndex() {
    return this.tabindex === void 0 && ["button", "input", "select", "textarea"].indexOf(this.host.tagName.toLowerCase()) === -1 && !(this.host.tagName === "A" && (this.host.hasAttribute("href") || this.host.hasAttribute("routerlink") || this.host.getAttribute("ng-reflect-router-link")));
  }
};
_BaseFocusDirective.\u0275fac = function BaseFocusDirective_Factory(t) {
  return new (t || _BaseFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(BaseFocusService));
};
_BaseFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BaseFocusDirective,
  hostVars: 1,
  hostBindings: function BaseFocusDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("tabindex", ctx.tabindex);
    }
  },
  inputs: {
    tabindex: "tabindex"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var BaseFocusDirective = _BaseFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: BaseFocusService
  }], {
    tabindex: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.tabindex"]
    }]
  });
})();
var _VisibleFocusDirective = class _VisibleFocusDirective extends BaseFocusDirective {
  constructor() {
    super(...arguments);
    this.defaultConfig = {
      disableMouseFocus: true
    };
    this.mouseFocus = false;
  }
  handleMousedown() {
    if (this.shouldFocusVisible) {
      this.mouseFocus = true;
    }
  }
  handleKeydown(event) {
    if (this.shouldFocusVisible) {
      this.mouseFocus = !this.isNavigating(event);
    }
  }
  /**
   * Indicates whether the configurations setup to disable visual focus.
   */
  get shouldFocusVisible() {
    return this.config?.disableMouseFocus;
  }
  /**
   * Indicates whether the event is used to navigate the storefront. Some keyboard events
   * are used by mouse users to fill a form or interact with the OS or browser.
   */
  isNavigating(event) {
    if (event.metaKey) {
      return false;
    }
    if (event.code === "Tab") {
      return true;
    }
    if (["INPUT", "TEXTAREA"].includes(event.target.tagName)) {
      return false;
    }
    return true;
  }
};
_VisibleFocusDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275VisibleFocusDirective_BaseFactory;
  return function VisibleFocusDirective_Factory(t) {
    return (\u0275VisibleFocusDirective_BaseFactory || (\u0275VisibleFocusDirective_BaseFactory = \u0275\u0275getInheritedFactory(_VisibleFocusDirective)))(t || _VisibleFocusDirective);
  };
})();
_VisibleFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _VisibleFocusDirective,
  hostVars: 2,
  hostBindings: function VisibleFocusDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mousedown", function VisibleFocusDirective_mousedown_HostBindingHandler() {
        return ctx.handleMousedown();
      })("keydown", function VisibleFocusDirective_keydown_HostBindingHandler($event) {
        return ctx.handleKeydown($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("mouse-focus", ctx.mouseFocus);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var VisibleFocusDirective = _VisibleFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VisibleFocusDirective, [{
    type: Directive
  }], null, {
    mouseFocus: [{
      type: HostBinding,
      args: ["class.mouse-focus"]
    }],
    handleMousedown: [{
      type: HostListener,
      args: ["mousedown"]
    }],
    handleKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var _BlockFocusDirective = class _BlockFocusDirective extends VisibleFocusDirective {
  constructor(elementRef, service) {
    super(elementRef, service);
    this.elementRef = elementRef;
    this.service = service;
    this.defaultConfig = {
      block: true
    };
    this.config = {};
  }
  ngOnInit() {
    super.ngOnInit();
    if (this.config.block) {
      this.tabindex = -1;
    }
  }
};
_BlockFocusDirective.\u0275fac = function BlockFocusDirective_Factory(t) {
  return new (t || _BlockFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(BaseFocusService));
};
_BlockFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BlockFocusDirective,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var BlockFocusDirective = _BlockFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BlockFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: BaseFocusService
  }], null);
})();
var GLOBAL_GROUP = "_g_";
var _PersistFocusService = class _PersistFocusService extends BaseFocusService {
  constructor() {
    super(...arguments);
    this.focus = /* @__PURE__ */ new Map();
  }
  get(group) {
    return this.focus.get(group || GLOBAL_GROUP);
  }
  /**
   * Persist the keyboard focus state for the given key. The focus is stored globally
   * or for the given group.
   */
  set(key, group) {
    if (key) {
      this.focus.set(group || GLOBAL_GROUP, key);
    }
  }
  /**
   * Clears the persisted keyboard focus state globally or for the given group.
   */
  clear(group) {
    this.focus.delete(group || GLOBAL_GROUP);
  }
  /**
   * Returns the group for the host element based on the configured group or
   * by the `data-cx-focus-group` attribute stored on the host.
   */
  getPersistenceGroup(host, config) {
    return config?.group ? config.group : host?.getAttribute(FOCUS_GROUP_ATTR);
  }
};
_PersistFocusService.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PersistFocusService_BaseFactory;
  return function PersistFocusService_Factory(t) {
    return (\u0275PersistFocusService_BaseFactory || (\u0275PersistFocusService_BaseFactory = \u0275\u0275getInheritedFactory(_PersistFocusService)))(t || _PersistFocusService);
  };
})();
_PersistFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PersistFocusService,
  factory: _PersistFocusService.\u0275fac,
  providedIn: "root"
});
var PersistFocusService = _PersistFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PersistFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _PersistFocusDirective = class _PersistFocusDirective extends BlockFocusDirective {
  handleFocus(event) {
    this.service.set(this.key, this.group);
    event?.preventDefault();
    event?.stopPropagation();
  }
  constructor(elementRef, service) {
    super(elementRef, service);
    this.elementRef = elementRef;
    this.service = service;
    this.defaultConfig = {};
    this.config = {};
  }
  ngOnInit() {
    super.ngOnInit();
    this.attr = this.key ? this.key : void 0;
  }
  setDefaultConfiguration() {
    if (typeof this.config === "string" && this.config !== "") {
      this.config = {
        key: this.config
      };
    }
    super.setDefaultConfiguration();
  }
  /**
   * Focus the element explicitly if it was focused before.
   */
  ngAfterViewInit() {
    if (this.isPersisted) {
      this.host.focus({
        preventScroll: true
      });
    }
  }
  get isPersisted() {
    return !!this.key && this.service.get(this.group) === this.key;
  }
  /**
   * Returns the key for the host element, which is used to persist the
   * focus state. This is useful in cases where the DOM is rebuild.
   */
  get key() {
    return this.config?.key;
  }
  /**
   * returns the persistence group (if any) for the focusable elements.
   */
  get group() {
    return this.service.getPersistenceGroup(this.host, this.config);
  }
};
_PersistFocusDirective.\u0275fac = function PersistFocusDirective_Factory(t) {
  return new (t || _PersistFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(PersistFocusService));
};
_PersistFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PersistFocusDirective,
  hostVars: 1,
  hostBindings: function PersistFocusDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("focus", function PersistFocusDirective_focus_HostBindingHandler($event) {
        return ctx.handleFocus($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("data-cx-focus", ctx.attr);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var PersistFocusDirective = _PersistFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PersistFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: PersistFocusService
  }], {
    attr: [{
      type: HostBinding,
      args: [`attr.${FOCUS_ATTR}`]
    }],
    handleFocus: [{
      type: HostListener,
      args: ["focus", ["$event"]]
    }]
  });
})();
var _SelectFocusUtility = class _SelectFocusUtility {
  constructor() {
    this.focusableSelectors = ["a[href]", "button", "[tabindex]", "input", "select", "textarea"];
    this.focusableSelectorSuffix = ":not([disabled]):not([hidden]):not([aria-hidden])";
  }
  query(host, selector) {
    if (!selector || selector === "") {
      return [];
    }
    return Array.from(host?.querySelectorAll(selector));
  }
  findFirstFocusable(host, config = {
    autofocus: true
  }) {
    const selector = typeof config?.autofocus === "string" ? config.autofocus : "[autofocus]";
    return this.query(host, selector).find((el) => !this.isHidden(el)) || this.findFocusable(host).find((el) => Boolean(el));
  }
  /**
   * returns all focusable child elements of the host element. The element selectors
   * are build from the `focusableSelectors`.
   *
   * @param host the `HTMLElement` used to query focusable elements
   * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
   * @param invisible indicates whether hidden focusable elements should be returned
   */
  findFocusable(host, locked = false, invisible = false) {
    let suffix = this.focusableSelectorSuffix;
    if (!locked) {
      suffix += `:not([tabindex='-1'])`;
    }
    const selector = this.focusableSelectors.map((s) => s += suffix).join(",");
    return this.query(host, selector).filter((el) => !invisible ? !this.isHidden(el) : Boolean(el));
  }
  /**
   * Indicates whether the element is hidden by CSS. There are various CSS rules and
   * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
   * of null indicates that the element or any of it's decendants is hidden (`display:none`).
   *
   * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
   * phyisical location on the element itself or any of it's anchestor elements. Those
   * technique require to work with the _computed styles_, which will cause a performance
   * downgrade. We don't do this in the standard implementaton.
   */
  isHidden(el) {
    return el.offsetParent === null;
  }
};
_SelectFocusUtility.\u0275fac = function SelectFocusUtility_Factory(t) {
  return new (t || _SelectFocusUtility)();
};
_SelectFocusUtility.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SelectFocusUtility,
  factory: _SelectFocusUtility.\u0275fac,
  providedIn: "root"
});
var SelectFocusUtility = _SelectFocusUtility;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectFocusUtility, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _EscapeFocusService = class _EscapeFocusService extends PersistFocusService {
  constructor(selectFocusUtil) {
    super();
    this.selectFocusUtil = selectFocusUtil;
  }
  shouldFocus(config) {
    return !!config?.focusOnEscape;
  }
  handleEscape(host, config, event) {
    if (this.shouldFocus(config)) {
      if (host !== event.target) {
        host.focus({
          preventScroll: true
        });
        event.preventDefault();
        event.stopPropagation();
      } else {
        if (config?.focusOnDoubleEscape) {
          this.selectFocusUtil.findFirstFocusable(host, {
            autofocus: true
          })?.focus();
        }
      }
    }
  }
};
_EscapeFocusService.\u0275fac = function EscapeFocusService_Factory(t) {
  return new (t || _EscapeFocusService)(\u0275\u0275inject(SelectFocusUtility));
};
_EscapeFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _EscapeFocusService,
  factory: _EscapeFocusService.\u0275fac,
  providedIn: "root"
});
var EscapeFocusService = _EscapeFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EscapeFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: SelectFocusUtility
  }], null);
})();
var _EscapeFocusDirective = class _EscapeFocusDirective extends PersistFocusDirective {
  /**
   * Handles the escape key event.
   * @param event the native keyboard event which contains the escape keydown event
   */
  handleEscape(event) {
    if (this.service.shouldFocus(this.config)) {
      this.service.handleEscape(this.host, this.config, event);
    }
    this.esc.emit(this.service.shouldFocus(this.config));
  }
  constructor(elementRef, service) {
    super(elementRef, service);
    this.elementRef = elementRef;
    this.service = service;
    this.defaultConfig = {
      focusOnEscape: true
    };
    this.esc = new EventEmitter();
  }
  ngOnInit() {
    if (this.service.shouldFocus(this.config)) {
      this.requiredTabindex = -1;
    }
    super.ngOnInit();
  }
};
_EscapeFocusDirective.\u0275fac = function EscapeFocusDirective_Factory(t) {
  return new (t || _EscapeFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(EscapeFocusService));
};
_EscapeFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _EscapeFocusDirective,
  hostBindings: function EscapeFocusDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown.escape", function EscapeFocusDirective_keydown_escape_HostBindingHandler($event) {
        return ctx.handleEscape($event);
      });
    }
  },
  outputs: {
    esc: "esc"
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var EscapeFocusDirective = _EscapeFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EscapeFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: EscapeFocusService
  }], {
    esc: [{
      type: Output
    }],
    handleEscape: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }]
  });
})();
var _AutoFocusService = class _AutoFocusService extends EscapeFocusService {
  /**
   * Returns the first focusable child element of the host element.
   */
  findFirstFocusable(host, config = {
    autofocus: true
  }) {
    if (config?.autofocus === ":host") {
      return host;
    } else if (this.hasPersistedFocus(host, config)) {
      return this.getPersisted(host, this.getPersistenceGroup(host, config));
    } else {
      return this.selectFocusUtil.findFirstFocusable(host, config) || host;
    }
  }
  /**
   * Indicates whether any of the focusable child elements is focused.
   */
  hasPersistedFocus(host, config) {
    return !!this.getPersisted(host, this.getPersistenceGroup(host, config));
  }
  /**
   * Returns the element that has a persisted focus state.
   *
   * @param host the `HTMLElement` used to query for focusable children
   * @param group the optional group for the persistent state, to separate different focus
   *   groups and remain the persistence
   */
  getPersisted(host, group) {
    if (!this.get(group)) {
      return;
    }
    const focussed = Array.from(host?.querySelectorAll(`[${FOCUS_ATTR}='${this.get(group)}']`));
    return focussed.length > 0 ? focussed[0] : void 0;
  }
};
_AutoFocusService.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AutoFocusService_BaseFactory;
  return function AutoFocusService_Factory(t) {
    return (\u0275AutoFocusService_BaseFactory || (\u0275AutoFocusService_BaseFactory = \u0275\u0275getInheritedFactory(_AutoFocusService)))(t || _AutoFocusService);
  };
})();
_AutoFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _AutoFocusService,
  factory: _AutoFocusService.\u0275fac,
  providedIn: "root"
});
var AutoFocusService = _AutoFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _AutoFocusDirective = class _AutoFocusDirective extends EscapeFocusDirective {
  constructor(elementRef, service) {
    super(elementRef, service);
    this.elementRef = elementRef;
    this.service = service;
    this.defaultConfig = {
      autofocus: true
    };
  }
  /**
   * Focus the element explicitly if it was focussed before.
   */
  ngAfterViewInit() {
    if (this.shouldAutofocus) {
      this.handleFocus();
    }
    if (!this.shouldAutofocus || this.hasPersistedFocus) {
      super.ngAfterViewInit();
    }
  }
  ngOnChanges(changes) {
    if (!!changes.config?.currentValue?.refreshFocus) {
      if (!this.config.autofocus) {
        this.config.autofocus = true;
      }
      this.handleFocus();
    }
    super.ngOnChanges(changes);
  }
  /**
   * Mimic the focus without setting the actual focus on the host. The first
   * focusable child element will be focussed.
   */
  handleFocus(event) {
    if (this.shouldAutofocus) {
      if (!event?.target || event.target === this.host) {
        this.firstFocusable?.focus();
      } else {
        event.target.focus();
      }
    }
    super.handleFocus(event);
  }
  /**
   * Helper function to get the first focusable child element
   */
  get hasPersistedFocus() {
    return this.service.hasPersistedFocus(this.host, this.config);
  }
  /**
   * Helper function to indicate whether we should use autofocus for the
   * child elements.
   */
  get shouldAutofocus() {
    return !!this.config?.autofocus;
  }
  /**
   * Helper function to get the first focusable child element.
   *
   * We keep this private to not pollute the API.
   */
  get firstFocusable() {
    return this.service.findFirstFocusable(this.host, this.config);
  }
};
_AutoFocusDirective.\u0275fac = function AutoFocusDirective_Factory(t) {
  return new (t || _AutoFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(AutoFocusService));
};
_AutoFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AutoFocusDirective,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var AutoFocusDirective = _AutoFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: AutoFocusService
  }], null);
})();
var _TabFocusService = class _TabFocusService extends AutoFocusService {
  /**
   * Moves to the next (or previous) tab.
   */
  moveTab(host, config, increment, event) {
    if (config?.tab) {
      const next = config.tab === "scroll" ? this.findNextScrollable(host, config, increment) : this.findNext(host, config, increment);
      next?.focus();
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /**
   * builds out virtual slides out of the full scrollable area, to allow
   * for maximum flexibility for the underlying layout without using hardcoded
   * slide sizes.
   */
  findNextScrollable(host, config, increment) {
    const active = this.getActiveChild(host, config);
    if (!active) {
      return;
    }
    const virtualSlideCount = Math.round(host.scrollWidth / host.clientWidth);
    const currentVirtualSlide = Math.round(active.offsetLeft / (host.scrollWidth / virtualSlideCount));
    let nextVirtualSlide = currentVirtualSlide + increment;
    if (increment === 1 && nextVirtualSlide >= virtualSlideCount) {
      nextVirtualSlide = 0;
    }
    if (increment === -1 && nextVirtualSlide < 0) {
      nextVirtualSlide = virtualSlideCount - 1;
    }
    const firstItemOnNextSlide = this.getChildren(host, config)?.find((tab) => tab.offsetLeft >= host.scrollWidth / virtualSlideCount * nextVirtualSlide);
    return firstItemOnNextSlide;
  }
  findNext(host, config, increment) {
    const childs = this.getChildren(host, config);
    let activeIndex = childs?.findIndex((c) => c === this.getActiveChild(host, config));
    if (!activeIndex || activeIndex === -1) {
      activeIndex = 0;
    }
    activeIndex += increment;
    if (increment === 1 && activeIndex >= childs?.length) {
      activeIndex = childs.length - 1;
    }
    if (increment === -1 && activeIndex < 0) {
      activeIndex = 0;
    }
    return childs ? childs[activeIndex] : void 0;
  }
  /**
   * Returns the active focusable child element. If there's no active
   * focusable child element, the first focusable child is returned.
   */
  getActiveChild(host, config) {
    const persisted = this.getPersisted(host, config?.group);
    if (persisted) {
      return persisted;
    }
    const children = this.getChildren(host, config);
    let index = children.findIndex((tab) => this.isActive(tab));
    if (!index || index === -1) {
      index = 0;
    }
    return children[index];
  }
  getChildren(host, config) {
    if (typeof config.tab === "string" && config.tab !== "scroll") {
      return this.selectFocusUtil.query(host, config.tab);
    } else {
      return this.findFocusable(host, true);
    }
  }
  /**
   * Returns all focusable child elements of the host element.
   *
   * @param host The host element is used to query child focusable elements.
   * @param locked Indicates if locked elements (tabindex=-1) should be returned, defaults to false.
   * @param invisible Indicates if invisible child elements should be returned, defaults to false.
   */
  findFocusable(host, locked = false, invisible = false) {
    return this.selectFocusUtil.findFocusable(host, locked, invisible);
  }
  isActive(el) {
    const child = document.activeElement;
    const selector = child?.tagName;
    return el === child || !!selector && !!Array.from(el.querySelectorAll(selector)).find((e) => e === child);
  }
};
_TabFocusService.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275TabFocusService_BaseFactory;
  return function TabFocusService_Factory(t) {
    return (\u0275TabFocusService_BaseFactory || (\u0275TabFocusService_BaseFactory = \u0275\u0275getInheritedFactory(_TabFocusService)))(t || _TabFocusService);
  };
})();
_TabFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TabFocusService,
  factory: _TabFocusService.\u0275fac,
  providedIn: "root"
});
var TabFocusService = _TabFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _TabFocusDirective = class _TabFocusDirective extends AutoFocusDirective {
  handleNextTab(event) {
    if (this.config?.tab) {
      this.service.moveTab(this.host, this.config, 1, event);
    }
  }
  handlePreviousTab(event) {
    if (this.config?.tab) {
      this.service.moveTab(this.host, this.config, -1, event);
    }
  }
  constructor(elementRef, service) {
    super(elementRef, service);
    this.elementRef = elementRef;
    this.service = service;
    this.defaultConfig = {
      tab: true
    };
    this.config = {};
  }
};
_TabFocusDirective.\u0275fac = function TabFocusDirective_Factory(t) {
  return new (t || _TabFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(TabFocusService));
};
_TabFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _TabFocusDirective,
  hostBindings: function TabFocusDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown.arrowRight", function TabFocusDirective_keydown_arrowRight_HostBindingHandler($event) {
        return ctx.handleNextTab($event);
      })("keydown.arrowLeft", function TabFocusDirective_keydown_arrowLeft_HostBindingHandler($event) {
        return ctx.handlePreviousTab($event);
      });
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var TabFocusDirective = _TabFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: TabFocusService
  }], {
    handleNextTab: [{
      type: HostListener,
      args: ["keydown.arrowRight", ["$event"]]
    }],
    handlePreviousTab: [{
      type: HostListener,
      args: ["keydown.arrowLeft", ["$event"]]
    }]
  });
})();
var _TrapFocusService = class _TrapFocusService extends TabFocusService {
  /**
   * Indicates whether any of the child elements of the host are focusable.
   *
   * @param host `HTMLElement` that is used to query the focusable elements.
   */
  hasFocusableChildren(host) {
    return this.findFocusable(host).length > 0;
  }
  /**
   * Focus the next or previous element of all available focusable elements.
   * The focus is _trapped_ in case there's no next or previous available element.
   * The focus will automatically move the start or end of the list.
   */
  moveFocus(host, config, increment, event) {
    const focusable = this.findFocusable(host);
    let index = focusable.findIndex((v) => v === event.target) + increment;
    const shouldMoveFocus = index >= 0 && index < focusable.length || index < 0 && this.getTrapStart(config.trap) || index >= focusable.length && this.getTrapEnd(config.trap);
    if (shouldMoveFocus) {
      if (index >= focusable.length) {
        index = 0;
      }
      if (index < 0) {
        index = focusable.length - 1;
      }
      event.preventDefault();
      event.stopPropagation();
      const el = focusable[index];
      el.focus();
    }
  }
  getTrapStart(trap) {
    return trap === true || trap === TrapFocus.start;
  }
  getTrapEnd(trap) {
    return trap === true || trap === TrapFocus.end;
  }
};
_TrapFocusService.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275TrapFocusService_BaseFactory;
  return function TrapFocusService_Factory(t) {
    return (\u0275TrapFocusService_BaseFactory || (\u0275TrapFocusService_BaseFactory = \u0275\u0275getInheritedFactory(_TrapFocusService)))(t || _TrapFocusService);
  };
})();
_TrapFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TrapFocusService,
  factory: _TrapFocusService.\u0275fac,
  providedIn: "root"
});
var TrapFocusService = _TrapFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrapFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _TrapFocusDirective = class _TrapFocusDirective extends TabFocusDirective {
  constructor(elementRef, service) {
    super(elementRef, service);
    this.elementRef = elementRef;
    this.service = service;
    this.defaultConfig = {
      trap: true
    };
    this.config = {};
    this.handleTrapDown = (event) => {
      if (!!this.config.trap) {
        this.moveFocus(
          event,
          1
          /* MOVE_FOCUS.NEXT */
        );
      }
    };
    this.handleTrapUp = (event) => {
      if (!!this.config.trap) {
        this.moveFocus(
          event,
          -1
          /* MOVE_FOCUS.PREV */
        );
      }
    };
  }
  /**
   * Moves the focus of the element reference up or down, depending on the increment.
   * The focus of the element is trapped to avoid it from going out of the group.
   *
   * @param event UIEvent that is used to get the target element. The event is blocked
   *   from standard execution and further bubbling.
   * @param increment indicates whether the next or previous is focussed.
   */
  moveFocus(event, increment) {
    if (this.service.hasFocusableChildren(this.host)) {
      this.service.moveFocus(this.host, this.config, increment, event);
    }
  }
};
_TrapFocusDirective.\u0275fac = function TrapFocusDirective_Factory(t) {
  return new (t || _TrapFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(TrapFocusService));
};
_TrapFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _TrapFocusDirective,
  hostBindings: function TrapFocusDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown.arrowdown", function TrapFocusDirective_keydown_arrowdown_HostBindingHandler($event) {
        return ctx.handleTrapDown($event);
      })("keydown.tab", function TrapFocusDirective_keydown_tab_HostBindingHandler($event) {
        return ctx.handleTrapDown($event);
      })("keydown.arrowup", function TrapFocusDirective_keydown_arrowup_HostBindingHandler($event) {
        return ctx.handleTrapUp($event);
      })("keydown.shift.tab", function TrapFocusDirective_keydown_shift_tab_HostBindingHandler($event) {
        return ctx.handleTrapUp($event);
      });
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var TrapFocusDirective = _TrapFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrapFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: TrapFocusService
  }], {
    handleTrapDown: [{
      type: HostListener,
      args: ["keydown.arrowdown", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.tab", ["$event"]]
    }],
    handleTrapUp: [{
      type: HostListener,
      args: ["keydown.arrowup", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.shift.tab", ["$event"]]
    }]
  });
})();
var _LockFocusService = class _LockFocusService extends TrapFocusService {
};
_LockFocusService.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275LockFocusService_BaseFactory;
  return function LockFocusService_Factory(t) {
    return (\u0275LockFocusService_BaseFactory || (\u0275LockFocusService_BaseFactory = \u0275\u0275getInheritedFactory(_LockFocusService)))(t || _LockFocusService);
  };
})();
_LockFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LockFocusService,
  factory: _LockFocusService.\u0275fac,
  providedIn: "root"
});
var LockFocusService = _LockFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LockFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var UNLOCK_HIDDEN_ELEMENTS = true;
var _LockFocusDirective = class _LockFocusDirective extends TrapFocusDirective {
  /**
   * When the user selects enter or space, the focusable childs are
   * unlocked, which means that the tabindex is set to 0.
   */
  handleEnter(event) {
    if (this.shouldLock && this.host === event.target) {
      this.unlockFocus(event);
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /**
   * In case any of the children elements is touched by the mouse,
   * we unlock the group to not break the mouse-experience.
   */
  handleClick(event) {
    if (this.shouldLock && this.isLocked) {
      this.unlockFocus(event);
      event.stopPropagation();
    }
  }
  constructor(elementRef, service, renderer) {
    super(elementRef, service);
    this.elementRef = elementRef;
    this.service = service;
    this.renderer = renderer;
    this.defaultConfig = {
      lock: true
    };
    this.config = {};
    this.unlock = new EventEmitter();
  }
  lockFocus() {
    this.addTabindexToChildren(-1);
  }
  unlockFocus(event) {
    this.unlock.emit(true);
    this.addTabindexToChildren(0);
    if (event?.target === this.host) {
      setTimeout(() => {
        super.handleFocus(event);
      }, 100);
    }
  }
  ngOnInit() {
    super.ngOnInit();
    this.shouldLock = this.config?.lock;
    if (this.shouldLock) {
      this.tabindex = 0;
      if (!this.config.hasOwnProperty("autofocus")) {
        this.config.autofocus = true;
      }
      if (!this.config.hasOwnProperty("focusOnEscape")) {
        this.config.focusOnEscape = !(this.config?.focusOnEscape === false);
      }
    }
  }
  ngAfterViewInit() {
    if (this.shouldLock) {
      if (!!this.group) {
        const group = this.group;
        this.service.findFocusable(this.host).forEach((el) => (
          // we must do this in after view init as
          this.renderer.setAttribute(el, FOCUS_GROUP_ATTR, group)
        ));
      }
      if (this.shouldAutofocus) {
        this.handleFocus();
      }
    }
    super.ngAfterViewInit();
  }
  handleFocus(event) {
    if (this.shouldLock) {
      if (this.shouldUnlockAfterAutofocus(event)) {
        setTimeout(() => this.unlockFocus(event));
      } else {
        setTimeout(() => this.lockFocus());
        event?.stopPropagation();
        return;
      }
    }
    super.handleFocus(event);
  }
  handleEscape(event) {
    if (this.shouldLock) {
      this.service.clear(this.config.group);
    }
    super.handleEscape(event);
  }
  /**
   * When the handleFocus is called without an actual event, it's coming from Autofocus.
   * In this case we unlock the focusable children in case there's a focusable child that
   * was unlocked before.
   *
   * We keep this private to not polute the API.
   */
  shouldUnlockAfterAutofocus(event) {
    return !event && this.service.hasPersistedFocus(this.host, this.config);
  }
  /**
   * Add the tabindex attribute to the focusable children elements
   */
  addTabindexToChildren(i = 0) {
    if (this.shouldLock) {
      this.isLocked = i === -1;
      if (!(this.hasFocusableChildren && i === 0) || i === 0) {
        this.focusable.forEach((el) => this.renderer.setAttribute(el, "tabindex", i.toString()));
      }
    }
  }
  /**
   * Utility method, returns all focusable children for the host element.
   *
   * We keep this private to not polute the API.
   */
  get hasFocusableChildren() {
    return this.service.hasFocusableChildren(this.host);
  }
  /**
   * Returns the focusable children of the host element. If the host element
   * is configured to be locked, the query is restricted to child elements
   * with a tabindex !== `-1`.
   *
   * We keep this private to not polute the API.
   */
  get focusable() {
    return this.service.findFocusable(this.host, this.shouldLock, UNLOCK_HIDDEN_ELEMENTS);
  }
};
_LockFocusDirective.\u0275fac = function LockFocusDirective_Factory(t) {
  return new (t || _LockFocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LockFocusService), \u0275\u0275directiveInject(Renderer2));
};
_LockFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _LockFocusDirective,
  hostVars: 4,
  hostBindings: function LockFocusDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown.enter", function LockFocusDirective_keydown_enter_HostBindingHandler($event) {
        return ctx.handleEnter($event);
      })("keydown.space", function LockFocusDirective_keydown_space_HostBindingHandler($event) {
        return ctx.handleEnter($event);
      })("click", function LockFocusDirective_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("focus-lock", ctx.shouldLock)("is-locked", ctx.isLocked);
    }
  },
  outputs: {
    unlock: "unlock"
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var LockFocusDirective = _LockFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LockFocusDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: LockFocusService
  }, {
    type: Renderer2
  }], {
    shouldLock: [{
      type: HostBinding,
      args: ["class.focus-lock"]
    }],
    isLocked: [{
      type: HostBinding,
      args: ["class.is-locked"]
    }],
    unlock: [{
      type: Output
    }],
    handleEnter: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _KeyboardFocusService = class _KeyboardFocusService extends LockFocusService {
};
_KeyboardFocusService.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275KeyboardFocusService_BaseFactory;
  return function KeyboardFocusService_Factory(t) {
    return (\u0275KeyboardFocusService_BaseFactory || (\u0275KeyboardFocusService_BaseFactory = \u0275\u0275getInheritedFactory(_KeyboardFocusService)))(t || _KeyboardFocusService);
  };
})();
_KeyboardFocusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _KeyboardFocusService,
  factory: _KeyboardFocusService.\u0275fac,
  providedIn: "root"
});
var KeyboardFocusService = _KeyboardFocusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyboardFocusService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _FocusDirective = class _FocusDirective extends LockFocusDirective {
  constructor(elementRef, service, renderer) {
    super(elementRef, service, renderer);
    this.elementRef = elementRef;
    this.service = service;
    this.renderer = renderer;
    this.defaultConfig = {};
    this.config = {};
  }
};
_FocusDirective.\u0275fac = function FocusDirective_Factory(t) {
  return new (t || _FocusDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyboardFocusService), \u0275\u0275directiveInject(Renderer2));
};
_FocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FocusDirective,
  selectors: [["", "cxFocus", ""]],
  inputs: {
    config: [InputFlags.None, "cxFocus", "config"]
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var FocusDirective = _FocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusDirective, [{
    type: Directive,
    args: [{
      selector: "[cxFocus]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: KeyboardFocusService
  }, {
    type: Renderer2
  }], {
    config: [{
      type: Input,
      args: ["cxFocus"]
    }]
  });
})();
var directives = [
  // PersistFocusDirective,
  // VisibleFocusDirective,
  // BlockFocusDirective,
  // AutoFocusDirective,
  // EscapeFocusDirective,
  // LockFocusDirective,
  // TrapFocusDirective,
  // TabFocusDirective,
  FocusDirective
];
var _KeyboardFocusModule = class _KeyboardFocusModule {
};
_KeyboardFocusModule.\u0275fac = function KeyboardFocusModule_Factory(t) {
  return new (t || _KeyboardFocusModule)();
};
_KeyboardFocusModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _KeyboardFocusModule
});
_KeyboardFocusModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var KeyboardFocusModule = _KeyboardFocusModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyboardFocusModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [...directives],
      exports: [...directives]
    }]
  }], null, null);
})();
var _MockKeyboardFocusDirective = class _MockKeyboardFocusDirective {
  constructor() {
    this.config = {};
  }
};
_MockKeyboardFocusDirective.\u0275fac = function MockKeyboardFocusDirective_Factory(t) {
  return new (t || _MockKeyboardFocusDirective)();
};
_MockKeyboardFocusDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MockKeyboardFocusDirective,
  selectors: [["", "cxFocus", ""]],
  inputs: {
    config: [InputFlags.None, "cxFocus", "config"]
  }
});
var MockKeyboardFocusDirective = _MockKeyboardFocusDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MockKeyboardFocusDirective, [{
    type: Directive,
    args: [{
      selector: "[cxFocus]"
    }]
  }], null, {
    config: [{
      type: Input,
      args: ["cxFocus"]
    }]
  });
})();
var _KeyboardFocusTestingModule = class _KeyboardFocusTestingModule {
};
_KeyboardFocusTestingModule.\u0275fac = function KeyboardFocusTestingModule_Factory(t) {
  return new (t || _KeyboardFocusTestingModule)();
};
_KeyboardFocusTestingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _KeyboardFocusTestingModule
});
_KeyboardFocusTestingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var KeyboardFocusTestingModule = _KeyboardFocusTestingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyboardFocusTestingModule, [{
    type: NgModule,
    args: [{
      declarations: [MockKeyboardFocusDirective],
      exports: [MockKeyboardFocusDirective]
    }]
  }], null, null);
})();
var DIALOG_TYPE;
(function(DIALOG_TYPE2) {
  DIALOG_TYPE2["POPOVER"] = "POPOVER";
  DIALOG_TYPE2["POPOVER_CENTER"] = "POPOVER_CENTER";
  DIALOG_TYPE2["POPOVER_CENTER_BACKDROP"] = "POPOVER_CENTER_BACKDROP";
  DIALOG_TYPE2["DIALOG"] = "DIALOG";
  DIALOG_TYPE2["SIDEBAR_START"] = "SIDEBAR_START";
  DIALOG_TYPE2["SIDEBAR_END"] = "SIDEBAR_END";
})(DIALOG_TYPE || (DIALOG_TYPE = {}));
var LaunchRenderStrategy = class LaunchRenderStrategy2 {
  constructor(document2, rendererFactory) {
    this.document = document2;
    this.rendererFactory = rendererFactory;
    this.renderedCallers = [];
    this.dialogClasses = ["d-block", "fade", "modal", "show"];
    this.popoverClasses = ["cx-dialog-popover"];
    this.popoverCenterClasses = ["cx-dialog-popover-center"];
    this.popoverCenterBackdropClasses = ["cx-dialog-popover-center-backdrop"];
    this.sidebarEndClasses = ["cx-sidebar-end"];
    this.sidebarStartClasses = ["cx-sidebar-start"];
    this.renderer = rendererFactory.createRenderer(null, null);
  }
  /**
   * Determines if element should render
   *
   * @param caller
   * @param config
   */
  shouldRender(caller, config) {
    return Boolean(config.component) && (this.renderedCallers.some((el) => el.caller === caller) ? !!config.multi : true);
  }
  applyClasses(component, dialogType) {
    let classes = [];
    switch (dialogType) {
      case DIALOG_TYPE.DIALOG:
        classes = this.dialogClasses;
        this.renderer.addClass(this.document.body, "modal-open");
        break;
      case DIALOG_TYPE.POPOVER:
        classes = this.popoverClasses;
        break;
      case DIALOG_TYPE.POPOVER_CENTER:
        classes = this.popoverCenterClasses;
        break;
      case DIALOG_TYPE.POPOVER_CENTER_BACKDROP:
        classes = this.popoverCenterBackdropClasses;
        break;
      case DIALOG_TYPE.SIDEBAR_END:
        classes = this.sidebarEndClasses;
        break;
      case DIALOG_TYPE.SIDEBAR_START:
        classes = this.sidebarStartClasses;
        break;
    }
    for (const newClass of classes) {
      this.renderer.addClass(component.location.nativeElement, newClass);
    }
  }
  /**
   * Method to call when rendered element is destroyed
   * The element will be removed from the list of rendered elements
   *
   * @param caller
   * @param _config optional parameters used in children strategies
   */
  remove(caller, config) {
    this.renderedCallers = this.renderedCallers.filter((el) => el.caller !== caller);
    if (config?.dialogType === DIALOG_TYPE.DIALOG) {
      this.renderer.removeClass(this.document.body, "modal-open");
    }
  }
  getPriority() {
    return -10;
  }
};
LaunchRenderStrategy = __decorate([__param(0, Inject(DOCUMENT))], LaunchRenderStrategy);
var BREAKPOINT;
(function(BREAKPOINT2) {
  BREAKPOINT2["xs"] = "xs";
  BREAKPOINT2["sm"] = "sm";
  BREAKPOINT2["md"] = "md";
  BREAKPOINT2["lg"] = "lg";
  BREAKPOINT2["xl"] = "xl";
})(BREAKPOINT || (BREAKPOINT = {}));
var _LayoutConfig = class _LayoutConfig {
};
_LayoutConfig.\u0275fac = function LayoutConfig_Factory(t) {
  return new (t || _LayoutConfig)();
};
_LayoutConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LayoutConfig,
  factory: function LayoutConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _LayoutConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var LayoutConfig = _LayoutConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var _LaunchDialogService = class _LaunchDialogService {
  get data$() {
    return this._dataSubject.asObservable();
  }
  constructor(renderStrategies, layoutConfig2) {
    this.renderStrategies = renderStrategies;
    this.layoutConfig = layoutConfig2;
    this._dialogClose = new BehaviorSubject(void 0);
    this._dataSubject = new BehaviorSubject(void 0);
    this.logger = inject(LoggerService);
    this.renderStrategies = this.renderStrategies || [];
  }
  /**
   * Open the dialog
   *
   * @param caller LAUNCH_CALLER
   * @param openElement button's Element ref
   * @param vcr View Container Ref of the container for inline rendering
   * @param data optional data which could be passed to dialog
   */
  openDialog(caller, openElement, vcr, data) {
    const component = this.launch(caller, vcr, data);
    if (component) {
      return combineLatest([component, this.dialogClose]).pipe(filter(([, close]) => close !== void 0), tap(([comp]) => {
        openElement?.nativeElement.focus();
        this.clear(caller);
        comp?.destroy();
      }), map(([comp]) => comp));
    }
  }
  /**
   * Render the element based on the strategy from the launch configuration
   *
   * @param caller LAUNCH_CALLER
   * @param vcr View Container Ref of the container for inline rendering
   */
  launch(caller, vcr, data) {
    const config = this.findConfiguration(caller);
    if (config) {
      const renderer = this.getStrategy(config);
      if (renderer) {
        this._dialogClose.next(void 0);
        this._dataSubject.next(data);
        return renderer.render(config, caller, vcr);
      }
    } else if (isDevMode()) {
      this.logger.warn("No configuration provided for caller " + caller);
    }
  }
  /**
   * Opens dialog and subscribe in the service. Should be used if the trigger component might get destroyed while the component is open.
   *
   * @param caller Launch Caller
   * @param openElement Element to open
   * @param data Data to provide to the rendered element
   */
  openDialogAndSubscribe(caller, openElement, data) {
    this.openDialog(caller, openElement, void 0, data)?.pipe(take(1)).subscribe();
  }
  /**
   * Util method to remove element from rendered elements list
   *
   * @param caller LAUNCH_CALLER
   */
  clear(caller) {
    const config = this.findConfiguration(caller);
    if (config) {
      const renderer = this.getStrategy(config);
      if (renderer) {
        renderer.remove(caller, config);
      }
    }
  }
  get dialogClose() {
    return this._dialogClose.asObservable();
  }
  closeDialog(reason) {
    this._dialogClose.next(reason);
  }
  /**
   * Returns the configuration for the caller
   *
   * @param caller LAUNCH_CALLER
   */
  findConfiguration(caller) {
    if (this.layoutConfig?.launch) {
      return this.layoutConfig.launch[caller];
    }
    return void 0;
  }
  /**
   * Returns the render strategy based on the configuration
   *
   * @param config Configuration for launch
   */
  getStrategy(config) {
    return resolveApplicable(this.renderStrategies, [config]);
  }
};
_LaunchDialogService.\u0275fac = function LaunchDialogService_Factory(t) {
  return new (t || _LaunchDialogService)(\u0275\u0275inject(LaunchRenderStrategy), \u0275\u0275inject(LayoutConfig));
};
_LaunchDialogService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LaunchDialogService,
  factory: _LaunchDialogService.\u0275fac,
  providedIn: "root"
});
var LaunchDialogService = _LaunchDialogService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LaunchDialogService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LaunchRenderStrategy]
    }]
  }, {
    type: LayoutConfig
  }], null);
})();
var _AnonymousConsentManagementBannerComponent = class _AnonymousConsentManagementBannerComponent {
  constructor(anonymousConsentsService, vcr, launchDialogService) {
    this.anonymousConsentsService = anonymousConsentsService;
    this.vcr = vcr;
    this.launchDialogService = launchDialogService;
    this.subscriptions = new Subscription();
    this.bannerVisible$ = this.anonymousConsentsService.isBannerVisible();
  }
  viewDetails() {
    this.hideBanner();
    const dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT", void 0, this.vcr);
    if (dialog) {
      this.subscriptions.add(dialog.subscribe());
    }
  }
  allowAll() {
    this.subscriptions.add(this.anonymousConsentsService.giveAllConsents().pipe(tap(() => this.hideBanner())).subscribe());
  }
  hideBanner() {
    this.anonymousConsentsService.toggleBannerDismissed(true);
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
};
_AnonymousConsentManagementBannerComponent.\u0275fac = function AnonymousConsentManagementBannerComponent_Factory(t) {
  return new (t || _AnonymousConsentManagementBannerComponent)(\u0275\u0275directiveInject(AnonymousConsentsService), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(LaunchDialogService));
};
_AnonymousConsentManagementBannerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AnonymousConsentManagementBannerComponent,
  selectors: [["cx-anonymous-consent-management-banner"]],
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [1, "anonymous-consent-banner", 3, "ngClass"], [1, "container"], [1, "row"], [1, "col-lg-7", "col-xs-12"], [1, "cx-banner-title"], [1, "cx-banner-description"], [1, "col-lg-5", "col-xs-12", "cx-banner-buttons"], [1, "btn", "btn-secondary", 3, "click"], [1, "btn", "btn-primary", 3, "click"]],
  template: function AnonymousConsentManagementBannerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, AnonymousConsentManagementBannerComponent_ng_container_0_Template, 18, 15, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.bannerVisible$));
    }
  },
  dependencies: [NgClass, NgIf, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var AnonymousConsentManagementBannerComponent = _AnonymousConsentManagementBannerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnonymousConsentManagementBannerComponent, [{
    type: Component,
    args: [{
      selector: "cx-anonymous-consent-management-banner",
      template: `<ng-container *ngIf="bannerVisible$ | async as bannerVisible">
  <div
    [ngClass]="{ 'anonymous-consent-banner-hidden': !bannerVisible }"
    class="anonymous-consent-banner"
  >
    <div class="container">
      <div class="row">
        <div class="col-lg-7 col-xs-12">
          <div class="cx-banner-title">
            {{ 'anonymousConsents.banner.title' | cxTranslate }}
          </div>
          <div class="cx-banner-description">
            {{ 'anonymousConsents.banner.description' | cxTranslate }}
          </div>
        </div>

        <div class="col-lg-5 col-xs-12 cx-banner-buttons">
          <button class="btn btn-secondary" (click)="viewDetails()">
            {{ 'anonymousConsents.banner.viewDetails' | cxTranslate }}
          </button>
          <button class="btn btn-primary" (click)="allowAll()">
            {{ 'anonymousConsents.banner.allowAll' | cxTranslate }}
          </button>
        </div>
      </div>
    </div>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: AnonymousConsentsService
  }, {
    type: ViewContainerRef
  }, {
    type: LaunchDialogService
  }], null);
})();
var _InlineRenderStrategy = class _InlineRenderStrategy extends LaunchRenderStrategy {
  constructor(document2, rendererFactory, componentFactoryResolver) {
    super(document2, rendererFactory);
    this.document = document2;
    this.rendererFactory = rendererFactory;
    this.componentFactoryResolver = componentFactoryResolver;
    this.logger = inject(LoggerService);
  }
  /**
   * Renders the component from the configuration in the view container ref
   *
   * @param config
   * @param caller
   * @param vcr
   */
  render(config, caller, vcr) {
    if (vcr && this.shouldRender(caller, config)) {
      const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
      const component = vcr.createComponent(template);
      if (config?.dialogType) {
        this.applyClasses(component, config?.dialogType);
      }
      this.renderedCallers.push({
        caller,
        element: vcr.element,
        component
      });
      return of(component);
    } else if (isDevMode()) {
      if (!vcr) {
        this.logger.warn(`No view container ref provided for ${caller}`);
      } else {
        this.logger.warn(`Element for ${caller} already rendered. To allow multi rendering add property multi: true.`);
      }
    }
  }
  hasMatch(config) {
    return Boolean(config.inline);
  }
};
_InlineRenderStrategy.\u0275fac = function InlineRenderStrategy_Factory(t) {
  return new (t || _InlineRenderStrategy)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(RendererFactory2), \u0275\u0275inject(ComponentFactoryResolver$1));
};
_InlineRenderStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _InlineRenderStrategy,
  factory: _InlineRenderStrategy.\u0275fac,
  providedIn: "root"
});
var InlineRenderStrategy = _InlineRenderStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineRenderStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: RendererFactory2
  }, {
    type: ComponentFactoryResolver$1
  }], null);
})();
var _InlineRootRenderStrategy = class _InlineRootRenderStrategy extends LaunchRenderStrategy {
  constructor(document2, rendererFactory, componentFactoryResolver, injector) {
    super(document2, rendererFactory);
    this.document = document2;
    this.rendererFactory = rendererFactory;
    this.componentFactoryResolver = componentFactoryResolver;
    this.injector = injector;
  }
  get hostComponent() {
    return this.injector.get(ApplicationRef)?.components?.[0];
  }
  render(config, caller) {
    if (this.shouldRender(caller, config)) {
      const componentFactory = this.componentFactoryResolver.resolveComponentFactory(config.component);
      const contentInjector = Injector.create({
        providers: []
      });
      const componentRef = componentFactory.create(contentInjector);
      this.injector.get(ApplicationRef)?.attachView(componentRef.hostView);
      this.renderer.appendChild(this.hostComponent?.location.nativeElement, componentRef.location.nativeElement);
      if (config?.dialogType) {
        this.applyClasses(componentRef, config?.dialogType);
      }
      this.renderedCallers.push({
        caller,
        component: componentRef
      });
      return of(componentRef);
    }
  }
  hasMatch(config) {
    return Boolean(config.inlineRoot);
  }
};
_InlineRootRenderStrategy.\u0275fac = function InlineRootRenderStrategy_Factory(t) {
  return new (t || _InlineRootRenderStrategy)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(RendererFactory2), \u0275\u0275inject(ComponentFactoryResolver$1), \u0275\u0275inject(Injector));
};
_InlineRootRenderStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _InlineRootRenderStrategy,
  factory: _InlineRootRenderStrategy.\u0275fac,
  providedIn: "root"
});
var InlineRootRenderStrategy = _InlineRootRenderStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineRootRenderStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: RendererFactory2
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Injector
  }], null);
})();
var OutletPosition;
(function(OutletPosition2) {
  OutletPosition2["REPLACE"] = "replace";
  OutletPosition2["BEFORE"] = "before";
  OutletPosition2["AFTER"] = "after";
})(OutletPosition || (OutletPosition = {}));
var AVOID_STACKED_OUTLETS = false;
var USE_STACKED_OUTLETS = true;
var OutletContextData = class {
};
var _OutletService = class _OutletService {
  constructor() {
    this.templatesRefs = {
      [OutletPosition.BEFORE]: /* @__PURE__ */ new Map(),
      [OutletPosition.REPLACE]: /* @__PURE__ */ new Map(),
      [OutletPosition.AFTER]: /* @__PURE__ */ new Map()
    };
  }
  /**
   * @param templateOrFactory A `ComponentFactory` that inserts a component dynamically.
   */
  add(outlet, templateOrFactory, position = OutletPosition.REPLACE) {
    const store = this.templatesRefs[position];
    if (store) {
      const existing = store.get(outlet) || [];
      const newValue = existing.concat([templateOrFactory]);
      store.set(outlet, newValue);
    }
  }
  /**
   *
   * Returns a single object or multiple objects for the given outlet reference,
   * depending on the `stacked` argument.
   *
   * @param outlet The outlet reference
   * @param position the outlet position, `OutletPosition.before`, `OutletPosition.AFTER` or `OutletPosition.REPLACE`
   * @param stacked Indicates whether an array of outlet components is returned
   */
  get(outlet, position = OutletPosition.REPLACE, stacked = AVOID_STACKED_OUTLETS) {
    const store = this.templatesRefs[position] || this.templatesRefs[OutletPosition.REPLACE];
    const templateRef = store.get(outlet);
    if (templateRef && !stacked) {
      return templateRef[0];
    }
    return templateRef;
  }
  remove(outlet, position = OutletPosition.REPLACE, value) {
    const store = this.templatesRefs[position] || this.templatesRefs[OutletPosition.REPLACE];
    this.removeValueOrAll(store, outlet, value);
  }
  removeValueOrAll(store, outlet, value) {
    if (!value && store.has(outlet)) {
      store.delete(outlet);
    } else if (value && store.has(outlet)) {
      let existing = store.get(outlet);
      existing = existing?.filter((val) => val !== value);
      if (existing) {
        store.set(outlet, existing);
      }
    }
  }
};
_OutletService.\u0275fac = function OutletService_Factory(t) {
  return new (t || _OutletService)();
};
_OutletService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _OutletService,
  factory: _OutletService.\u0275fac,
  providedIn: "root"
});
var OutletService = _OutletService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutletService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _OutletRefDirective = class _OutletRefDirective {
  constructor(tpl, outletService) {
    this.tpl = tpl;
    this.outletService = outletService;
  }
  ngOnInit() {
    this.outletService.add(this.cxOutletRef, this.tpl, this.cxOutletPos);
  }
  ngOnDestroy() {
    this.outletService.remove(this.cxOutletRef, this.cxOutletPos, this.tpl);
  }
};
_OutletRefDirective.\u0275fac = function OutletRefDirective_Factory(t) {
  return new (t || _OutletRefDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(OutletService));
};
_OutletRefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _OutletRefDirective,
  selectors: [["", "cxOutletRef", ""]],
  inputs: {
    cxOutletRef: "cxOutletRef",
    cxOutletPos: "cxOutletPos"
  }
});
var OutletRefDirective = _OutletRefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutletRefDirective, [{
    type: Directive,
    args: [{
      selector: "[cxOutletRef]"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: OutletService
  }], {
    cxOutletRef: [{
      type: Input
    }],
    cxOutletPos: [{
      type: Input
    }]
  });
})();
var _OutletRefModule = class _OutletRefModule {
};
_OutletRefModule.\u0275fac = function OutletRefModule_Factory(t) {
  return new (t || _OutletRefModule)();
};
_OutletRefModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _OutletRefModule
});
_OutletRefModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var OutletRefModule = _OutletRefModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutletRefModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [OutletRefDirective],
      exports: [OutletRefDirective]
    }]
  }], null, null);
})();
var _OutletRendererService = class _OutletRendererService {
  constructor() {
    this.outletRefs = new BehaviorSubject(/* @__PURE__ */ new Map());
  }
  /**
   * Dynamically render the templates in the specified array
   *
   * @param outlet
   */
  render(outlet) {
    if (this.outletRefs.value.size !== 0) {
      this.outletRefs.value.get(outlet)?.render();
    }
  }
  /**
   * Register outlet to be available to render dynamically
   *
   * @param cxOutlet
   * @param context
   */
  register(cxOutlet, context) {
    this.outletRefs.next(this.outletRefs.value.set(cxOutlet, context));
  }
  /**
   * Returns map of outlets
   *
   */
  getOutletRef(outlet) {
    return this.outletRefs.asObservable().pipe(map((val) => val.get(outlet)), filter(isNotNullable));
  }
};
_OutletRendererService.\u0275fac = function OutletRendererService_Factory(t) {
  return new (t || _OutletRendererService)();
};
_OutletRendererService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _OutletRendererService,
  factory: _OutletRendererService.\u0275fac,
  providedIn: "root"
});
var OutletRendererService = _OutletRendererService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutletRendererService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _IntersectionService = class _IntersectionService {
  constructor(config) {
    this.config = config;
  }
  /**
   * Returns an Observable that emits only once a boolean value whenever
   * the given element has shown in the view port.
   *
   * The returned observable will only emit the first value. The
   * observable must be cleaned up either way, since the value might never emit; it
   * depends on whether the element appears in the view port.
   *
   * @param element - HTML element
   * @param options - Allows to specify an optional root margin, in order to fire before the element shows up in the viewport
   * @param intersectingCondition - Allows to specify an intersecting condition.
   * If this parameter is not set, then the transition state of the element will be verified whenever the element intersects the view port.
   * @returns Element intersects?
   */
  isIntersected(element, options, intersectingCondition) {
    return this.intersects(element, options, intersectingCondition).pipe(first((v) => v === true));
  }
  /**
   * Returns an observable that emits for every change of intersection of a given element.
   *
   * @param element - HTML element
   * @param options - Allows to specify an optional root margin, in order to fire before the element shows up in the viewport
   * @param intersectingCondition - Allows to specify an intersecting condition.
   * If this parameter is not set, then the transition state of the element will be verified whenever the element intersects the view port.
   * @returns Element intersects?
   */
  isIntersecting(element, options, intersectingCondition) {
    return this.intersects(element, options, intersectingCondition);
  }
  /**
   * Indicates whenever the element intersects the view port. An optional margin
   * is used to intersects before the element shows up in the viewport.
   * A value is emitted each time the element intersects.
   */
  intersects(element, options = {}, intersectingCondition) {
    return this.createIntersectionObservable(element, options).pipe(mergeMap((entries) => entries), map((entry) => intersectingCondition ? intersectingCondition(entry) : entry.isIntersecting), distinctUntilChanged());
  }
  createIntersectionObservable(element, options) {
    return new Observable((observer) => {
      const rootMargin = this.getRootMargin(options);
      const intersectOptions = {
        rootMargin,
        threshold: options.threshold
      };
      const intersectionObserver = new IntersectionObserver((entries) => {
        observer.next(entries);
      }, intersectOptions);
      intersectionObserver.observe(element);
      return () => {
        intersectionObserver.disconnect();
      };
    });
  }
  getRootMargin(options = {}) {
    if (options.rootMargin) {
      return options.rootMargin;
    }
    const layoutConfig2 = this.config;
    if (layoutConfig2.deferredLoading && layoutConfig2.deferredLoading.intersectionMargin) {
      return layoutConfig2.deferredLoading.intersectionMargin;
    }
  }
};
_IntersectionService.\u0275fac = function IntersectionService_Factory(t) {
  return new (t || _IntersectionService)(\u0275\u0275inject(LayoutConfig));
};
_IntersectionService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _IntersectionService,
  factory: _IntersectionService.\u0275fac,
  providedIn: "root"
});
var IntersectionService = _IntersectionService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IntersectionService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: LayoutConfig
  }], null);
})();
var _DeferLoaderService = class _DeferLoaderService {
  constructor(platformId, config, intersectionService) {
    this.platformId = platformId;
    this.config = config;
    this.intersectionService = intersectionService;
    this.globalLoadStrategy = config.deferredLoading?.strategy ?? DeferLoadingStrategy.INSTANT;
  }
  /**
   * Defer loading till the element intersects the viewport.
   *
   * We evaluate whether we instantly load the element for different reasons:
   * - we run in SSR mode
   * - there's no global strategy given
   * - the global loading strategy is set to INSTANT loading,
   *   and the loading strategy in the given is not set to DEFER
   * - the loading strategy in the given options is set to INSTANT
   */
  load(element, options) {
    if (this.shouldLoadInstantly((options || {}).deferLoading)) {
      return of(true);
    } else {
      return this.intersectionService.isIntersected(element, options);
    }
  }
  shouldLoadInstantly(elementLoadingStrategy) {
    return isPlatformServer(this.platformId) || elementLoadingStrategy === DeferLoadingStrategy.INSTANT || elementLoadingStrategy !== DeferLoadingStrategy.DEFER && this.globalLoadStrategy === DeferLoadingStrategy.INSTANT;
  }
};
_DeferLoaderService.\u0275fac = function DeferLoaderService_Factory(t) {
  return new (t || _DeferLoaderService)(\u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(LayoutConfig), \u0275\u0275inject(IntersectionService));
};
_DeferLoaderService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DeferLoaderService,
  factory: _DeferLoaderService.\u0275fac,
  providedIn: "root"
});
var DeferLoaderService = _DeferLoaderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DeferLoaderService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: LayoutConfig
  }, {
    type: IntersectionService
  }], null);
})();
var _OutletDirective = class _OutletDirective {
  constructor(vcr, templateRef, outletService, deferLoaderService, outletRendererService) {
    this.vcr = vcr;
    this.templateRef = templateRef;
    this.outletService = outletService;
    this.deferLoaderService = deferLoaderService;
    this.outletRendererService = outletRendererService;
    this.renderedTemplate = [];
    this.renderedComponents = /* @__PURE__ */ new Map();
    this.outletContext$ = new ReplaySubject(1);
    this.loaded = new EventEmitter(true);
    this.cxComponentRefChange = new EventEmitter();
    this.subscription = new Subscription();
  }
  /**
   * Renders view for outlet or defers it, depending on the input `cxOutletDefer`
   */
  render() {
    this.vcr.clear();
    this.renderedTemplate = [];
    this.renderedComponents.clear();
    this.subscription.unsubscribe();
    this.subscription = new Subscription();
    if (this.cxOutletDefer) {
      this.deferLoading();
    } else {
      this.build();
    }
  }
  ngOnChanges(changes) {
    if (changes.cxOutlet) {
      this.render();
      this.outletRendererService.register(this.cxOutlet, this);
    }
    if (changes.cxOutletContext) {
      this.outletContext$.next(this.cxOutletContext);
    }
  }
  deferLoading() {
    this.loaded.emit(false);
    const hostElement = this.getHostElement(this.vcr.element.nativeElement);
    this.subscription.add(this.deferLoaderService.load(hostElement, this.cxOutletDefer).subscribe(() => {
      this.build();
      this.loaded.emit(true);
    }));
  }
  /**
   * Renders view for outlet
   */
  build() {
    this.buildOutlet(OutletPosition.BEFORE);
    this.buildOutlet(OutletPosition.REPLACE);
    this.buildOutlet(OutletPosition.AFTER);
  }
  /**
   * Renders view in a given position for outlet
   */
  buildOutlet(position) {
    let templates = this.outletService.get(this.cxOutlet, position, USE_STACKED_OUTLETS);
    templates = templates?.filter((el) => !this.renderedTemplate.includes(el));
    if (!templates && position === OutletPosition.REPLACE) {
      templates = [this.templateRef];
    }
    if (!Array.isArray(templates)) {
      templates = [templates];
    }
    const components = [];
    templates.forEach((obj) => {
      const component = this.create(obj, position);
      if (component) {
        components.push(component);
      }
    });
    this.renderedComponents.set(position, components);
  }
  /**
   * Renders view based on the given template or component factory
   */
  create(tmplOrFactory, position) {
    this.renderedTemplate.push(tmplOrFactory);
    if (tmplOrFactory instanceof ComponentFactory$1) {
      const component = this.vcr.createComponent(tmplOrFactory, void 0, this.getComponentInjector(position));
      this.cxComponentRefChange.emit(component);
      return component;
    } else if (tmplOrFactory instanceof TemplateRef) {
      const view = this.vcr.createEmbeddedView(tmplOrFactory, {
        $implicit: this.cxOutletContext
      });
      view.markForCheck();
      this.cxComponentRefChange.emit(view);
      return view;
    }
  }
  /**
   * Returns injector with OutletContextData that can be injected to the component
   * rendered in the outlet
   */
  getComponentInjector(position) {
    const contextData = {
      reference: this.cxOutlet,
      position,
      context: this.cxOutletContext,
      context$: this.outletContext$.asObservable()
    };
    return Injector.create({
      providers: [{
        provide: OutletContextData,
        useValue: contextData
      }],
      parent: this.vcr.injector
    });
  }
  /**
   * Returns the closest `HtmlElement`, by iterating over the
   * parent nodes of the given element.
   *
   * We avoid traversing the parent _elements_, as this is blocking
   * ie11 implementations. One of the spare exclusions we make to not
   * supporting ie11.
   *
   * @param element
   */
  getHostElement(element) {
    if (element instanceof HTMLElement) {
      return element;
    }
    return this.getHostElement(element.parentNode);
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.outletContext$.complete();
  }
};
_OutletDirective.\u0275fac = function OutletDirective_Factory(t) {
  return new (t || _OutletDirective)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(OutletService), \u0275\u0275directiveInject(DeferLoaderService), \u0275\u0275directiveInject(OutletRendererService));
};
_OutletDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _OutletDirective,
  selectors: [["", "cxOutlet", ""]],
  inputs: {
    cxOutlet: "cxOutlet",
    cxOutletContext: "cxOutletContext",
    cxOutletDefer: "cxOutletDefer",
    cxComponentRef: "cxComponentRef"
  },
  outputs: {
    loaded: "loaded",
    cxComponentRefChange: "cxComponentRefChange"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var OutletDirective = _OutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutletDirective, [{
    type: Directive,
    args: [{
      selector: "[cxOutlet]"
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: OutletService
  }, {
    type: DeferLoaderService
  }, {
    type: OutletRendererService
  }], {
    cxOutlet: [{
      type: Input
    }],
    cxOutletContext: [{
      type: Input
    }],
    cxOutletDefer: [{
      type: Input
    }],
    loaded: [{
      type: Output
    }],
    cxComponentRef: [{
      type: Input
    }],
    cxComponentRefChange: [{
      type: Output
    }]
  });
})();
var PROVIDE_OUTLET_OPTIONS = new InjectionToken("PROVIDE_OUTLET_OPTIONS");
function provideOutlet(options) {
  return {
    provide: PROVIDE_OUTLET_OPTIONS,
    useValue: options,
    multi: true
  };
}
function registerOutletsFactory(providedOutletOptions, componentFactoryResolver, outletService) {
  const result = () => {
    (providedOutletOptions ?? []).forEach((options) => {
      const factory = componentFactoryResolver.resolveComponentFactory(options.component);
      outletService.add(options.id, factory, options.position ?? OutletPosition.AFTER);
    });
  };
  return result;
}
var _OutletModule = class _OutletModule {
  static forRoot() {
    return {
      ngModule: _OutletModule,
      providers: [{
        provide: APP_INITIALIZER,
        useFactory: registerOutletsFactory,
        deps: [[new Optional(), PROVIDE_OUTLET_OPTIONS], ComponentFactoryResolver$1, OutletService],
        multi: true
      }]
    };
  }
  static forChild() {
    return {
      ngModule: _OutletModule,
      providers: [{
        provide: MODULE_INITIALIZER,
        useFactory: registerOutletsFactory,
        deps: [[new Optional(), PROVIDE_OUTLET_OPTIONS], ComponentFactoryResolver$1, OutletService],
        multi: true
      }]
    };
  }
};
_OutletModule.\u0275fac = function OutletModule_Factory(t) {
  return new (t || _OutletModule)();
};
_OutletModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _OutletModule
});
_OutletModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var OutletModule = _OutletModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutletModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [OutletDirective],
      exports: [OutletDirective]
    }]
  }], null, null);
})();
var _OutletRenderStrategy = class _OutletRenderStrategy extends LaunchRenderStrategy {
  constructor(document2, rendererFactory, outletService, componentFactoryResolver, outletRendererService) {
    super(document2, rendererFactory);
    this.document = document2;
    this.rendererFactory = rendererFactory;
    this.outletService = outletService;
    this.componentFactoryResolver = componentFactoryResolver;
    this.outletRendererService = outletRendererService;
  }
  /**
   * Renders the element in the configured outlet
   *
   * @param config
   * @param caller
   * @param vcr
   */
  render(config, caller) {
    if (this.shouldRender(caller, config)) {
      const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
      this.outletService.add(config.outlet, template, config.position ? config.position : OutletPosition.BEFORE);
      this.outletRendererService.render(config.outlet);
      this.renderedCallers.push({
        caller
      });
      return this.outletRendererService.getOutletRef(config.outlet).pipe(map((outletDirective) => {
        const components = outletDirective.renderedComponents.get(config.position ? config.position : OutletPosition.BEFORE);
        return components.reverse().find((component) => component.componentType === template.componentType);
      }), tap((component) => {
        if (config?.dialogType && component) {
          this.applyClasses(component, config?.dialogType);
        }
      }));
    }
  }
  hasMatch(config) {
    return Boolean(config.outlet);
  }
  remove(caller, config) {
    const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
    this.outletService.remove(config.outlet, config.position ? config.position : OutletPosition.BEFORE, template);
    super.remove(caller, config);
  }
};
_OutletRenderStrategy.\u0275fac = function OutletRenderStrategy_Factory(t) {
  return new (t || _OutletRenderStrategy)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(RendererFactory2), \u0275\u0275inject(OutletService), \u0275\u0275inject(ComponentFactoryResolver$1), \u0275\u0275inject(OutletRendererService));
};
_OutletRenderStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _OutletRenderStrategy,
  factory: _OutletRenderStrategy.\u0275fac,
  providedIn: "root"
});
var OutletRenderStrategy = _OutletRenderStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutletRenderStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: RendererFactory2
  }, {
    type: OutletService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: OutletRendererService
  }], null);
})();
var _RoutingRenderStrategy = class _RoutingRenderStrategy extends LaunchRenderStrategy {
  constructor(document2, rendererFactory, routingService) {
    super(document2, rendererFactory);
    this.document = document2;
    this.rendererFactory = rendererFactory;
    this.routingService = routingService;
  }
  /**
   * Navigates to the route configured for the caller
   */
  render(config, _caller) {
    this.routingService.go(config);
  }
  hasMatch(config) {
    return Boolean(config.cxRoute);
  }
};
_RoutingRenderStrategy.\u0275fac = function RoutingRenderStrategy_Factory(t) {
  return new (t || _RoutingRenderStrategy)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(RendererFactory2), \u0275\u0275inject(RoutingService));
};
_RoutingRenderStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RoutingRenderStrategy,
  factory: _RoutingRenderStrategy.\u0275fac,
  providedIn: "root"
});
var RoutingRenderStrategy = _RoutingRenderStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutingRenderStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: RendererFactory2
  }, {
    type: RoutingService
  }], null);
})();
var _LaunchDialogModule = class _LaunchDialogModule {
  static forRoot() {
    return {
      ngModule: _LaunchDialogModule,
      providers: [{
        provide: LayoutConfig,
        useExisting: Config
      }]
    };
  }
};
_LaunchDialogModule.\u0275fac = function LaunchDialogModule_Factory(t) {
  return new (t || _LaunchDialogModule)();
};
_LaunchDialogModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LaunchDialogModule
});
_LaunchDialogModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: LaunchRenderStrategy,
    useExisting: OutletRenderStrategy,
    multi: true
  }, {
    provide: LaunchRenderStrategy,
    useExisting: InlineRenderStrategy,
    multi: true
  }, {
    provide: LaunchRenderStrategy,
    useExisting: RoutingRenderStrategy,
    multi: true
  }, {
    provide: LaunchRenderStrategy,
    useExisting: InlineRootRenderStrategy,
    multi: true
  }]
});
var LaunchDialogModule = _LaunchDialogModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LaunchDialogModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: LaunchRenderStrategy,
        useExisting: OutletRenderStrategy,
        multi: true
      }, {
        provide: LaunchRenderStrategy,
        useExisting: InlineRenderStrategy,
        multi: true
      }, {
        provide: LaunchRenderStrategy,
        useExisting: RoutingRenderStrategy,
        multi: true
      }, {
        provide: LaunchRenderStrategy,
        useExisting: InlineRootRenderStrategy,
        multi: true
      }]
    }]
  }], null, null);
})();
var ICON_TYPE;
(function(ICON_TYPE2) {
  ICON_TYPE2["ACTIVE"] = "ACTIVE";
  ICON_TYPE2["ADDRESS_BOOK"] = "ADDRESS_BOOK";
  ICON_TYPE2["AMEX"] = "AMEX";
  ICON_TYPE2["CARET_DOWN"] = "CARET_DOWN";
  ICON_TYPE2["CARET_LEFT"] = "CARET_LEFT";
  ICON_TYPE2["CARET_RIGHT"] = "CARET_RIGHT";
  ICON_TYPE2["CARET_UP"] = "CARET_UP";
  ICON_TYPE2["CART"] = "CART";
  ICON_TYPE2["CART_PLUS"] = "CART_PLUS";
  ICON_TYPE2["CART_ARROW_DOWN"] = "CART_ARROW_DOWN";
  ICON_TYPE2["CHECK"] = "CHECK";
  ICON_TYPE2["CIRCLE"] = "CIRCLE";
  ICON_TYPE2["CLIPBOARD_LIST"] = "CLIPBOARD_LIST";
  ICON_TYPE2["CLOCK"] = "CLOCK";
  ICON_TYPE2["CLOSE"] = "CLOSE";
  ICON_TYPE2["COLLAPSE"] = "COLLAPSE";
  ICON_TYPE2["CREDIT_CARD"] = "CREDIT_CARD";
  ICON_TYPE2["DINERS_CLUB"] = "DINERS_CLUB";
  ICON_TYPE2["DOWNLOAD"] = "DOWNLOAD";
  ICON_TYPE2["EMPTY_HEART"] = "EMPTY_HEART";
  ICON_TYPE2["ERROR"] = "ERROR";
  ICON_TYPE2["EXPAND"] = "EXPAND";
  ICON_TYPE2["EXPAND_ARROWS"] = "EXPAND_ARROWS";
  ICON_TYPE2["EYE"] = "EYE";
  ICON_TYPE2["EYE_SLASH"] = "EYE_SLASH";
  ICON_TYPE2["FILE"] = "FILE";
  ICON_TYPE2["FILTER"] = "FILTER";
  ICON_TYPE2["GRID"] = "GRID";
  ICON_TYPE2["HEART"] = "HEART";
  ICON_TYPE2["INFO"] = "INFO";
  ICON_TYPE2["LINK_OUT"] = "LINK_OUT";
  ICON_TYPE2["LIST"] = "LIST";
  ICON_TYPE2["MASTER_CARD"] = "MASTER_CARD";
  ICON_TYPE2["OFF"] = "OFF";
  ICON_TYPE2["ON"] = "ON";
  ICON_TYPE2["ORDER"] = "ORDER";
  ICON_TYPE2["PENCIL"] = "PENCIL";
  ICON_TYPE2["RESET"] = "RESET";
  ICON_TYPE2["REPEAT"] = "REPEAT";
  ICON_TYPE2["SEARCH"] = "SEARCH";
  ICON_TYPE2["SORT"] = "SORT";
  ICON_TYPE2["SORT_AMOUNT_DOWN"] = "SORT_AMOUNT_DOWN";
  ICON_TYPE2["SORT_AMOUNT_UP"] = "SORT_AMOUNT_UP";
  ICON_TYPE2["SORT_DOWN"] = "SORT_DOWN";
  ICON_TYPE2["STAR"] = "STAR";
  ICON_TYPE2["SUCCESS"] = "SUCCESS";
  ICON_TYPE2["TRASH"] = "TRASH";
  ICON_TYPE2["USER_FRIENDS"] = "USER_FRIENDS";
  ICON_TYPE2["VISA"] = "VISA";
  ICON_TYPE2["WARNING"] = "WARNING";
  ICON_TYPE2["HEADSET"] = "HEADSET";
  ICON_TYPE2["ATTACHMENT"] = "ATTACHMENT";
  ICON_TYPE2["UPLOAD"] = "UPLOAD";
  ICON_TYPE2["USER"] = "USER";
  ICON_TYPE2["USER_PLUS"] = "USER_PLUS";
  ICON_TYPE2["ARROW_LEFT"] = "ARROW_LEFT";
  ICON_TYPE2["ARROW_RIGHT"] = "ARROW_RIGHT";
  ICON_TYPE2["ARROW_DOWN"] = "ARROW_DOWN";
  ICON_TYPE2["ARROW_UP"] = "ARROW_UP";
})(ICON_TYPE || (ICON_TYPE = {}));
var _IconConfig = class _IconConfig {
};
_IconConfig.\u0275fac = function IconConfig_Factory(t) {
  return new (t || _IconConfig)();
};
_IconConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _IconConfig,
  factory: function IconConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _IconConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var IconConfig = _IconConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var IconResourceType;
(function(IconResourceType2) {
  IconResourceType2["SVG"] = "svg";
  IconResourceType2["LINK"] = "link";
  IconResourceType2["TEXT"] = "text";
})(IconResourceType || (IconResourceType = {}));
var fontawesomeIconConfig = {
  icon: {
    symbols: {
      ACTIVE: "fas fa-check",
      ADDRESS_BOOK: "far fa-address-book",
      AMEX: "fab fa-cc-amex",
      CARET_DOWN: "fas fa-angle-down",
      CARET_LEFT: "fas fa-angle-left",
      CARET_RIGHT: "fas fa-angle-right",
      CARET_UP: "fas fa-angle-up",
      CART: "fas fa-shopping-cart",
      CART_PLUS: "fas fa-cart-plus",
      CART_ARROW_DOWN: "fas fa-cart-arrow-down",
      CHECK: "fas fa-check",
      CIRCLE: "fas fa-circle",
      CLIPBOARD_LIST: "fas fa-clipboard-list",
      CLOCK: "far fa-clock",
      CLOSE: "fas fa-times",
      COLLAPSE: "fas fa-minus",
      CREDIT_CARD: "fas fa-credit-card",
      DINERS_CLUB: "fab fa-cc-diners-club",
      DOWNLOAD: "fas fa-download",
      EMPTY_HEART: "far fa-heart",
      ERROR: "fas fa-exclamation-circle",
      EXPAND_ARROWS: "fas fa-expand",
      EXPAND: "fas fa-plus",
      EYE_SLASH: "fas fa-eye-slash",
      EYE: "fas fa-eye",
      FILE: "fas fa-file",
      FILTER: "fas fa-filter",
      GRID: "fas fa-th-large",
      HEART: "fas fa-heart",
      INFO: "fas fa-info-circle",
      LINK_OUT: "fas fa-external-link-alt",
      LIST: "fas fa-bars",
      MASTER_CARD: "fab fa-cc-mastercard",
      OFF: "fas fa-toggle-off",
      ON: "fas fa-toggle-on",
      ORDER: "fas fa-clipboard-list",
      PDF_FILE: "fas fa-file-pdf",
      PENCIL: "fas fa-pencil-alt",
      REPEAT: "fas fa-retweet",
      RESET: "fas fa-times-circle",
      SEARCH: "fas fa-search",
      SORT_AMOUNT_DOWN: "fas fa-sort-amount-down",
      SORT_AMOUNT_UP: "fas fa-sort-amount-up",
      SORT_DOWN: "fas fa-sort-down",
      SORT: "fas fa-sort",
      STAR: "fas fa-star",
      SUCCESS: "fas fa-check-circle",
      TRASH: "fas fa-trash",
      USER_FRIENDS: "fas fa-user-friends",
      VISA: "fab fa-cc-visa",
      WARNING: "fas fa-exclamation-triangle",
      HEADSET: "fas fa-headset",
      ATTACHMENT: "fas fa-paperclip",
      UPLOAD: "fas fa-upload",
      USER: "fas fa-user",
      USER_PLUS: "fas fa-user-plus",
      ARROW_LEFT: "fas fa-arrow-left",
      ARROW_RIGHT: "fas  fa-arrow-right",
      ARROW_DOWN: "fas  fa-arrow-down",
      ARROW_UP: "fas  fa-arrow-up"
    },
    resources: [{
      type: IconResourceType.LINK,
      url: ""
    }]
  }
};
var _IconLoaderService = class _IconLoaderService {
  constructor(winRef, iconConfig, sanitizer) {
    this.winRef = winRef;
    this.iconConfig = iconConfig;
    this.sanitizer = sanitizer;
    this.loadedResources = [];
  }
  /**
   * Returns an html fragment which can be added to the DOM in a safe way.
   */
  getHtml(type) {
    if (this.isResourceType(type, IconResourceType.SVG)) {
      const url = this.sanitizer.sanitize(SecurityContext.URL, this.getSvgPath(type) || null);
      if (url) {
        const useElement = this.winRef.document.createElement("use");
        useElement.setAttribute("xlink:href", url);
        const svgElement = this.winRef.document.createElement("svg");
        svgElement.appendChild(useElement);
        return this.sanitizer.bypassSecurityTrustHtml(svgElement.outerHTML);
      }
    }
    if (this.isResourceType(type, IconResourceType.TEXT)) {
      const symbol = this.getSymbol(type);
      if (symbol) {
        const helperDiv = this.winRef.document.createElement("div");
        helperDiv.textContent = symbol;
        return this.sanitizer.bypassSecurityTrustHtml(helperDiv.innerHTML);
      }
    }
  }
  /**
   * Return the direction for which the icon should mirror (ltr vs rtl). The icon direction
   * is configurable, but optional, as only a few icons should be flipped for rtl direction.
   */
  getFlipDirection(type) {
    return this.config?.flipDirection?.[type];
  }
  /**
   *
   * Returns the symbol class(es) for the icon type.
   */
  getStyleClasses(iconType) {
    return this.getSymbol(iconType) || "";
  }
  /**
   * Indicates whether the given `ICON_TYPE` is configured for
   * the given `IconResourceType`.
   */
  isResourceType(iconType, resourceType) {
    return this.config?.resources !== void 0 && !!this.config.resources.find((res) => res.types && res.type === resourceType && res.types.includes(iconType));
  }
  /**
   * Returns the path to the svg link. The link supports path names
   * as well, if the config a[[s been setup to support a svg file path.
   * Additionally, the icon prefix will be taken into account to prefix the
   * icon IDs in the SVG.
   */
  getSvgPath(iconType) {
    const svgResource = this.config?.resources?.find((res) => res.type === IconResourceType.SVG && res.types && res.types.includes(iconType));
    if (svgResource) {
      return svgResource.url ? `${svgResource.url}#${this.getSymbol(iconType)}` : `#${this.getSymbol(iconType)}`;
    }
  }
  /**
   * Loads the resource url (if any) for the given icon.
   * The icon will only be loaded once.
   *
   * NOTE: this is not working when the shadow is used as there's
   * no head element available and the link must be loaded for every
   * web component.
   */
  addLinkResource(iconType) {
    const resource = this.findResource(iconType, IconResourceType.LINK);
    if (resource?.url && !this.loadedResources.includes(resource.url)) {
      this.loadedResources.push(resource.url);
      const sanitizedUrl = this.sanitizer.sanitize(SecurityContext.URL, resource.url);
      if (sanitizedUrl) {
        const head = this.winRef.document.getElementsByTagName("head")[0];
        const link = this.winRef.document.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        link.href = sanitizedUrl;
        head.appendChild(link);
      }
    }
  }
  findResource(iconType, resourceType) {
    if (!this.config?.resources) {
      return;
    }
    let resource = this.config.resources.find((res) => res.type === resourceType && res.types && res.types.includes(iconType));
    if (!resource) {
      resource = this.config.resources.find((res) => res.type === resourceType && !res.types || res.types && res.types.length === 0);
    }
    return resource;
  }
  getSymbol(iconType) {
    if (this.config && this.config.symbols && this.config.symbols[iconType]) {
      return this.config.symbols[iconType];
    }
  }
  get config() {
    return this.iconConfig.icon;
  }
};
_IconLoaderService.\u0275fac = function IconLoaderService_Factory(t) {
  return new (t || _IconLoaderService)(\u0275\u0275inject(WindowRef), \u0275\u0275inject(IconConfig), \u0275\u0275inject(DomSanitizer));
};
_IconLoaderService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _IconLoaderService,
  factory: _IconLoaderService.\u0275fac,
  providedIn: "root"
});
var IconLoaderService = _IconLoaderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconLoaderService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: WindowRef
  }, {
    type: IconConfig
  }, {
    type: DomSanitizer
  }], null);
})();
var DirectionMode;
(function(DirectionMode2) {
  DirectionMode2["LTR"] = "ltr";
  DirectionMode2["RTL"] = "rtl";
})(DirectionMode || (DirectionMode = {}));
var _IconComponent = class _IconComponent {
  /**
   * The cxIcon directive is bound to the icon type. You can feed the `ICON_TYPE` to
   * accomplish a configurable button in the UI.
   */
  set cxIcon(type) {
    this.setIcon(type);
  }
  /**
   * The type input parameter is bound to the icon type. You can feed the `ICON_TYPE` to
   * accomplish a configurable button in the UI.
   */
  set type(type) {
    this.setIcon(type);
  }
  constructor(iconLoader, elementRef, renderer) {
    this.iconLoader = iconLoader;
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  setIcon(type) {
    if (!type || type === "") {
      return;
    }
    this.icon = this.iconLoader.getHtml(type);
    this.addStyleClasses(type);
    this.iconLoader.addLinkResource(type);
    this.flipIcon(type);
  }
  /**
   * The icons supports flipping for some icons to support rtl and ltr directions.
   */
  flipIcon(type) {
    if (!this.iconLoader.getFlipDirection) {
      return;
    }
    const iconDirection = this.iconLoader.getFlipDirection(type);
    this.flipAtLtr = iconDirection === DirectionMode.LTR;
    this.flipAtRtl = iconDirection === DirectionMode.RTL;
  }
  /**
   * Adds the style classes and the link resource (if available).
   */
  addStyleClasses(type) {
    this.renderer.addClass(this.host, "cx-icon");
    this.styleClasses?.forEach((cls) => this.renderer.removeClass(this.host, cls));
    this.styleClasses = this.iconLoader.getStyleClasses(type)?.split(" ");
    this.styleClasses?.forEach((cls) => {
      if (cls !== "") {
        this.renderer.addClass(this.host, cls);
      }
    });
  }
  get host() {
    return this.elementRef.nativeElement;
  }
};
_IconComponent.\u0275fac = function IconComponent_Factory(t) {
  return new (t || _IconComponent)(\u0275\u0275directiveInject(IconLoaderService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_IconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _IconComponent,
  selectors: [["cx-icon"], ["", "cxIcon", ""]],
  hostVars: 4,
  hostBindings: function IconComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("flip-at-rtl", ctx.flipAtRtl)("flip-at-ltr", ctx.flipAtLtr);
    }
  },
  inputs: {
    cxIcon: "cxIcon",
    type: "type"
  },
  ngContentSelectors: _c12,
  decls: 2,
  vars: 1,
  consts: [[3, "outerHTML"]],
  template: function IconComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275element(0, "i", 0);
      \u0275\u0275projection(1);
    }
    if (rf & 2) {
      \u0275\u0275property("outerHTML", ctx.icon, \u0275\u0275sanitizeHtml);
    }
  },
  encapsulation: 2
});
var IconComponent = _IconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconComponent, [{
    type: Component,
    args: [{
      selector: "cx-icon,[cxIcon]",
      template: '<i [outerHTML]="icon"></i><ng-content></ng-content>\n'
    }]
  }], () => [{
    type: IconLoaderService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    cxIcon: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    flipAtRtl: [{
      type: HostBinding,
      args: ["class.flip-at-rtl"]
    }],
    flipAtLtr: [{
      type: HostBinding,
      args: ["class.flip-at-ltr"]
    }]
  });
})();
var defaultIconConfig = {
  icon: {
    flipDirection: {
      CARET_RIGHT: DirectionMode.RTL,
      CARET_LEFT: DirectionMode.RTL
    }
  }
};
var _IconModule = class _IconModule {
};
_IconModule.\u0275fac = function IconModule_Factory(t) {
  return new (t || _IconModule)();
};
_IconModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _IconModule
});
_IconModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [
    provideDefaultConfig(defaultIconConfig),
    // TODO: move the opinionated fontawesome config to a recipe
    provideDefaultConfig(fontawesomeIconConfig)
  ],
  imports: [CommonModule]
});
var IconModule = _IconModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconModule, [{
    type: NgModule,
    args: [{
      declarations: [IconComponent],
      imports: [CommonModule],
      providers: [
        provideDefaultConfig(defaultIconConfig),
        // TODO: move the opinionated fontawesome config to a recipe
        provideDefaultConfig(fontawesomeIconConfig)
      ],
      exports: [IconComponent]
    }]
  }], null, null);
})();
var _MockIconComponent = class _MockIconComponent {
};
_MockIconComponent.\u0275fac = function MockIconComponent_Factory(t) {
  return new (t || _MockIconComponent)();
};
_MockIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MockIconComponent,
  selectors: [["cx-icon"], ["", "cxIcon", ""]],
  inputs: {
    cxIcon: "cxIcon",
    type: "type"
  },
  decls: 1,
  vars: 1,
  template: function MockIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275text(0);
    }
    if (rf & 2) {
      \u0275\u0275textInterpolate(ctx.type || ctx.cxIcon);
    }
  },
  encapsulation: 2
});
var MockIconComponent = _MockIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MockIconComponent, [{
    type: Component,
    args: [{
      selector: "cx-icon,[cxIcon]",
      template: `{{ type || cxIcon }}`
    }]
  }], null, {
    cxIcon: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var mockComponents = [MockIconComponent];
var MockIconLoaderService = class {
  getHtml() {
  }
  getStyleClasses() {
  }
  addStyleClasses() {
  }
  addLinkResource() {
  }
};
var _IconTestingModule = class _IconTestingModule {
};
_IconTestingModule.\u0275fac = function IconTestingModule_Factory(t) {
  return new (t || _IconTestingModule)();
};
_IconTestingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _IconTestingModule
});
_IconTestingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: IconLoaderService,
    useClass: MockIconLoaderService
  }]
});
var IconTestingModule = _IconTestingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconTestingModule, [{
    type: NgModule,
    args: [{
      declarations: mockComponents,
      exports: mockComponents,
      providers: [{
        provide: IconLoaderService,
        useClass: MockIconLoaderService
      }]
    }]
  }], null, null);
})();
var _SpinnerComponent = class _SpinnerComponent {
  constructor() {
  }
};
_SpinnerComponent.\u0275fac = function SpinnerComponent_Factory(t) {
  return new (t || _SpinnerComponent)();
};
_SpinnerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SpinnerComponent,
  selectors: [["cx-spinner"]],
  decls: 4,
  vars: 3,
  consts: [["role", "status", 1, "loader-container"], [1, "loader"]],
  template: function SpinnerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275text(2);
      \u0275\u0275pipe(3, "cxTranslate");
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(3, 1, "spinner.loading"));
    }
  },
  dependencies: [TranslatePipe],
  encapsulation: 2
});
var SpinnerComponent = _SpinnerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SpinnerComponent, [{
    type: Component,
    args: [{
      selector: "cx-spinner",
      template: `<div class="loader-container" role="status">
  <div class="loader">{{ 'spinner.loading' | cxTranslate }}</div>
</div>
`
    }]
  }], () => [], null);
})();
var _ConsentManagementFormComponent = class _ConsentManagementFormComponent {
  constructor() {
    this.consentGiven = false;
    this.requiredConsents = [];
    this.consentChanged = new EventEmitter();
  }
  ngOnInit() {
    if (this.consent) {
      this.consentGiven = Boolean(this.consent.consentState === ANONYMOUS_CONSENT_STATUS.GIVEN);
    } else {
      if (this.consentTemplate && this.consentTemplate.currentConsent) {
        if (this.consentTemplate.currentConsent.consentWithdrawnDate) {
          this.consentGiven = false;
        } else if (this.consentTemplate.currentConsent.consentGivenDate) {
          this.consentGiven = true;
        }
      }
    }
  }
  onConsentChange() {
    this.consentGiven = !this.consentGiven;
    this.consentChanged.emit({
      given: this.consentGiven,
      template: this.consentTemplate
    });
  }
  isRequired(templateId) {
    return templateId ? this.requiredConsents.includes(templateId) : false;
  }
};
_ConsentManagementFormComponent.\u0275fac = function ConsentManagementFormComponent_Factory(t) {
  return new (t || _ConsentManagementFormComponent)();
};
_ConsentManagementFormComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ConsentManagementFormComponent,
  selectors: [["cx-consent-management-form"]],
  inputs: {
    consentTemplate: "consentTemplate",
    requiredConsents: "requiredConsents",
    consent: "consent"
  },
  outputs: {
    consentChanged: "consentChanged"
  },
  decls: 7,
  vars: 5,
  consts: [[1, "form-check"], ["type", "checkbox", 1, "form-check-input", 3, "change", "checked", "name", "disabled"], [1, "form-check-label", "cx-be-bold"], [4, "ngIf"], [1, "form-check-label"]],
  template: function ConsentManagementFormComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "label")(2, "input", 1);
      \u0275\u0275listener("change", function ConsentManagementFormComponent_Template_input_change_2_listener() {
        return ctx.onConsentChange();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "span", 2);
      \u0275\u0275template(4, ConsentManagementFormComponent_ng_container_4_Template, 3, 1, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "span", 4);
      \u0275\u0275text(6);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("checked", ctx.consentGiven)("name", ctx.consentTemplate.id)("disabled", ctx.isRequired(ctx.consentTemplate == null ? null : ctx.consentTemplate.id));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.consentTemplate == null ? null : ctx.consentTemplate.name);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.consentTemplate == null ? null : ctx.consentTemplate.description, " ");
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
var ConsentManagementFormComponent = _ConsentManagementFormComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConsentManagementFormComponent, [{
    type: Component,
    args: [{
      selector: "cx-consent-management-form",
      template: '<div class="form-check">\n  <label>\n    <input\n      type="checkbox"\n      class="form-check-input"\n      (change)="onConsentChange()"\n      [checked]="consentGiven"\n      [name]="consentTemplate.id"\n      [disabled]="isRequired(consentTemplate?.id)"\n    />\n    <span class="form-check-label cx-be-bold">\n      <ng-container *ngIf="consentTemplate?.name">\n        {{ consentTemplate?.name }}\n        <br />\n      </ng-container>\n    </span>\n    <span class="form-check-label">\n      {{ consentTemplate?.description }}\n    </span>\n  </label>\n</div>\n'
    }]
  }], () => [], {
    consentTemplate: [{
      type: Input
    }],
    requiredConsents: [{
      type: Input
    }],
    consent: [{
      type: Input
    }],
    consentChanged: [{
      type: Output
    }]
  });
})();
var _AnonymousConsentDialogComponent = class _AnonymousConsentDialogComponent {
  handleClick(event) {
    if (event.target.tagName === this.el.nativeElement.tagName) {
      this.close("Cross click");
    }
  }
  constructor(config, anonymousConsentsService, el, launchDialogService) {
    this.config = config;
    this.anonymousConsentsService = anonymousConsentsService;
    this.el = el;
    this.launchDialogService = launchDialogService;
    this.role = "dialog";
    this.modal = true;
    this.subscriptions = new Subscription();
    this.showLegalDescription = true;
    this.iconTypes = ICON_TYPE;
    this.requiredConsents = [];
    this.focusConfig = {
      trap: true,
      block: true,
      autofocus: 'input[type="checkbox"]',
      focusOnEscape: true
    };
    if (this.config.anonymousConsents) {
      this.showLegalDescription = this.config.anonymousConsents.showLegalDescriptionInDialog;
      if (this.config.anonymousConsents.requiredConsents) {
        this.requiredConsents = this.config.anonymousConsents.requiredConsents;
      }
    }
  }
  ngOnInit() {
    this.templates$ = this.anonymousConsentsService.getTemplates();
    this.consents$ = this.anonymousConsentsService.getConsents();
    this.loading$ = this.anonymousConsentsService.getLoadTemplatesLoading();
  }
  close(reason) {
    this.launchDialogService.closeDialog(reason);
  }
  rejectAll() {
    this.subscriptions.add(combineLatest([this.templates$, this.consents$]).pipe(take(1), distinctUntilChanged(), tap(([templates, consents]) => templates.forEach((template) => {
      const consent = this.getCorrespondingConsent(template, consents);
      if (consent && this.anonymousConsentsService.isConsentGiven(consent)) {
        if (this.isRequiredConsent(template)) {
          return;
        }
        if (template.id) {
          this.anonymousConsentsService.withdrawConsent(template.id);
        }
      }
    }))).subscribe());
    this.close("rejectAll");
  }
  allowAll() {
    this.subscriptions.add(combineLatest([this.templates$, this.consents$]).pipe(take(1), distinctUntilChanged(), tap(([templates, consents]) => templates.forEach((template) => {
      const consent = this.getCorrespondingConsent(template, consents);
      if (consent && (consent.consentState == null || this.anonymousConsentsService.isConsentWithdrawn(consent))) {
        if (this.isRequiredConsent(template)) {
          return;
        }
        if (template.id) {
          this.anonymousConsentsService.giveConsent(template.id);
        }
      }
    }))).subscribe());
    this.close("allowAll");
  }
  isRequiredConsent(template) {
    return Boolean(template.id && this.config.anonymousConsents?.requiredConsents && this.config.anonymousConsents.requiredConsents.includes(template.id));
  }
  onConsentChange({
    given,
    template
  }) {
    if (template.id) {
      if (given) {
        this.anonymousConsentsService.giveConsent(template.id);
      } else {
        this.anonymousConsentsService.withdrawConsent(template.id);
      }
    }
  }
  getCorrespondingConsent(template, consents = []) {
    for (const consent of consents) {
      if (template.id === consent.templateCode) {
        return consent;
      }
    }
    return null;
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
};
_AnonymousConsentDialogComponent.\u0275fac = function AnonymousConsentDialogComponent_Factory(t) {
  return new (t || _AnonymousConsentDialogComponent)(\u0275\u0275directiveInject(AnonymousConsentsConfig), \u0275\u0275directiveInject(AnonymousConsentsService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LaunchDialogService));
};
_AnonymousConsentDialogComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AnonymousConsentDialogComponent,
  selectors: [["cx-anonymous-consent-dialog"]],
  hostVars: 2,
  hostBindings: function AnonymousConsentDialogComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function AnonymousConsentDialogComponent_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("role", ctx.role)("aria-modal", ctx.modal);
    }
  },
  decls: 6,
  vars: 5,
  consts: [["dialogBody", ""], [1, "cx-anonymous-consent-dialog", 3, "esc", "cxFocus"], [1, "cx-dialog-content"], [4, "ngIf", "ngIfElse"], ["role", "status"], [1, "cx-dialog-header"], ["type", "button", 1, "close", 3, "click"], ["aria-hidden", "true"], [3, "type"], ["class", "cx-dialog-description", 4, "ngIf"], [1, "cx-dialog-buttons"], ["tabindex", "0", 1, "btn-link", "cx-action-link", 3, "click"], ["class", "cx-dialog-body", 4, "ngIf"], [1, "cx-dialog-description"], [1, "cx-dialog-separator", "col-sm-12", "d-xs-block", "d-sm-block", "d-md-none"], [1, "cx-dialog-body"], [4, "ngIf"], ["class", "cx-dialog-row col-sm-12 col-md-6", 4, "ngFor", "ngForOf"], [1, "cx-dialog-row", "col-sm-12", "col-md-6"], [3, "consentChanged", "consentTemplate", "requiredConsents", "consent"]],
  template: function AnonymousConsentDialogComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 1);
      \u0275\u0275listener("esc", function AnonymousConsentDialogComponent_Template_div_esc_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.close("Escape clicked"));
      });
      \u0275\u0275elementStart(1, "div", 2);
      \u0275\u0275template(2, AnonymousConsentDialogComponent_div_2_Template, 2, 0, "div", 3);
      \u0275\u0275pipe(3, "async");
      \u0275\u0275template(4, AnonymousConsentDialogComponent_ng_template_4_Template, 20, 20, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      const dialogBody_r8 = \u0275\u0275reference(5);
      \u0275\u0275property("cxFocus", ctx.focusConfig);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(3, 3, ctx.loading$))("ngIfElse", dialogBody_r8);
    }
  },
  dependencies: [NgForOf, NgIf, IconComponent, SpinnerComponent, ConsentManagementFormComponent, FocusDirective, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var AnonymousConsentDialogComponent = _AnonymousConsentDialogComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnonymousConsentDialogComponent, [{
    type: Component,
    args: [{
      selector: "cx-anonymous-consent-dialog",
      template: `<div
  class="cx-anonymous-consent-dialog"
  [cxFocus]="focusConfig"
  (esc)="close('Escape clicked')"
>
  <div class="cx-dialog-content">
    <div *ngIf="loading$ | async; else dialogBody">
      <cx-spinner></cx-spinner>
    </div>
    <ng-template #dialogBody>
      <div
        role="status"
        [attr.aria-label]="'common.loaded' | cxTranslate"
      ></div>
      <div class="cx-dialog-header">
        <h3>
          {{ 'anonymousConsents.dialog.title' | cxTranslate }}
        </h3>
        <button
          type="button"
          class="close"
          [attr.aria-label]="'common.close' | cxTranslate"
          (click)="close('Cross click')"
        >
          <span aria-hidden="true">
            <cx-icon [type]="iconTypes.CLOSE"></cx-icon>
          </span>
        </button>
      </div>
      <!-- Separator -->
      <div class="cx-dialog-description" *ngIf="showLegalDescription">
        {{ 'anonymousConsents.dialog.legalDescription' | cxTranslate }}
        <div
          class="cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none"
        ></div>
      </div>
      <!-- Actions -->
      <div class="cx-dialog-buttons">
        <a tabindex="0" class="btn-link cx-action-link" (click)="rejectAll()">{{
          'anonymousConsents.dialog.clearAll' | cxTranslate
        }}</a>
        <a tabindex="0" class="btn-link cx-action-link" (click)="allowAll()">{{
          'anonymousConsents.dialog.selectAll' | cxTranslate
        }}</a>
      </div>
      <!-- Modal Body -->
      <div class="cx-dialog-body" *ngIf="templates$ | async as templates">
        <ng-container *ngIf="consents$ | async as consents">
          <div
            class="cx-dialog-row col-sm-12 col-md-6"
            *ngFor="let template of templates"
          >
            <cx-consent-management-form
              [consentTemplate]="template"
              [requiredConsents]="requiredConsents"
              [consent]="getCorrespondingConsent(template, consents)"
              (consentChanged)="onConsentChange($event)"
            ></cx-consent-management-form>
          </div>
        </ng-container>
      </div>
    </ng-template>
  </div>
</div>
`
    }]
  }], () => [{
    type: AnonymousConsentsConfig
  }, {
    type: AnonymousConsentsService
  }, {
    type: ElementRef
  }, {
    type: LaunchDialogService
  }], {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    modal: [{
      type: HostBinding,
      args: ["attr.aria-modal"]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var defaultAnonymousConsentLayoutConfig = {
  launch: {
    ANONYMOUS_CONSENT: {
      inlineRoot: true,
      component: AnonymousConsentDialogComponent,
      dialogType: DIALOG_TYPE.DIALOG
    }
  }
};
var _AnonymousConsentOpenDialogComponent = class _AnonymousConsentOpenDialogComponent {
  constructor(vcr, launchDialogService) {
    this.vcr = vcr;
    this.launchDialogService = launchDialogService;
  }
  openDialog() {
    const dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT", this.openElement, this.vcr);
    if (dialog) {
      dialog.pipe(take(1)).subscribe();
    }
  }
};
_AnonymousConsentOpenDialogComponent.\u0275fac = function AnonymousConsentOpenDialogComponent_Factory(t) {
  return new (t || _AnonymousConsentOpenDialogComponent)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(LaunchDialogService));
};
_AnonymousConsentOpenDialogComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AnonymousConsentOpenDialogComponent,
  selectors: [["cx-anonymous-consent-open-dialog"]],
  viewQuery: function AnonymousConsentOpenDialogComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c22, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.openElement = _t.first);
    }
  },
  decls: 4,
  vars: 3,
  consts: [["open", ""], [1, "btn", "btn-link", 3, "click"]],
  template: function AnonymousConsentOpenDialogComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "button", 1, 0);
      \u0275\u0275listener("click", function AnonymousConsentOpenDialogComponent_Template_button_click_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.openDialog());
      });
      \u0275\u0275text(2);
      \u0275\u0275pipe(3, "cxTranslate");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(3, 1, "anonymousConsents.preferences"), "\n");
    }
  },
  dependencies: [TranslatePipe],
  encapsulation: 2
});
var AnonymousConsentOpenDialogComponent = _AnonymousConsentOpenDialogComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnonymousConsentOpenDialogComponent, [{
    type: Component,
    args: [{
      selector: "cx-anonymous-consent-open-dialog",
      template: `<button #open class="btn btn-link" (click)="openDialog()">
  {{ 'anonymousConsents.preferences' | cxTranslate }}
</button>
`
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: LaunchDialogService
  }], {
    openElement: [{
      type: ViewChild,
      args: ["open"]
    }]
  });
})();
var _AnonymousConsentManagementBannerModule = class _AnonymousConsentManagementBannerModule {
};
_AnonymousConsentManagementBannerModule.\u0275fac = function AnonymousConsentManagementBannerModule_Factory(t) {
  return new (t || _AnonymousConsentManagementBannerModule)();
};
_AnonymousConsentManagementBannerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _AnonymousConsentManagementBannerModule
});
_AnonymousConsentManagementBannerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultAnonymousConsentLayoutConfig), provideDefaultConfig({
    cmsComponents: {
      AnonymousConsentManagementBannerComponent: {
        component: AnonymousConsentManagementBannerComponent,
        deferLoading: DeferLoadingStrategy.INSTANT
      },
      AnonymousConsentOpenDialogComponent: {
        component: AnonymousConsentOpenDialogComponent
      }
    }
  })],
  imports: [CommonModule, I18nModule, KeyboardFocusModule]
});
var AnonymousConsentManagementBannerModule = _AnonymousConsentManagementBannerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnonymousConsentManagementBannerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, KeyboardFocusModule],
      providers: [provideDefaultConfig(defaultAnonymousConsentLayoutConfig), provideDefaultConfig({
        cmsComponents: {
          AnonymousConsentManagementBannerComponent: {
            component: AnonymousConsentManagementBannerComponent,
            deferLoading: DeferLoadingStrategy.INSTANT
          },
          AnonymousConsentOpenDialogComponent: {
            component: AnonymousConsentOpenDialogComponent
          }
        }
      })],
      declarations: [AnonymousConsentManagementBannerComponent, AnonymousConsentOpenDialogComponent],
      exports: [AnonymousConsentManagementBannerComponent, AnonymousConsentOpenDialogComponent]
    }]
  }], null, null);
})();
var PAGE_LAYOUT_HANDLER = new InjectionToken("PageLayoutHandler");
var _BreakpointService = class _BreakpointService {
  constructor(winRef, layoutConfig2, platform) {
    this.winRef = winRef;
    this.layoutConfig = layoutConfig2;
    this.platform = platform;
    this.breakpoint$ = isPlatformBrowser(this.platform) ? this.winRef.resize$.pipe(map((event) => this.getBreakpoint(event.target.innerWidth)), distinctUntilChanged()) : of(this.fallbackBreakpoint);
  }
  /**
   * Returns the breakpoints for the storefront layout.
   *
   * The breakpoints are driven by the `LayoutConfig.breakpoints` and sorted based on
   * the given screen size.
   */
  get breakpoints() {
    if (!this._breakpoints) {
      this._breakpoints = this.resolveBreakpointsFromConfig();
    }
    return this._breakpoints;
  }
  /**
   * Returns the _maximum_ size for the breakpoint, given by the `LayoutConfig.breakpoints`
   * configuration.
   */
  getSize(breakpoint) {
    return this.getMaxSize(breakpoint) ?? // if there's no direct max value or explicit max value
    // we must derive the max value from the previous min
    this.getMinSize(this.breakpoints?.[this.breakpoints.indexOf(breakpoint) + 1]);
  }
  /**
   * Indicates whether the current screen size is smaller than the maximum size of the
   * given breakpoint.
   *
   * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
   * window innerWidth is smaller than the configured size of `BREAKPOINT.md`.
   */
  isDown(breakpoint) {
    return this.breakpoint$.pipe(map((br) => this.breakpoints.slice(0, this.breakpoints.indexOf(breakpoint) + 1).includes(br)));
  }
  /**
   * Indicates whether the current screen size is larger than the minimum size of the
   * given breakpoint.
   *
   * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
   * window innerWidth is larger than the configured size of `BREAKPOINT.sm`.
   */
  isUp(breakpoint) {
    return this.breakpoint$.pipe(map((br) => this.breakpoints.slice(this.breakpoints.indexOf(breakpoint)).includes(br)));
  }
  /**
   * Indicates whether the given breakpoint fits in the current screen size.
   */
  isEqual(breakpoint) {
    return this.breakpoint$.pipe(map((br) => br === breakpoint));
  }
  /**
   * Returns the fallback breakpoint in case no breakpoint can be resolved. This is
   * typically the case when we're on SSR without an actual window.
   *
   * Returns the smallest screen size (mobile first).
   */
  get fallbackBreakpoint() {
    return this.breakpoints?.[0];
  }
  /**
   * Resolves the breakpoints and sorts them according to the configured size.
   *
   * The sort order is by small to large screens.
   */
  resolveBreakpointsFromConfig() {
    const sortByScreenSize = (next, prev) => {
      const nextMinSize = this.getMinSize(next);
      const maxNext = Math.max(nextMinSize ? nextMinSize + 1 : 0, this.getMaxSize(next) || 0);
      const preMinSize = this.getMinSize(prev);
      const maxPrev = Math.max(preMinSize ? preMinSize + 1 : 0, this.getMaxSize(prev) || 0);
      return maxNext < maxPrev ? -1 : 0;
    };
    return Object.keys(this.config).sort(sortByScreenSize);
  }
  /**
   * Returns the _maximum_ size for the breakpoint, given by the
   * `LayoutConfig.breakpoints` configuration. We will try to resolve the
   * max size form the current breakpoint, but if this is not available, we
   * resolve it form the next breakpoint
   */
  getMaxSize(breakpoint) {
    const breakpointConfig = this.config[breakpoint];
    if (!breakpointConfig) {
      return null;
    }
    if (typeof breakpointConfig === "number") {
      return breakpointConfig;
    } else if (breakpointConfig.max) {
      return breakpointConfig.max;
    } else {
      return null;
    }
  }
  getMinSize(breakpoint) {
    return this.config[breakpoint]?.min ?? null;
  }
  /**
   * Returns a `BREAKPOINT` for the given window size.
   *
   * This method tries to match the closest breakpoint for the given
   * window size. We'll fallback to the `largest` size in case the window
   * is greater than the largest configurable breakpoint.
   *
   * The windowWidth should be smaller than the maximum size of any of the
   * screen sizes defined in the `LayoutConfig.breakpoints`.
   */
  getBreakpoint(windowWidth) {
    return this.breakpoints.find((br) => {
      const size = this.getSize(br);
      return size !== null && windowWidth < size;
    }) ?? this.breakpoints?.[this.breakpoints.length - 1];
  }
  /**
   * Helper method to return the breakpoint configuration.
   */
  get config() {
    return this.layoutConfig?.breakpoints || {};
  }
};
_BreakpointService.\u0275fac = function BreakpointService_Factory(t) {
  return new (t || _BreakpointService)(\u0275\u0275inject(WindowRef), \u0275\u0275inject(LayoutConfig), \u0275\u0275inject(PLATFORM_ID));
};
_BreakpointService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _BreakpointService,
  factory: _BreakpointService.\u0275fac,
  providedIn: "root"
});
var BreakpointService = _BreakpointService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: WindowRef
  }, {
    type: LayoutConfig
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var _PageLayoutService = class _PageLayoutService {
  constructor(cms, config, breakpointService, unifiedInjector) {
    this.cms = cms;
    this.config = config;
    this.breakpointService = breakpointService;
    this.unifiedInjector = unifiedInjector;
    this.subscription = new Subscription();
    this.logger = inject(LoggerService);
    this.warnLogMessages = {};
    this.logSlots = {};
    this.subscription.add(this.unifiedInjector.getMulti(PAGE_LAYOUT_HANDLER).subscribe((handlers) => this.handlers = handlers));
  }
  getSlots(section) {
    return combineLatest([this.page$, this.breakpointService.breakpoint$]).pipe(map(([page, breakpoint]) => {
      const pageTemplate = page.template;
      const slots = this.resolveSlots(page, section, breakpoint);
      return {
        slots,
        pageTemplate,
        breakpoint
      };
    }), switchMap(({
      slots,
      pageTemplate,
      breakpoint
    }) => {
      let result = of(slots);
      for (const handler of this.handlers || []) {
        result = handler.handle(result, pageTemplate, section, breakpoint);
      }
      return result;
    }), distinctUntilChanged((a, b) => {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }));
  }
  /**
   * Returns an observable with the last page slot above-the-fold
   * for the given pageTemplate / breakpoint.
   *
   * The page fold is configurable in the `LayoutConfig` for each page layout.
   */
  getPageFoldSlot(pageTemplate) {
    return this.breakpointService.breakpoint$.pipe(map((breakpoint) => {
      if (!this.config.layoutSlots) {
        return void 0;
      }
      const pageTemplateConfig = this.config.layoutSlots[pageTemplate];
      const config = this.getResponsiveSlotConfig(pageTemplateConfig, "pageFold", breakpoint);
      return config ? config.pageFold : void 0;
    }));
  }
  resolveSlots(page, section, breakpoint) {
    const config = this.getSlotConfig(page.template ?? "", "slots", section, breakpoint);
    if (config && config.slots) {
      const pageSlots = page.slots ? Object.keys(page.slots) : [];
      return config.slots.filter((slot) => pageSlots.includes(slot));
    } else if (!section) {
      this.logMissingLayoutConfig(page);
      return page.slots ? Object.keys(page.slots) : [];
    } else {
      this.logMissingLayoutConfig(page, section);
      return [];
    }
  }
  get page$() {
    return this.cms.getCurrentPage().pipe(filter((page) => !!page));
  }
  get templateName$() {
    return this.page$.pipe(map((page) => page.template), filter(isNotUndefined));
  }
  /**
   * load slots from the layout configuration. The breakpoint is used
   * to load a specific configuration for the given breakpoint. If there's
   * no configuration available for the given breakpoint the default slot
   * configuration is returned.
   */
  getSlotConfig(templateUid, configAttribute, section, breakpoint) {
    if (!this.config.layoutSlots) {
      return void 0;
    }
    const pageTemplateConfig = this.config.layoutSlots[templateUid];
    if (section) {
      return this.getSlotConfigForSection(templateUid, configAttribute, section, breakpoint);
    }
    if (pageTemplateConfig) {
      return this.getResponsiveSlotConfig(pageTemplateConfig, configAttribute, breakpoint);
    }
  }
  getSlotConfigForSection(templateUid, configAttribute, section, breakpoint) {
    const pageTemplateConfig = this.config.layoutSlots?.[templateUid];
    if (!pageTemplateConfig || !section) {
      return void 0;
    }
    const sectionConfig = pageTemplateConfig[section] ? pageTemplateConfig[section] : this.config.layoutSlots?.[section];
    if (!sectionConfig) {
      return void 0;
    }
    const responsiveConfig = this.getResponsiveSlotConfig(sectionConfig, configAttribute, breakpoint);
    if (responsiveConfig.hasOwnProperty(configAttribute)) {
      return responsiveConfig;
    } else if (pageTemplateConfig[section].hasOwnProperty(configAttribute)) {
      return pageTemplateConfig[section];
    } else if (this.config.layoutSlots?.[section]) {
      return this.config.layoutSlots[section];
    }
  }
  /**
   * Returns a list of slots for a breakpoint specific configuration
   * If there's no specific configuration for the breakpoint,
   * the closest available configuration will be returned.
   */
  getResponsiveSlotConfig(layoutSlotConfig, configAttribute, breakpoint) {
    let slotConfig = layoutSlotConfig;
    if (!layoutSlotConfig || !breakpoint) {
      return slotConfig;
    }
    if (layoutSlotConfig[breakpoint] && layoutSlotConfig[breakpoint].hasOwnProperty(configAttribute)) {
      return layoutSlotConfig[breakpoint];
    }
    const all = this.breakpointService.breakpoints;
    for (const br of all.slice(0, all.indexOf(breakpoint))) {
      if (layoutSlotConfig[br] && layoutSlotConfig[br].hasOwnProperty(configAttribute)) {
        slotConfig = layoutSlotConfig[br];
      }
    }
    return slotConfig;
  }
  /**
   * In order to help developers, we print some detailed log information in
   * case there's no layout configuration available for the given page template
   * or section. Additionally, the slot positions are printed in the console
   * in a format that can be copied / paste to the configuration.
   */
  logMissingLayoutConfig(page, section) {
    if (!isDevMode()) {
      return;
    }
    if (page.template && !this.logSlots[page.template]) {
      this.logger.info(`Available CMS page slots: '${(page.slots ? Object.keys(page.slots) : []).join(`','`)}'`);
      this.logSlots[page.template] = true;
    }
    const cacheKey = section || page.template;
    if (cacheKey && !this.warnLogMessages[cacheKey]) {
      this.logger.warn(`No layout config found for ${cacheKey}, you can configure a 'LayoutConfig' to control the rendering of page slots.`);
      this.warnLogMessages[cacheKey] = true;
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_PageLayoutService.\u0275fac = function PageLayoutService_Factory(t) {
  return new (t || _PageLayoutService)(\u0275\u0275inject(CmsService), \u0275\u0275inject(LayoutConfig), \u0275\u0275inject(BreakpointService), \u0275\u0275inject(UnifiedInjector));
};
_PageLayoutService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PageLayoutService,
  factory: _PageLayoutService.\u0275fac,
  providedIn: "root"
});
var PageLayoutService = _PageLayoutService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageLayoutService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsService
  }, {
    type: LayoutConfig
  }, {
    type: BreakpointService
  }, {
    type: UnifiedInjector
  }], null);
})();
var _CmsFeaturesService = class _CmsFeaturesService {
  constructor(configInitializer, featureModules) {
    this.configInitializer = configInitializer;
    this.featureModules = featureModules;
    this.componentFeatureMap = /* @__PURE__ */ new Map();
    this.featureInstances = /* @__PURE__ */ new Map();
    this.initFeatureMap();
  }
  initFeatureMap() {
    this.configInitializer.getStable("featureModules").subscribe((config) => {
      this.featureModulesConfig = config.featureModules ?? {};
      for (const [featureName, featureConfig] of Object.entries(this.featureModulesConfig)) {
        if (typeof featureConfig !== "string" && featureConfig?.module && featureConfig?.cmsComponents?.length) {
          for (const component of featureConfig.cmsComponents) {
            this.componentFeatureMap.set(component, featureName);
          }
        }
      }
    });
  }
  /**
   * Check if there is feature module configuration that covers specified
   * component type
   */
  hasFeatureFor(componentType) {
    return this.componentFeatureMap.has(componentType);
  }
  /**
   * Return full CmsComponent mapping defined in feature module
   */
  getCmsMapping(componentType) {
    const feature = this.componentFeatureMap.get(componentType);
    if (!feature) {
      return of(void 0);
    }
    return this.resolveFeatureInstance(feature).pipe(map((featureInstance) => featureInstance.componentsMappings?.[componentType]));
  }
  /**
   * Resolves feature module for provided component type
   *
   * @param componentType
   */
  getModule(componentType) {
    const feature = this.componentFeatureMap.get(componentType);
    if (!feature) {
      return void 0;
    }
    let module;
    this.featureInstances.get(feature)?.subscribe((featureInstance) => {
      module = featureInstance.moduleRef;
    }).unsubscribe();
    return module;
  }
  /**
   * Resolve feature based on feature name, if feature was not yet resolved
   *
   * It will first resolve all module dependencies if defined
   */
  resolveFeatureInstance(featureName) {
    return defer(() => {
      if (!this.featureInstances.has(featureName)) {
        this.featureInstances.set(featureName, this.featureModules.resolveFeature(featureName).pipe(map((moduleRef) => this.createFeatureInstance(moduleRef, featureName)), shareReplay()));
      }
      return this.featureInstances.get(featureName) ?? EMPTY;
    });
  }
  /**
   * Create feature instance from feature's moduleRef
   */
  createFeatureInstance(moduleRef, feature) {
    const featureConfig = this.featureModulesConfig[feature];
    const featureInstance = {
      moduleRef,
      componentsMappings: {}
    };
    const resolvedConfiguration = this.resolveFeatureConfiguration(moduleRef.injector);
    for (const componentType of featureConfig.cmsComponents ?? []) {
      featureInstance.componentsMappings[componentType] = resolvedConfiguration.cmsComponents?.[componentType] ?? {};
    }
    return featureInstance;
  }
  /**
   * Returns configuration provided in feature module
   */
  resolveFeatureConfiguration(featureInjector) {
    const featureConfigChunks = featureInjector.get(ConfigChunk, [], {
      self: true
    });
    const featureDefaultConfigChunks = featureInjector.get(DefaultConfigChunk, [], {
      self: true
    });
    return deepMerge({}, ...featureDefaultConfigChunks ?? [], ...featureConfigChunks ?? []);
  }
};
_CmsFeaturesService.\u0275fac = function CmsFeaturesService_Factory(t) {
  return new (t || _CmsFeaturesService)(\u0275\u0275inject(ConfigInitializerService), \u0275\u0275inject(FeatureModulesService));
};
_CmsFeaturesService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsFeaturesService,
  factory: _CmsFeaturesService.\u0275fac,
  providedIn: "root"
});
var CmsFeaturesService = _CmsFeaturesService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsFeaturesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ConfigInitializerService
  }, {
    type: FeatureModulesService
  }], null);
})();
var _CmsComponentsService = class _CmsComponentsService {
  constructor(config, platformId, featureModules, configInitializer) {
    this.config = config;
    this.platformId = platformId;
    this.featureModules = featureModules;
    this.configInitializer = configInitializer;
    this.missingComponents = [];
    this.mappings = {};
    this.mappingResolvers = /* @__PURE__ */ new Map();
    this.logger = inject(LoggerService);
    this.configInitializer.getStable("cmsComponents").subscribe((cmsConfig) => {
      this.staticCmsConfig = __spreadValues({}, cmsConfig.cmsComponents);
    });
  }
  /**
   * Should be called to make sure all component mappings are determined,
   * especially lazy loaded ones.
   *
   * It's recommended way to make sure all other methods of CmsComponentService
   * will be able to work synchronously for asked component types and avoid risk
   * of potential errors that could be thrown otherwise.
   */
  determineMappings(componentTypes) {
    return defer(() => {
      const featureResolvers = [];
      for (const componentType of componentTypes) {
        if (!this.mappings[componentType]) {
          const staticConfig = (this.staticCmsConfig ?? this.config.cmsComponents)?.[componentType];
          if (this.featureModules.hasFeatureFor(componentType)) {
            featureResolvers.push(
              // we delegate populating this.mappings to feature resolver
              this.getFeatureMappingResolver(componentType, staticConfig)
            );
          } else {
            if (staticConfig) {
              this.mappings[componentType] = staticConfig;
            }
          }
        }
      }
      if (featureResolvers.length) {
        return forkJoin(featureResolvers).pipe(map(() => componentTypes));
      } else {
        return of(componentTypes);
      }
    });
  }
  getFeatureMappingResolver(componentType, staticConfig) {
    if (!this.mappingResolvers.has(componentType)) {
      const mappingResolver$ = this.featureModules.getCmsMapping(componentType).pipe(filter(isNotUndefined), tap((featureComponentMapping) => {
        this.mappings[componentType] = deepMerge({}, featureComponentMapping, staticConfig);
        this.mappingResolvers.delete(componentType);
      }), share());
      this.mappingResolvers.set(componentType, mappingResolver$);
    }
    return this.mappingResolvers.get(componentType);
  }
  /**
   * Returns the feature module for a cms component.
   * It will only work for cms components provided by feature modules.
   *
   * @param componentType
   */
  getModule(componentType) {
    if (this.featureModules.hasFeatureFor(componentType)) {
      return this.featureModules.getModule(componentType);
    }
  }
  /**
   * Return collection of component mapping configuration for specified list of
   * component types.
   *
   * If component mapping can't be determined synchronously, for example, lazy
   * loaded one, it will throw an error.
   *
   * To make sure component mapping is available, determineMappings()
   * should be called and completed first.
   */
  getMapping(componentType) {
    const componentConfig = this.mappings[componentType] ?? (this.staticCmsConfig ?? this.config.cmsComponents)?.[componentType];
    if (isDevMode() && !componentConfig) {
      if (!this.missingComponents.includes(componentType)) {
        this.missingComponents.push(componentType);
        this.logger.warn(`No component implementation found for the CMS component type '${componentType}'.
`, `Make sure you implement a component and register it in the mapper.`);
      }
    }
    return componentConfig;
  }
  /**
   * Checks, if component should be rendered as some components
   * could be disabled for server side renderings
   */
  shouldRender(componentType) {
    const isSSR = isPlatformServer(this.platformId);
    return !(isSSR && this.getMapping(componentType)?.disableSSR);
  }
  /**
   * Return DeferLoadingStrategy for component type.
   */
  getDeferLoadingStrategy(componentType) {
    return (this.staticCmsConfig ?? this.config.cmsComponents)?.[componentType]?.deferLoading;
  }
  /**
   * Get cms driven child routes for components
   */
  getChildRoutes(componentTypes) {
    const configs = [];
    for (const componentType of componentTypes) {
      if (this.shouldRender(componentType)) {
        configs.push(this.getMapping(componentType)?.childRoutes ?? []);
      }
    }
    return this.standardizeChildRoutes(configs);
  }
  /**
   * Returns the static data for the component type.
   */
  getStaticData(componentType) {
    return this.getMapping(componentType)?.data;
  }
  /**
   * Standardizes the format of `childRoutes` config.
   *
   * Some `childRoutes` configs are simple arrays of Routes (without the notion of the parent route).
   * But some configs can be an object with children routes and their parent defined in separate property.
   */
  standardizeChildRoutes(childRoutesConfigs) {
    const result = {
      children: []
    };
    (childRoutesConfigs || []).forEach((config) => {
      if (Array.isArray(config)) {
        result.children?.push(...config);
      } else {
        result.children?.push(...config.children || []);
        if (config.parent) {
          result.parent = config.parent;
        }
      }
    });
    return result;
  }
  /**
   * Get cms driven guards for components
   */
  getGuards(componentTypes) {
    const guards = /* @__PURE__ */ new Set();
    for (const componentType of componentTypes) {
      this.getMapping(componentType)?.guards?.forEach((guard) => guards.add(guard));
    }
    return Array.from(guards);
  }
  /**
   * Get i18n keys associated with components
   */
  getI18nKeys(componentTypes) {
    const i18nKeys = /* @__PURE__ */ new Set();
    for (const componentType of componentTypes) {
      if (this.shouldRender(componentType)) {
        this.getMapping(componentType)?.i18nKeys?.forEach((key) => i18nKeys.add(key));
      }
    }
    return Array.from(i18nKeys);
  }
};
_CmsComponentsService.\u0275fac = function CmsComponentsService_Factory(t) {
  return new (t || _CmsComponentsService)(\u0275\u0275inject(CmsConfig), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(CmsFeaturesService), \u0275\u0275inject(ConfigInitializerService));
};
_CmsComponentsService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsComponentsService,
  factory: _CmsComponentsService.\u0275fac,
  providedIn: "root"
});
var CmsComponentsService = _CmsComponentsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsComponentsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsConfig
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: CmsFeaturesService
  }, {
    type: ConfigInitializerService
  }], null);
})();
var _PageSlotService = class _PageSlotService {
  constructor(cmsComponentsService, platformId, document2) {
    this.cmsComponentsService = cmsComponentsService;
    this.platformId = platformId;
    this.document = document2;
    this.resolvePrerenderedSlots();
  }
  /**
   * Finds all slots visible in the SSR pre-rendered DOM
   */
  resolvePrerenderedSlots() {
    if (isPlatformBrowser(this.platformId)) {
      this.prerenderedSlots = Array.from(this.document.querySelectorAll("cx-page-slot")).filter((el) => el.getBoundingClientRect().top < this.document.documentElement.clientHeight).map((el) => el.getAttribute("position"));
    }
  }
  /**
   * Indicates if certain slot should be rendered instantly.
   *
   * It's especially useful when transitioning from SSR to CSR application,
   * where we don't want to apply deferring logic to slots that are visible
   * to avoid unnecessary flickering.
   */
  shouldNotDefer(slot) {
    if (this.prerenderedSlots?.includes(slot)) {
      this.prerenderedSlots.splice(this.prerenderedSlots.indexOf(slot), 1);
      return true;
    }
    return false;
  }
  /**
   * Returns the defer options for the given component. If the wrapping
   * page slot is prerendered, we would ignore the defer options altogether.
   */
  getComponentDeferOptions(slot, componentType) {
    if (slot && this.shouldNotDefer(slot)) {
      return {
        deferLoading: DeferLoadingStrategy.INSTANT
      };
    }
    const deferLoading = this.cmsComponentsService.getDeferLoadingStrategy(componentType);
    return {
      deferLoading
    };
  }
};
_PageSlotService.\u0275fac = function PageSlotService_Factory(t) {
  return new (t || _PageSlotService)(\u0275\u0275inject(CmsComponentsService), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(DOCUMENT));
};
_PageSlotService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PageSlotService,
  factory: _PageSlotService.\u0275fac,
  providedIn: "root"
});
var PageSlotService = _PageSlotService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageSlotService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsComponentsService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var ComponentEvent = class extends CxEvent {
};
var _ComponentCreateEvent = class _ComponentCreateEvent extends ComponentEvent {
};
_ComponentCreateEvent.type = "ComponentCreate";
var ComponentCreateEvent = _ComponentCreateEvent;
var _ComponentDestroyEvent = class _ComponentDestroyEvent extends ComponentEvent {
};
_ComponentDestroyEvent.type = "ComponentDestroy";
var ComponentDestroyEvent = _ComponentDestroyEvent;
var ComponentHandler = class {
};
var _ComponentHandlerService = class _ComponentHandlerService {
  constructor(handlers) {
    this.handlers = handlers;
    this.logger = inject(LoggerService);
    this.invalidMappings = /* @__PURE__ */ new Set();
  }
  /**
   * Get best matching component handler
   *
   * @param componentMapping
   */
  resolve(componentMapping) {
    const handler = resolveApplicable(this.handlers, [componentMapping]);
    if (isDevMode() && !handler) {
      if (!this.invalidMappings.has(componentMapping)) {
        this.invalidMappings.add(componentMapping);
        this.logger.warn("Can't resolve handler for component mapping: ", componentMapping);
      }
    }
    return handler;
  }
  /**
   * Get launcher for specified component mapping
   *
   * @param componentMapping
   * @param viewContainerRef
   * @param elementInjector
   */
  getLauncher(componentMapping, viewContainerRef, elementInjector, module) {
    return this.resolve(componentMapping)?.launcher(componentMapping, viewContainerRef, elementInjector, module);
  }
};
_ComponentHandlerService.\u0275fac = function ComponentHandlerService_Factory(t) {
  return new (t || _ComponentHandlerService)(\u0275\u0275inject(ComponentHandler, 8));
};
_ComponentHandlerService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ComponentHandlerService,
  factory: _ComponentHandlerService.\u0275fac,
  providedIn: "root"
});
var ComponentHandlerService = _ComponentHandlerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentHandlerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ComponentHandler]
    }]
  }], null);
})();
var CmsComponentData = class {
};
var _ComponentDataProvider = class _ComponentDataProvider {
  constructor(componentsService, cmsService) {
    this.componentsService = componentsService;
    this.cmsService = cmsService;
  }
  /**
   * Return the component data for a component given by the `uid`.
   *
   * If the `type` is provided, static component data (if available) is
   * merged into the component data. The static data is complemented and
   * overridden with data retrieved from the cms service.
   */
  get(uid, type) {
    return defer(() => {
      let staticComponentData;
      if (type) {
        staticComponentData = this.componentsService.getStaticData(type);
      }
      if (uid) {
        if (staticComponentData) {
          return this.cmsService.getComponentData(uid).pipe(map((data) => __spreadValues(__spreadValues({}, staticComponentData), data)), startWith(staticComponentData));
        } else {
          return this.cmsService.getComponentData(uid);
        }
      } else {
        return staticComponentData ? of(staticComponentData) : EMPTY;
      }
    });
  }
};
_ComponentDataProvider.\u0275fac = function ComponentDataProvider_Factory(t) {
  return new (t || _ComponentDataProvider)(\u0275\u0275inject(CmsComponentsService), \u0275\u0275inject(CmsService));
};
_ComponentDataProvider.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ComponentDataProvider,
  factory: _ComponentDataProvider.\u0275fac,
  providedIn: "root"
});
var ComponentDataProvider = _ComponentDataProvider;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentDataProvider, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsComponentsService
  }, {
    type: CmsService
  }], null);
})();
var _CmsInjectorService = class _CmsInjectorService {
  constructor(cmsComponentsService, injector) {
    this.cmsComponentsService = cmsComponentsService;
    this.injector = injector;
  }
  getInjector(type, uid, parentInjector) {
    const configProviders = this.cmsComponentsService.getMapping(type)?.providers ?? [];
    return Injector.create({
      providers: [{
        provide: CmsComponentData,
        useFactory: (dataProvider) => ({
          uid,
          data$: dataProvider.get(uid, type)
        }),
        deps: [ComponentDataProvider]
      }, ...configProviders],
      parent: parentInjector ?? this.injector
    });
  }
};
_CmsInjectorService.\u0275fac = function CmsInjectorService_Factory(t) {
  return new (t || _CmsInjectorService)(\u0275\u0275inject(CmsComponentsService), \u0275\u0275inject(Injector));
};
_CmsInjectorService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsInjectorService,
  factory: _CmsInjectorService.\u0275fac,
  providedIn: "root"
});
var CmsInjectorService = _CmsInjectorService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsInjectorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsComponentsService
  }, {
    type: Injector
  }], null);
})();
var _ComponentWrapperDirective = class _ComponentWrapperDirective {
  constructor(vcr, cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector, eventService) {
    this.vcr = vcr;
    this.cmsComponentsService = cmsComponentsService;
    this.injector = injector;
    this.dynamicAttributeService = dynamicAttributeService;
    this.renderer = renderer;
    this.componentHandler = componentHandler;
    this.cmsInjector = cmsInjector;
    this.eventService = eventService;
    this.cxComponentRef = new EventEmitter();
  }
  ngOnInit() {
    this.cmsComponentsService.determineMappings([this.cxComponentWrapper.flexType ?? ""]).subscribe(() => {
      if (this.cmsComponentsService.shouldRender(this.cxComponentWrapper.flexType ?? "")) {
        this.launchComponent();
      }
    });
  }
  launchComponent() {
    const componentMapping = this.cmsComponentsService.getMapping(this.cxComponentWrapper.flexType ?? "");
    if (!componentMapping) {
      return;
    }
    this.launcherResource = this.componentHandler.getLauncher(componentMapping, this.vcr, this.cmsInjector.getInjector(this.cxComponentWrapper.flexType ?? "", this.cxComponentWrapper.uid ?? "", this.injector), this.cmsComponentsService.getModule(this.cxComponentWrapper.flexType ?? ""))?.pipe(filter(isNotUndefined), tap(({
      elementRef,
      componentRef
    }) => {
      this.cmpRef = componentRef;
      this.cxComponentRef.emit(componentRef);
      this.dispatchEvent(ComponentCreateEvent, elementRef);
      this.decorate(elementRef);
      this.injector.get(ChangeDetectorRef).markForCheck();
    }), finalize(() => this.dispatchEvent(ComponentDestroyEvent))).subscribe();
  }
  /**
   * Dispatch the component event.
   *
   * The event is dispatched during creation and removal of the component.
   */
  dispatchEvent(event, elementRef) {
    const payload = {
      typeCode: this.cxComponentWrapper.typeCode,
      id: this.cxComponentWrapper.uid
    };
    if (event === ComponentCreateEvent) {
      payload.host = elementRef?.nativeElement;
    }
    this.eventService.dispatch(payload, event);
  }
  decorate(elementRef) {
    this.dynamicAttributeService.addAttributesToComponent(elementRef.nativeElement, this.renderer, this.cxComponentWrapper);
  }
  ngOnDestroy() {
    if (this.launcherResource) {
      this.launcherResource.unsubscribe();
    }
  }
};
_ComponentWrapperDirective.\u0275fac = function ComponentWrapperDirective_Factory(t) {
  return new (t || _ComponentWrapperDirective)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(CmsComponentsService), \u0275\u0275directiveInject(Injector), \u0275\u0275directiveInject(DynamicAttributeService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ComponentHandlerService), \u0275\u0275directiveInject(CmsInjectorService), \u0275\u0275directiveInject(EventService));
};
_ComponentWrapperDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _ComponentWrapperDirective,
  selectors: [["", "cxComponentWrapper", ""]],
  inputs: {
    cxComponentWrapper: "cxComponentWrapper"
  },
  outputs: {
    cxComponentRef: "cxComponentRef"
  }
});
var ComponentWrapperDirective = _ComponentWrapperDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentWrapperDirective, [{
    type: Directive,
    args: [{
      selector: "[cxComponentWrapper]"
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: CmsComponentsService
  }, {
    type: Injector
  }, {
    type: DynamicAttributeService
  }, {
    type: Renderer2
  }, {
    type: ComponentHandlerService
  }, {
    type: CmsInjectorService
  }, {
    type: EventService
  }], {
    cxComponentWrapper: [{
      type: Input
    }],
    cxComponentRef: [{
      type: Output
    }]
  });
})();
var _PageSlotComponent = class _PageSlotComponent {
  /**
   * The position represents the unique key for a page slot on a single page, but can
   * be reused cross pages.
   *
   * The position is used to find the CMS components for the page slot. It is also
   * added as an additional CSS class so that layout can be applied.
   */
  set position(value) {
    this.position$.next(value);
  }
  get position() {
    return this.position$.value;
  }
  constructor(cmsService, dynamicAttributeService, renderer, elementRef, cd, pageSlotService) {
    this.cmsService = cmsService;
    this.dynamicAttributeService = dynamicAttributeService;
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.cd = cd;
    this.pageSlotService = pageSlotService;
    this.isPageFold = false;
    this.isPending = true;
    this.hasComponents = false;
    this.position$ = new BehaviorSubject(void 0);
    this.slot$ = this.position$.pipe(filter(isNotUndefined), switchMap((position) => this.cmsService.getContentSlot(position)), distinctUntilChanged(this.isDistinct));
    this.components$ = this.slot$.pipe(map((slot) => slot?.components ?? []));
    this.subscription = new Subscription();
    this.pendingComponentCount = 0;
  }
  ngOnInit() {
    this.subscription.add(this.slot$.pipe(tap((slot) => this.decorate(slot))).subscribe((value) => {
      this.components = value?.components || [];
      this.cd.markForCheck();
    }));
  }
  decorate(slot) {
    let cls = this.class || "";
    if (this.lastPosition && cls.indexOf(this.lastPosition) > -1) {
      cls = cls.replace(this.lastPosition, "");
    }
    if (this.position$.value) {
      cls += ` ${this.position$.value}`;
      this.lastPosition = this.position$.value;
    }
    this.pending = slot?.components?.length || 0;
    this.hasComponents = slot?.components ? slot?.components?.length > 0 : false;
    if (cls && cls !== this.class) {
      this.class = cls;
    }
    if (slot) {
      this.dynamicAttributeService.addAttributesToSlot(this.elementRef.nativeElement, this.renderer, slot);
    }
  }
  /**
   * Sets the pending count for the page slot components. Once all pending components are
   * loaded, the `isPending` flag is updated, so that the associated class can be updated
   */
  set pending(count) {
    this.pendingComponentCount = count;
    this.isPending = this.pendingComponentCount > 0;
  }
  get pending() {
    return this.pendingComponentCount;
  }
  /*
   * Is triggered when a component is added to the view. This is used to
   * update the pending count
   */
  isLoaded(loadState) {
    if (loadState) {
      this.pending--;
      this.cd.markForCheck();
    }
  }
  /**
   * The `DeferLoadingStrategy` indicates whether the component should be
   * rendered instantly or whether it should be deferred.
   */
  getComponentDeferOptions(componentType) {
    return this.pageSlotService.getComponentDeferOptions(this.position, componentType);
  }
  isDistinct(old, current) {
    return Boolean(current.components && old.components && old.components.length === current.components.length && !old.components.find((el, index) => el.uid !== current.components?.[index].uid));
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
};
_PageSlotComponent.\u0275fac = function PageSlotComponent_Factory(t) {
  return new (t || _PageSlotComponent)(\u0275\u0275directiveInject(CmsService), \u0275\u0275directiveInject(DynamicAttributeService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(PageSlotService));
};
_PageSlotComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PageSlotComponent,
  selectors: [["cx-page-slot"], ["", "cx-page-slot", ""]],
  hostVars: 9,
  hostBindings: function PageSlotComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("position", ctx.position);
      \u0275\u0275classMap(ctx.class);
      \u0275\u0275classProp("page-fold", ctx.isPageFold)("cx-pending", ctx.isPending)("has-components", ctx.hasComponents);
    }
  },
  inputs: {
    position: "position",
    class: "class",
    isPageFold: "isPageFold",
    hasComponents: "hasComponents"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [3, "cxOutlet", "cxOutletContext"], [4, "ngFor", "ngForOf"], [3, "loaded", "cxOutlet", "cxOutletContext", "cxOutletDefer"], [3, "cxComponentWrapper"]],
  template: function PageSlotComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, PageSlotComponent_0_Template, 1, 4, null, 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.position);
    }
  },
  dependencies: [NgForOf, NgIf, OutletDirective, ComponentWrapperDirective],
  encapsulation: 2,
  changeDetection: 0
});
var PageSlotComponent = _PageSlotComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageSlotComponent, [{
    type: Component,
    args: [{
      selector: "cx-page-slot,[cx-page-slot]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<ng-template\n  *ngIf="position"\n  [cxOutlet]="position"\n  [cxOutletContext]="{ components$: components$ }"\n>\n  <ng-container *ngFor="let component of components">\n    <ng-template\n      *ngIf="component.flexType"\n      [cxOutlet]="component.flexType"\n      [cxOutletContext]="{ component: component }"\n      [cxOutletDefer]="getComponentDeferOptions(component.flexType)"\n      (loaded)="isLoaded($event)"\n    >\n      <ng-container [cxComponentWrapper]="component"></ng-container>\n    </ng-template>\n  </ng-container>\n</ng-template>\n'
    }]
  }], () => [{
    type: CmsService
  }, {
    type: DynamicAttributeService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: PageSlotService
  }], {
    position: [{
      type: HostBinding,
      args: ["attr.position"]
    }, {
      type: Input
    }],
    class: [{
      type: Input
    }, {
      type: HostBinding
    }],
    isPageFold: [{
      type: HostBinding,
      args: ["class.page-fold"]
    }, {
      type: Input
    }],
    isPending: [{
      type: HostBinding,
      args: ["class.cx-pending"]
    }],
    hasComponents: [{
      type: HostBinding,
      args: ["class.has-components"]
    }, {
      type: Input
    }]
  });
})();
var _PageTemplateDirective = class _PageTemplateDirective {
  /**
   * Adds a style class to the host element based on the cms page template, unless
   * the class is given as an input.
   *
   * The host element is either the actual host, or the parent element in case this
   * is used inside an `ng-template`.
   */
  set setTemplate(template) {
    if (template && template !== "") {
      this.useTemplateFromInput = true;
      this.addStyleClass(template);
    } else if (this.useTemplateFromInput) {
      this.clear();
    }
  }
  constructor(pageLayoutService, elementRef, templateRef, cd) {
    this.pageLayoutService = pageLayoutService;
    this.elementRef = elementRef;
    this.templateRef = templateRef;
    this.cd = cd;
    this.subscription = new Subscription();
  }
  ngOnInit() {
    if (!this.useTemplateFromInput) {
      this.subscription.add(this.pageLayoutService.templateName$.subscribe((template) => this.addStyleClass(template)));
    }
  }
  /**
   * Adds the page template as a style class to the given element. If any
   * page template was added before, we clean it up.
   *
   * We'll not use hostBinding for the style class, as it will potential drop
   * an existing class name on the host. This is why we need to work with
   * the lower level change detection api.
   */
  addStyleClass(template, el) {
    this.clear(el);
    if (template) {
      this.currentTemplate = template;
      (el ?? this.host).classList.add(this.currentTemplate);
      this.cd.markForCheck();
    }
  }
  /**
   * Cleans up the class host binding, if a template class was assigned before.
   */
  clear(el) {
    if (this.currentTemplate) {
      (el ?? this.host).classList?.remove(this.currentTemplate);
      this.cd.markForCheck();
    }
  }
  /**
   * Returns the host element (`HTMLElement`).
   *
   * If the directive is used on an `ng-template`, we take the parent element,
   * to ensure that we're not ending up with a comment.
   */
  get host() {
    return !!this.templateRef ? this.templateRef.elementRef.nativeElement.parentElement : this.elementRef.nativeElement;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_PageTemplateDirective.\u0275fac = function PageTemplateDirective_Factory(t) {
  return new (t || _PageTemplateDirective)(\u0275\u0275directiveInject(PageLayoutService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(TemplateRef, 8), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_PageTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PageTemplateDirective,
  selectors: [["", "cxPageTemplateStyle", ""]],
  inputs: {
    setTemplate: [InputFlags.None, "cxPageTemplateStyle", "setTemplate"]
  }
});
var PageTemplateDirective = _PageTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[cxPageTemplateStyle]"
    }]
  }], () => [{
    type: PageLayoutService
  }, {
    type: ElementRef
  }, {
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    setTemplate: [{
      type: Input,
      args: ["cxPageTemplateStyle"]
    }]
  });
})();
var _PageLayoutComponent = class _PageLayoutComponent {
  set section(value) {
    this.section$.next(value);
  }
  constructor(pageLayoutService) {
    this.pageLayoutService = pageLayoutService;
    this.section$ = new BehaviorSubject(void 0);
    this.templateName$ = this.pageLayoutService.templateName$;
    this.layoutName$ = this.section$.pipe(switchMap((section) => section ? of(section) : this.templateName$));
    this.slots$ = this.section$.pipe(switchMap((section) => this.pageLayoutService.getSlots(section)));
    this.pageFoldSlot$ = this.templateName$.pipe(switchMap((templateName) => this.pageLayoutService.getPageFoldSlot(templateName)), distinctUntilChanged());
  }
};
_PageLayoutComponent.\u0275fac = function PageLayoutComponent_Factory(t) {
  return new (t || _PageLayoutComponent)(\u0275\u0275directiveInject(PageLayoutService));
};
_PageLayoutComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PageLayoutComponent,
  selectors: [["cx-page-layout"]],
  inputs: {
    section: "section"
  },
  ngContentSelectors: _c12,
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [3, "cxPageTemplateStyle", "cxOutlet", "cxOutletContext"], [3, "position", "isPageFold", 4, "ngFor", "ngForOf"], [3, "position", "isPageFold"]],
  template: function PageLayoutComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, PageLayoutComponent_0_Template, 1, 7, null, 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.layoutName$));
    }
  },
  dependencies: [NgForOf, NgIf, OutletDirective, PageSlotComponent, PageTemplateDirective, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var PageLayoutComponent = _PageLayoutComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageLayoutComponent, [{
    type: Component,
    args: [{
      selector: "cx-page-layout",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<ng-template\n  *ngIf="layoutName$ | async as layoutName"\n  [cxPageTemplateStyle]="layoutName"\n  [cxOutlet]="layoutName"\n  [cxOutletContext]="{\n    templateName$: templateName$,\n    slots$: slots$,\n    section$: section$\n  }"\n>\n  <ng-content></ng-content>\n\n  <cx-page-slot\n    *ngFor="let slot of slots$ | async"\n    [position]="slot"\n    [isPageFold]="slot === (pageFoldSlot$ | async)"\n  ></cx-page-slot>\n</ng-template>\n'
    }]
  }], () => [{
    type: PageLayoutService
  }], {
    section: [{
      type: Input
    }]
  });
})();
var _CmsGuardsService = class _CmsGuardsService {
  constructor(cmsComponentsService, unifiedInjector) {
    this.cmsComponentsService = cmsComponentsService;
    this.unifiedInjector = unifiedInjector;
  }
  cmsPageCanActivate(componentTypes, route, state) {
    const guards = this.cmsComponentsService.getGuards(componentTypes);
    if (guards.length) {
      const canActivateObservables = guards.map((guard) => this.canActivateGuard(guard, route, state));
      return concat(...canActivateObservables).pipe(skipWhile((canActivate) => canActivate === true), endWith(true), first());
    } else {
      return of(true);
    }
  }
  canActivateGuard(guardClass, route, state) {
    const guard = getLastValueSync(this.unifiedInjector.get(guardClass));
    if (isCanActivate(guard)) {
      return wrapIntoObservable(guard.canActivate(route, state)).pipe(first());
    } else {
      throw new Error("Invalid CanActivate guard in cmsMapping");
    }
  }
};
_CmsGuardsService.\u0275fac = function CmsGuardsService_Factory(t) {
  return new (t || _CmsGuardsService)(\u0275\u0275inject(CmsComponentsService), \u0275\u0275inject(UnifiedInjector));
};
_CmsGuardsService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsGuardsService,
  factory: _CmsGuardsService.\u0275fac,
  providedIn: "root"
});
var CmsGuardsService = _CmsGuardsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsGuardsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsComponentsService
  }, {
    type: UnifiedInjector
  }], null);
})();
function wrapIntoObservable(value) {
  if (isObservable(value)) {
    return value;
  }
  if (isPromise3(value)) {
    return from(Promise.resolve(value));
  }
  return of(value);
}
function isPromise3(obj) {
  return !!obj && typeof obj.then === "function";
}
function isCanActivate(guard) {
  return guard && isFunction2(guard.canActivate);
}
function isFunction2(v) {
  return typeof v === "function";
}
var _CmsRoutesImplService = class _CmsRoutesImplService {
  constructor(router, cmsComponentsService, cmsGuardsService) {
    this.router = router;
    this.cmsComponentsService = cmsComponentsService;
    this.cmsGuardsService = cmsGuardsService;
  }
  cmsRouteExists(url) {
    const isCmsDrivenRoute = url.startsWith("/");
    if (!isCmsDrivenRoute) {
      return false;
    }
    const routePath = url.substring(1);
    return isCmsDrivenRoute && !!this.router.config.find((route) => route.data && route.data.cxCmsRouteContext && route.path === routePath);
  }
  /**
   * Contains Cms driven routing logic intended for use use in guards, especially in canActivate method.
   *
   * Will return true, when logic wont have to modify routing (so canActivate could be easily resolved to true)
   * or will return false, when routing configuration was updated and redirection to newly generated route was initiated.
   *
   * @param pageContext
   * @param currentUrl
   */
  handleCmsRoutesInGuard(pageContext, componentTypes, currentUrl, currentPageLabel) {
    if (this.cmsRouteExists(currentPageLabel)) {
      return true;
    }
    const childRoutesConfig = this.cmsComponentsService.getChildRoutes(componentTypes);
    if (childRoutesConfig?.children?.length) {
      if (this.updateRouting(pageContext, currentPageLabel, childRoutesConfig)) {
        this.router.navigateByUrl(currentUrl);
        return false;
      }
    }
    return true;
  }
  updateRouting(pageContext, pageLabel, childRoutesConfig) {
    if (pageContext.type === PageType.CONTENT_PAGE && pageLabel.startsWith("/") && pageLabel.length > 1) {
      const children = this.wrapCmsGuardsRecursively(childRoutesConfig.children ?? []);
      const newRoute = {
        path: pageLabel.substring(1),
        component: PageLayoutComponent,
        children,
        data: deepMerge({}, childRoutesConfig?.parent?.data ?? {}, {
          cxCmsRouteContext: {
            type: pageContext.type,
            id: pageLabel
          }
        })
      };
      this.router.resetConfig([newRoute, ...this.router.config]);
      return true;
    }
    return false;
  }
  /**
   * Traverses recursively the given Routes and wraps each `canActivate`
   * guard of each Route with a special `CanActivateFn` function.
   *
   * This special wrapper function allows for resolving
   * those guards by the Angular Router using the `UnifiedInjector`
   * instead of only root injector.
   *
   * This allows Angular Router to inject the guards (and their dependencies)
   * even when they are provided only in a child injector of a lazy-loaded module.
   */
  wrapCmsGuardsRecursively(routes) {
    return routes.map((route) => {
      if (route.children) {
        route.children = this.wrapCmsGuardsRecursively(route.children);
      }
      if (route?.canActivate?.length) {
        route.canActivate = route.canActivate.map((guard) => this.wrapCmsGuard(guard));
      }
      return route;
    });
  }
  /**
   * Returns a wrapper function `CanActivateFn` (https://angular.io/api/router/CanActivateFn)
   * that injects the given guard instance and runs its method `.canActivate()`.
   *
   * It allows to inject the guard's instance (and it's dependencies)
   * even if it's 'provided only in a child injector of a lazy-loaded module.
   */
  wrapCmsGuard(guardClass) {
    return (route, state) => {
      return this.cmsGuardsService.canActivateGuard(guardClass, route, state);
    };
  }
};
_CmsRoutesImplService.\u0275fac = function CmsRoutesImplService_Factory(t) {
  return new (t || _CmsRoutesImplService)(\u0275\u0275inject(Router), \u0275\u0275inject(CmsComponentsService), \u0275\u0275inject(CmsGuardsService));
};
_CmsRoutesImplService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsRoutesImplService,
  factory: _CmsRoutesImplService.\u0275fac,
  providedIn: "root"
});
var CmsRoutesImplService = _CmsRoutesImplService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsRoutesImplService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Router
  }, {
    type: CmsComponentsService
  }, {
    type: CmsGuardsService
  }], null);
})();
var _CmsRoutesService = class _CmsRoutesService {
};
_CmsRoutesService.\u0275fac = function CmsRoutesService_Factory(t) {
  return new (t || _CmsRoutesService)();
};
_CmsRoutesService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsRoutesService,
  factory: function CmsRoutesService_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _CmsRoutesService)();
    } else {
      r = \u0275\u0275inject(CmsRoutesImplService);
    }
    return r;
  },
  providedIn: "root"
});
var CmsRoutesService = _CmsRoutesService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsRoutesService, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: CmsRoutesImplService
    }]
  }], null, null);
})();
var _CmsI18nService = class _CmsI18nService {
  constructor(cmsComponentsService, translation, translationChunk) {
    this.cmsComponentsService = cmsComponentsService;
    this.translation = translation;
    this.translationChunk = translationChunk;
  }
  loadForComponents(componentTypes) {
    const i18nKeys = this.cmsComponentsService.getI18nKeys(componentTypes);
    const i18nChunks = /* @__PURE__ */ new Set();
    for (const key of i18nKeys) {
      i18nChunks.add(this.translationChunk.getChunkNameForKey(key));
    }
    this.translation.loadChunks(Array.from(i18nChunks));
  }
};
_CmsI18nService.\u0275fac = function CmsI18nService_Factory(t) {
  return new (t || _CmsI18nService)(\u0275\u0275inject(CmsComponentsService), \u0275\u0275inject(TranslationService), \u0275\u0275inject(TranslationChunkService));
};
_CmsI18nService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsI18nService,
  factory: _CmsI18nService.\u0275fac,
  providedIn: "root"
});
var CmsI18nService = _CmsI18nService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsI18nService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsComponentsService
  }, {
    type: TranslationService
  }, {
    type: TranslationChunkService
  }], null);
})();
var _CmsPageGuardService = class _CmsPageGuardService {
  constructor(semanticPathService, cmsService, cmsRoutes, cmsI18n, cmsGuards, cmsComponentsService, routing) {
    this.semanticPathService = semanticPathService;
    this.cmsService = cmsService;
    this.cmsRoutes = cmsRoutes;
    this.cmsI18n = cmsI18n;
    this.cmsGuards = cmsGuards;
    this.cmsComponentsService = cmsComponentsService;
    this.routing = routing;
  }
  /**
   * Takes CMS components types in the current CMS page, triggers (configurable) side effects and returns a boolean - whether the route can be activated.
   *
   * Based on `cmsComponents` config for the components in the page:
   * - Evaluates components' guards; if one of them emits false or UrlTree - the route cannot be activated or redirects to the given UrlTree, respectively.
   * - If all components' guards emitted true, then the route can be activated
   * - Then we trigger loading of configured i18n chunks in parallel
   * - And we register the configured children routes of cms components
   *
   * @param pageContext current cms page context
   * @param pageData cms page data
   * @param route activated route snapshot
   * @param state router state snapshot
   *
   * @returns boolean observable - whether the route can be activated
   */
  canActivatePage(pageContext, pageData, route, state) {
    return this.cmsService.getPageComponentTypes(pageContext).pipe(take(1), switchMap((componentTypes) => this.cmsComponentsService.determineMappings(componentTypes)), switchMap((componentTypes) => this.cmsGuards.cmsPageCanActivate(componentTypes, route, state).pipe(withLatestFrom(of(componentTypes)))), tap(([canActivate, componentTypes]) => {
      if (canActivate === true) {
        this.cmsI18n.loadForComponents(componentTypes);
      }
    }), map(([canActivate, componentTypes]) => {
      const pageLabel = pageData.label || pageContext.id;
      if (canActivate === true && !route?.data?.cxCmsRouteContext) {
        return this.cmsRoutes.handleCmsRoutesInGuard(pageContext, componentTypes, state.url, pageLabel);
      }
      return canActivate;
    }));
  }
  /**
   * Activates the "NOT FOUND" cms page.
   *
   * It loads cms page data for the "NOT FOUND" page and puts it in the state of the the requested page label.
   * Then it processes its CMS components with the method `canActivatePage()` of this service. For more, see its docs.
   */
  canActivateNotFoundPage(pageContext, route, state) {
    const notFoundLabel = this.semanticPathService.get("notFound");
    if (!notFoundLabel) {
      return of(false);
    }
    const notFoundCmsPageContext = {
      type: PageType.CONTENT_PAGE,
      id: notFoundLabel
    };
    return this.cmsService.getPage(notFoundCmsPageContext).pipe(switchMap((notFoundPage) => {
      if (notFoundPage) {
        return this.cmsService.getPageIndex(notFoundCmsPageContext).pipe(tap((notFoundIndex) => {
          this.cmsService.setPageFailIndex(pageContext, notFoundIndex);
          this.routing.changeNextPageContext(notFoundCmsPageContext);
        }), switchMap((notFoundIndex) => this.cmsService.getPageIndex(pageContext).pipe(
          // we have to wait for page index update
          filter((index) => index === notFoundIndex)
        )), switchMap(() => this.canActivatePage(pageContext, notFoundPage, route, state)));
      }
      return of(false);
    }));
  }
};
_CmsPageGuardService.\u0275fac = function CmsPageGuardService_Factory(t) {
  return new (t || _CmsPageGuardService)(\u0275\u0275inject(SemanticPathService), \u0275\u0275inject(CmsService), \u0275\u0275inject(CmsRoutesService), \u0275\u0275inject(CmsI18nService), \u0275\u0275inject(CmsGuardsService), \u0275\u0275inject(CmsComponentsService), \u0275\u0275inject(RoutingService));
};
_CmsPageGuardService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsPageGuardService,
  factory: _CmsPageGuardService.\u0275fac,
  providedIn: "root"
});
var CmsPageGuardService = _CmsPageGuardService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsPageGuardService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: SemanticPathService
  }, {
    type: CmsService
  }, {
    type: CmsRoutesService
  }, {
    type: CmsI18nService
  }, {
    type: CmsGuardsService
  }, {
    type: CmsComponentsService
  }, {
    type: RoutingService
  }], null);
})();
var _CmsPageGuard = class _CmsPageGuard {
  constructor(routingService, cmsService, protectedRoutesGuard, service, routingConfig) {
    this.routingService = routingService;
    this.cmsService = cmsService;
    this.protectedRoutesGuard = protectedRoutesGuard;
    this.service = service;
    this.routingConfig = routingConfig;
  }
  /**
   * Tries to load the CMS page data for the anticipated route and returns:
   * - `true` - if it can be activated
   * - `false` - if it cannot be activated
   * - `UrlTree` - if user should be redirected to a given `UrlTree`
   *
   * If the route can be activated, it fires additional calculations on the CMS components present on this CMS page,
   * based on their configuration (`cmsComponents` config).
   *
   * For more, see docs of the `CmsPageGuardService.canActivatePage`.
   */
  canActivate(route, state) {
    return this.protectedRoutesGuard.canActivate(route).pipe(switchMap((canActivate) => canActivate === true ? this.routingService.getNextPageContext().pipe(filter(isNotUndefined), take(1), switchMap((pageContext) => this.cmsService.getPage(pageContext, this.shouldReload()).pipe(first(), switchMap((pageData) => pageData ? this.service.canActivatePage(pageContext, pageData, route, state) : this.service.canActivateNotFoundPage(pageContext, route, state))))) : of(canActivate)));
  }
  /**
   * Returns whether we should reload the CMS page data, even when it was loaded before.
   */
  shouldReload() {
    return this.routingConfig.getLoadStrategy() !== "once";
  }
};
_CmsPageGuard.guardName = "CmsPageGuard";
_CmsPageGuard.\u0275fac = function CmsPageGuard_Factory(t) {
  return new (t || _CmsPageGuard)(\u0275\u0275inject(RoutingService), \u0275\u0275inject(CmsService), \u0275\u0275inject(ProtectedRoutesGuard), \u0275\u0275inject(CmsPageGuardService), \u0275\u0275inject(RoutingConfigService));
};
_CmsPageGuard.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CmsPageGuard,
  factory: _CmsPageGuard.\u0275fac,
  providedIn: "root"
});
var CmsPageGuard = _CmsPageGuard;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsPageGuard, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RoutingService
  }, {
    type: CmsService
  }, {
    type: ProtectedRoutesGuard
  }, {
    type: CmsPageGuardService
  }, {
    type: RoutingConfigService
  }], null);
})();
var _DefaultComponentHandler = class _DefaultComponentHandler {
  hasMatch(componentMapping) {
    return typeof componentMapping.component === "function";
  }
  getPriority() {
    return -50;
  }
  launcher(componentMapping, viewContainerRef, elementInjector, module) {
    return new Observable((subscriber) => {
      let componentRef;
      const injector = elementInjector ?? viewContainerRef.injector;
      const dispose = () => {
        if (componentRef) {
          componentRef.destroy();
        }
      };
      const factory = this.getComponentFactory(injector, componentMapping.component);
      if (factory) {
        componentRef = viewContainerRef.createComponent(factory, void 0, injector, void 0, module);
        subscriber.next({
          elementRef: componentRef.location,
          componentRef
        });
      }
      return dispose;
    });
  }
  getComponentFactory(injector, component) {
    if (!component) {
      return null;
    }
    const factory = injector.get(ComponentFactoryResolver$1).resolveComponentFactory(component);
    return factory;
  }
};
_DefaultComponentHandler.\u0275fac = function DefaultComponentHandler_Factory(t) {
  return new (t || _DefaultComponentHandler)();
};
_DefaultComponentHandler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DefaultComponentHandler,
  factory: _DefaultComponentHandler.\u0275fac,
  providedIn: "root"
});
var DefaultComponentHandler = _DefaultComponentHandler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultComponentHandler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _LazyComponentHandler = class _LazyComponentHandler {
  constructor(defaultHandler) {
    this.defaultHandler = defaultHandler;
  }
  /**
   * We want to mach dynamic import signature () => import('')
   */
  hasMatch(componentMapping) {
    return typeof componentMapping.component === "function" && this.isNotClass(componentMapping.component);
  }
  isNotClass(symbol) {
    const signature = symbol.toString().substring(0, 20).replace(" ", "");
    return signature.startsWith("function()") || signature.startsWith("()=>");
  }
  getPriority() {
    return -10;
  }
  launcher(componentMapping, viewContainerRef, elementInjector, module) {
    return from(componentMapping.component()).pipe(switchMap((component) => this.defaultHandler.launcher(__spreadProps(__spreadValues({}, componentMapping), {
      component
    }), viewContainerRef, elementInjector, module)));
  }
};
_LazyComponentHandler.\u0275fac = function LazyComponentHandler_Factory(t) {
  return new (t || _LazyComponentHandler)(\u0275\u0275inject(DefaultComponentHandler));
};
_LazyComponentHandler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LazyComponentHandler,
  factory: _LazyComponentHandler.\u0275fac,
  providedIn: "root"
});
var LazyComponentHandler = _LazyComponentHandler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LazyComponentHandler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: DefaultComponentHandler
  }], null);
})();
var _InnerComponentsHostDirective = class _InnerComponentsHostDirective {
  constructor(data, vcr, cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector, eventService) {
    this.data = data;
    this.vcr = vcr;
    this.cmsComponentsService = cmsComponentsService;
    this.injector = injector;
    this.dynamicAttributeService = dynamicAttributeService;
    this.renderer = renderer;
    this.componentHandler = componentHandler;
    this.cmsInjector = cmsInjector;
    this.eventService = eventService;
    this.innerComponents$ = this.data.data$.pipe(map((data2) => data2?.composition?.inner ?? []), distinctUntilChanged());
    this.componentWrappers = [];
  }
  ngOnInit() {
    this.subscription = this.innerComponents$.subscribe((x) => {
      this.renderComponents(x);
    });
  }
  renderComponents(components) {
    this.clearComponents();
    components.forEach((component) => this.renderComponent(component));
  }
  renderComponent(component) {
    const componentWrapper = new ComponentWrapperDirective(this.vcr, this.cmsComponentsService, this.injector, this.dynamicAttributeService, this.renderer, this.componentHandler, this.cmsInjector, this.eventService);
    componentWrapper.cxComponentWrapper = {
      flexType: component,
      uid: ""
    };
    componentWrapper.ngOnInit();
    this.componentWrappers.push(componentWrapper);
  }
  clearComponents() {
    this.componentWrappers.forEach((wrapper) => wrapper.ngOnDestroy());
    this.componentWrappers = [];
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
    this.clearComponents();
  }
};
_InnerComponentsHostDirective.\u0275fac = function InnerComponentsHostDirective_Factory(t) {
  return new (t || _InnerComponentsHostDirective)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(CmsComponentsService), \u0275\u0275directiveInject(Injector), \u0275\u0275directiveInject(DynamicAttributeService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ComponentHandlerService), \u0275\u0275directiveInject(CmsInjectorService), \u0275\u0275directiveInject(EventService));
};
_InnerComponentsHostDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _InnerComponentsHostDirective,
  selectors: [["", "cxInnerComponentsHost", ""]]
});
var InnerComponentsHostDirective = _InnerComponentsHostDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InnerComponentsHostDirective, [{
    type: Directive,
    args: [{
      selector: "[cxInnerComponentsHost]"
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: ViewContainerRef
  }, {
    type: CmsComponentsService
  }, {
    type: Injector
  }, {
    type: DynamicAttributeService
  }, {
    type: Renderer2
  }, {
    type: ComponentHandlerService
  }, {
    type: CmsInjectorService
  }, {
    type: EventService
  }], null);
})();
var _PageComponentModule = class _PageComponentModule {
  static forRoot() {
    return {
      ngModule: _PageComponentModule,
      providers: [{
        provide: ComponentHandler,
        useExisting: DefaultComponentHandler,
        multi: true
      }, {
        provide: ComponentHandler,
        useExisting: LazyComponentHandler,
        multi: true
      }]
    };
  }
};
_PageComponentModule.\u0275fac = function PageComponentModule_Factory(t) {
  return new (t || _PageComponentModule)();
};
_PageComponentModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PageComponentModule
});
_PageComponentModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var PageComponentModule = _PageComponentModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageComponentModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [ComponentWrapperDirective, InnerComponentsHostDirective],
      exports: [ComponentWrapperDirective, InnerComponentsHostDirective]
    }]
  }], null, null);
})();
var _PageSlotModule = class _PageSlotModule {
  // instantiate PageSlotService ASAP, so it can examine SSR pre-rendered DOM
  constructor(_pageSlot) {
  }
};
_PageSlotModule.\u0275fac = function PageSlotModule_Factory(t) {
  return new (t || _PageSlotModule)(\u0275\u0275inject(PageSlotService));
};
_PageSlotModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PageSlotModule
});
_PageSlotModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, OutletModule, PageComponentModule]
});
var PageSlotModule = _PageSlotModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageSlotModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, OutletModule, PageComponentModule],
      declarations: [PageSlotComponent],
      exports: [PageSlotComponent]
    }]
  }], () => [{
    type: PageSlotService
  }], null);
})();
var _PageLayoutModule = class _PageLayoutModule {
};
_PageLayoutModule.\u0275fac = function PageLayoutModule_Factory(t) {
  return new (t || _PageLayoutModule)();
};
_PageLayoutModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PageLayoutModule
});
_PageLayoutModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, OutletModule, PageSlotModule]
});
var PageLayoutModule = _PageLayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageLayoutModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, OutletModule, PageSlotModule],
      declarations: [PageLayoutComponent, PageTemplateDirective],
      exports: [PageLayoutComponent, PageTemplateDirective]
    }]
  }], null, null);
})();
var _PWAModuleConfig = class _PWAModuleConfig {
};
_PWAModuleConfig.\u0275fac = function PWAModuleConfig_Factory(t) {
  return new (t || _PWAModuleConfig)();
};
_PWAModuleConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PWAModuleConfig,
  factory: function PWAModuleConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _PWAModuleConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var PWAModuleConfig = _PWAModuleConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PWAModuleConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var defaultPWAModuleConfig = {
  pwa: {
    enabled: false,
    addToHomeScreen: false
  }
};
var _AddToHomeScreenService = class _AddToHomeScreenService {
  constructor(config, globalMessageService, winRef) {
    this.config = config;
    this.globalMessageService = globalMessageService;
    this.winRef = winRef;
    this.canPrompt = new BehaviorSubject(false);
    this.canPrompt$ = this.canPrompt.asObservable();
    if (this.config.pwa?.addToHomeScreen) {
      this.init();
    }
  }
  init() {
    if (this.winRef.nativeWindow) {
      this.winRef.nativeWindow.addEventListener("beforeinstallprompt", (event) => {
        event.preventDefault();
        this.deferredEvent = event;
        this.enableAddToHomeScreen();
      });
      this.winRef.nativeWindow.addEventListener("appinstalled", () => {
        this.globalMessageService.add({
          key: "pwa.addedToHomeScreen"
        }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        this.disableAddToHomeScreen();
        this.deferredEvent = null;
      });
    }
  }
  enableAddToHomeScreen() {
    this.canPrompt.next(true);
  }
  disableAddToHomeScreen() {
    this.canPrompt.next(false);
  }
  firePrompt() {
    if (this.deferredEvent) {
      this.deferredEvent.prompt();
    }
  }
};
_AddToHomeScreenService.\u0275fac = function AddToHomeScreenService_Factory(t) {
  return new (t || _AddToHomeScreenService)(\u0275\u0275inject(PWAModuleConfig), \u0275\u0275inject(GlobalMessageService), \u0275\u0275inject(WindowRef));
};
_AddToHomeScreenService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _AddToHomeScreenService,
  factory: _AddToHomeScreenService.\u0275fac,
  providedIn: "root"
});
var AddToHomeScreenService = _AddToHomeScreenService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddToHomeScreenService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PWAModuleConfig
  }, {
    type: GlobalMessageService
  }, {
    type: WindowRef
  }], null);
})();
var _AddToHomeScreenComponent = class _AddToHomeScreenComponent {
  constructor(addToHomeScreenService) {
    this.addToHomeScreenService = addToHomeScreenService;
  }
  ngOnInit() {
    this.canPrompt$ = this.addToHomeScreenService.canPrompt$;
  }
  prompt() {
    this.addToHomeScreenService.firePrompt();
  }
};
_AddToHomeScreenComponent.\u0275fac = function AddToHomeScreenComponent_Factory(t) {
  return new (t || _AddToHomeScreenComponent)(\u0275\u0275directiveInject(AddToHomeScreenService));
};
_AddToHomeScreenComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AddToHomeScreenComponent
});
var AddToHomeScreenComponent = _AddToHomeScreenComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddToHomeScreenComponent, [{
    type: Directive
  }], () => [{
    type: AddToHomeScreenService
  }], null);
})();
var _AddToHomeScreenBannerComponent = class _AddToHomeScreenBannerComponent extends AddToHomeScreenComponent {
  constructor(addToHomeScreenService) {
    super(addToHomeScreenService);
    this.addToHomeScreenService = addToHomeScreenService;
  }
};
_AddToHomeScreenBannerComponent.\u0275fac = function AddToHomeScreenBannerComponent_Factory(t) {
  return new (t || _AddToHomeScreenBannerComponent)(\u0275\u0275directiveInject(AddToHomeScreenService));
};
_AddToHomeScreenBannerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AddToHomeScreenBannerComponent,
  selectors: [["cx-add-to-home-screen-banner"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [1, "cx-add-to-home-screen-banner"], [1, "cx-add-to-home-screen-banner-inner"], [1, "btn", "btn-primary", 3, "click"]],
  template: function AddToHomeScreenBannerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, AddToHomeScreenBannerComponent_div_0_Template, 16, 12, "div", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.canPrompt$));
    }
  },
  dependencies: [NgIf, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var AddToHomeScreenBannerComponent = _AddToHomeScreenBannerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddToHomeScreenBannerComponent, [{
    type: Component,
    args: [{
      selector: "cx-add-to-home-screen-banner",
      template: `<div *ngIf="canPrompt$ | async">
  <div class="cx-add-to-home-screen-banner">
    <div class="cx-add-to-home-screen-banner-inner">
      <p>
        {{ 'pwa.addToHomeScreenDescription' | cxTranslate }}
      </p>
      <ul>
        <li>{{ 'pwa.noInstallationNeeded' | cxTranslate }}</li>
        <li>{{ 'pwa.fastAccessToApplication' | cxTranslate }}</li>
      </ul>
      <button (click)="prompt()" class="btn btn-primary">
        {{ 'pwa.addToHomeScreen' | cxTranslate }}
      </button>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: AddToHomeScreenService
  }], null);
})();
var _AddToHomeScreenBtnComponent = class _AddToHomeScreenBtnComponent extends AddToHomeScreenComponent {
  constructor(addToHomeScreenService) {
    super(addToHomeScreenService);
    this.addToHomeScreenService = addToHomeScreenService;
  }
};
_AddToHomeScreenBtnComponent.\u0275fac = function AddToHomeScreenBtnComponent_Factory(t) {
  return new (t || _AddToHomeScreenBtnComponent)(\u0275\u0275directiveInject(AddToHomeScreenService));
};
_AddToHomeScreenBtnComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AddToHomeScreenBtnComponent,
  selectors: [["cx-add-to-home-screen-btn"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  ngContentSelectors: _c12,
  decls: 3,
  vars: 3,
  consts: [[3, "click"], [4, "ngIf"]],
  template: function AddToHomeScreenBtnComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275listener("click", function AddToHomeScreenBtnComponent_Template_span_click_0_listener() {
        return ctx.prompt();
      });
      \u0275\u0275template(1, AddToHomeScreenBtnComponent_ng_content_1_Template, 1, 0, "ng-content", 1);
      \u0275\u0275pipe(2, "async");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(2, 1, ctx.canPrompt$));
    }
  },
  dependencies: [NgIf, AsyncPipe],
  encapsulation: 2
});
var AddToHomeScreenBtnComponent = _AddToHomeScreenBtnComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddToHomeScreenBtnComponent, [{
    type: Component,
    args: [{
      selector: "cx-add-to-home-screen-btn",
      template: '<span (click)="prompt()">\n  <ng-content *ngIf="canPrompt$ | async"></ng-content>\n</span>\n'
    }]
  }], () => [{
    type: AddToHomeScreenService
  }], null);
})();
function pwaConfigurationFactory(pwaConfig) {
  return {
    enabled: !isDevMode() && pwaConfig.pwa?.enabled || false
  };
}
function pwaFactory(addToHomeScreenService) {
  const result = () => addToHomeScreenService;
  return result;
}
var _PwaModule = class _PwaModule {
};
_PwaModule.\u0275fac = function PwaModule_Factory(t) {
  return new (t || _PwaModule)();
};
_PwaModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PwaModule
});
_PwaModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultPWAModuleConfig), {
    provide: SwRegistrationOptions,
    useFactory: pwaConfigurationFactory,
    deps: [Config]
  }, {
    provide: APP_INITIALIZER,
    useFactory: pwaFactory,
    deps: [AddToHomeScreenService],
    multi: true
  }],
  imports: [CommonModule, ServiceWorkerModule.register("ngsw-worker.js"), I18nModule]
});
var PwaModule = _PwaModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PwaModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ServiceWorkerModule.register("ngsw-worker.js"), I18nModule],
      providers: [provideDefaultConfig(defaultPWAModuleConfig), {
        provide: SwRegistrationOptions,
        useFactory: pwaConfigurationFactory,
        deps: [Config]
      }, {
        provide: APP_INITIALIZER,
        useFactory: pwaFactory,
        deps: [AddToHomeScreenService],
        multi: true
      }],
      declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
      exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent]
    }]
  }], null, null);
})();
var cmsRoute = {
  path: "**",
  canActivate: [CmsPageGuard],
  component: PageLayoutComponent
};
function addCmsRoute(injector) {
  const result = () => {
    const router = injector.get(Router);
    router.config.push(cmsRoute);
  };
  return result;
}
var _CmsRouteModule = class _CmsRouteModule {
};
_CmsRouteModule.\u0275fac = function CmsRouteModule_Factory(t) {
  return new (t || _CmsRouteModule)();
};
_CmsRouteModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CmsRouteModule
});
_CmsRouteModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: APP_INITIALIZER,
    multi: true,
    deps: [Injector],
    useFactory: addCmsRoute
  }]
});
var CmsRouteModule = _CmsRouteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsRouteModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: APP_INITIALIZER,
        multi: true,
        deps: [Injector],
        useFactory: addCmsRoute
      }]
    }]
  }], null, null);
})();
var defaultStorefrontRoutesConfig = {
  home: {
    paths: [""]
  },
  notFound: {
    paths: ["not-found"]
  },
  // semantic links for login related pages
  login: {
    paths: ["login"],
    protected: false,
    authFlow: true
  },
  register: {
    paths: ["login/register"],
    protected: false,
    authFlow: true
  },
  forgotPassword: {
    paths: ["login/forgot-password"],
    protected: false,
    authFlow: true
  },
  resetPassword: {
    paths: ["login/pw/change"],
    protected: false,
    authFlow: true
  },
  logout: {
    paths: ["logout"],
    protected: false,
    authFlow: true
  },
  // plp routes
  search: {
    paths: ["search/:query"]
  },
  category: {
    paths: ["category/:categoryCode"],
    paramsMapping: {
      categoryCode: "code"
    }
  },
  brand: {
    paths: ["Brands/:brandName/c/:brandCode"]
  },
  // pdp routes
  product: {
    paths: ["product/:productCode/:name"],
    paramsMapping: {
      productCode: "code"
    }
  },
  termsAndConditions: {
    paths: ["terms-and-conditions"]
  },
  coupons: {
    paths: ["my-account/coupons"]
  },
  couponClaim: {
    paths: ["my-account/coupon/claim/:couponCode"],
    paramsMapping: {
      couponCode: "code"
    }
  },
  myInterests: {
    paths: ["my-account/my-interests"]
  },
  notificationPreference: {
    paths: ["my-account/notification-preference"]
  }
};
var defaultRoutingConfig = {
  routing: {
    routes: defaultStorefrontRoutesConfig
  }
};
var _RoutingModule = class _RoutingModule {
  static forRoot() {
    return {
      ngModule: _RoutingModule,
      providers: [provideDefaultConfig(defaultRoutingConfig)]
    };
  }
};
_RoutingModule.\u0275fac = function RoutingModule_Factory(t) {
  return new (t || _RoutingModule)();
};
_RoutingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _RoutingModule
});
_RoutingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [RoutingModule.forRoot(), CmsRouteModule]
});
var RoutingModule2 = _RoutingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutingModule2, [{
    type: NgModule,
    args: [{
      imports: [RoutingModule.forRoot(), CmsRouteModule]
    }]
  }], null, null);
})();
function getSuffixUrlMatcher({
  marker,
  paramName,
  precedingParamName
}) {
  precedingParamName = precedingParamName || "param";
  const matcher = function suffixUrlMatcher(segments) {
    const markerIndex = findLastIndex(segments, ({
      path
    }) => path === marker);
    const isMarkerLastSegment = markerIndex === segments.length - 1;
    if (markerIndex === -1 || isMarkerLastSegment) {
      return null;
    }
    const paramIndex = markerIndex + 1;
    const posParams = {
      [paramName]: segments[paramIndex]
    };
    for (let i = 0; i < markerIndex; i++) {
      posParams[`${precedingParamName}${i}`] = segments[i];
    }
    return {
      consumed: segments.slice(0, paramIndex + 1),
      posParams
    };
  };
  if (isDevMode()) {
    matcher["_suffixRouteConfig"] = {
      marker,
      paramName,
      precedingParamName
    };
  }
  return matcher;
}
function findLastIndex(elements, predicate) {
  for (let index = elements.length - 1; index >= 0; index--) {
    if (predicate(elements[index])) {
      return index;
    }
  }
  return -1;
}
var _PageMetaLinkService = class _PageMetaLinkService {
  constructor(winRef, rendererFactory) {
    this.winRef = winRef;
    this.rendererFactory = rendererFactory;
  }
  /**
   * Adds a canonical link element to the document head.
   *
   * If an id is provided, the link will be updated.
   * If no url is provided, the link element will be deleted.
   */
  setCanonicalLink(url) {
    let link = this.winRef.document.querySelector('link[rel="canonical"]');
    if (!url) {
      link?.remove();
      return;
    }
    if (!link) {
      link = this.renderer.createElement("link");
      link.rel = "canonical";
      link.href = url;
      this.renderer.appendChild(this.winRef.document.head, link);
    } else {
      link?.setAttribute("href", url);
    }
  }
  get renderer() {
    return this.rendererFactory.createRenderer(null, null);
  }
};
_PageMetaLinkService.\u0275fac = function PageMetaLinkService_Factory(t) {
  return new (t || _PageMetaLinkService)(\u0275\u0275inject(WindowRef), \u0275\u0275inject(RendererFactory2));
};
_PageMetaLinkService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PageMetaLinkService,
  factory: _PageMetaLinkService.\u0275fac,
  providedIn: "root"
});
var PageMetaLinkService = _PageMetaLinkService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageMetaLinkService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: WindowRef
  }, {
    type: RendererFactory2
  }], null);
})();
var _SeoMetaService = class _SeoMetaService {
  constructor(ngTitle, ngMeta, pageMetaService, pageMetaLinkService) {
    this.ngTitle = ngTitle;
    this.ngMeta = ngMeta;
    this.pageMetaService = pageMetaService;
    this.pageMetaLinkService = pageMetaLinkService;
  }
  init() {
    this.subscription = this.pageMetaService.getMeta().pipe(filter(isNotNullable)).subscribe((meta) => this.meta = meta);
  }
  set meta(meta) {
    this.title = meta.title;
    this.description = meta.description;
    this.image = meta.image;
    this.robots = meta.robots;
    this.canonicalUrl = meta.canonicalUrl;
  }
  set title(title) {
    this.ngTitle.setTitle(title || "");
  }
  set description(value) {
    if (value) {
      this.addTag({
        name: "description",
        content: value || ""
      });
    } else {
      this.ngMeta.removeTag('name="description"');
    }
  }
  set image(imageUrl) {
    if (imageUrl) {
      this.addTag({
        name: "og:image",
        content: imageUrl
      });
    } else {
      this.ngMeta.removeTag('name="og:image"');
    }
  }
  set robots(value) {
    if (value && value.length > 0) {
      this.addTag({
        name: "robots",
        content: value.join(", ")
      });
    }
  }
  /**
   * Add the canonical Url to the head of the page.
   *
   * If the canonical url already exists the link is removed. This is quite
   * unlikely though, since canonical links are (typically) only added in SSR.
   */
  set canonicalUrl(url) {
    this.pageMetaLinkService?.setCanonicalLink(url);
  }
  addTag(meta) {
    if (meta.content) {
      this.ngMeta.updateTag(meta);
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
};
_SeoMetaService.\u0275fac = function SeoMetaService_Factory(t) {
  return new (t || _SeoMetaService)(\u0275\u0275inject(Title), \u0275\u0275inject(Meta), \u0275\u0275inject(PageMetaService), \u0275\u0275inject(PageMetaLinkService));
};
_SeoMetaService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SeoMetaService,
  factory: _SeoMetaService.\u0275fac,
  providedIn: "root"
});
var SeoMetaService = _SeoMetaService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeoMetaService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Title
  }, {
    type: Meta
  }, {
    type: PageMetaService
  }, {
    type: PageMetaLinkService
  }], null);
})();
var defaultSeoConfig = {
  seo: {
    structuredData: {
      disableInDevMode: true
    }
  }
};
var _SeoConfig = class _SeoConfig {
};
_SeoConfig.\u0275fac = function SeoConfig_Factory(t) {
  return new (t || _SeoConfig)();
};
_SeoConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SeoConfig,
  factory: function SeoConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _SeoConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var SeoConfig = _SeoConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeoConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var htmlLangProvider = {
  provide: APP_INITIALIZER,
  multi: true,
  useFactory: setHtmlLangAttribute,
  deps: [WindowRef, LanguageService]
};
function setHtmlLangAttribute(winRef, languageService) {
  const result = () => {
    languageService.getActive().subscribe((lang) => {
      winRef.document.documentElement.lang = lang.replace(/_/g, "-");
    });
  };
  return result;
}
var _JsonLdScriptFactory = class _JsonLdScriptFactory {
  constructor(platformId, winRef, rendererFactory, config) {
    this.platformId = platformId;
    this.winRef = winRef;
    this.rendererFactory = rendererFactory;
    this.config = config;
    this.renderer = this.rendererFactory.createRenderer(null, null);
  }
  build(schema) {
    if (schema && this.isJsonLdRequired()) {
      this.getJsonLdScriptElement().textContent = this.escapeHtml(schema);
    }
  }
  /**
   * Indicates whether json ld data should be generated.
   *
   * This is only required on the server, but can be enabled in dev mode.
   */
  isJsonLdRequired() {
    return !isPlatformBrowser(this.platformId) || isDevMode() && !this.config.seo?.structuredData?.disableInDevMode;
  }
  /**
   * Creates a json-ld script element. The element is created one, and appended
   * to the html body element.
   *
   * ```html
   * <script id="json-ld" type="application/ld+json">
   * </script>
   * ```
   */
  getJsonLdScriptElement() {
    const id = "json-ld";
    let scriptElement = this.winRef.document.getElementById(id);
    if (!scriptElement) {
      const script = this.renderer.createElement("script");
      script.id = id;
      script.type = "application/ld+json";
      this.renderer.appendChild(this.winRef.document.body, script);
      scriptElement = script;
    }
    return scriptElement;
  }
  /**
   * Secure the given json-ld schema by encoding html characters (aka escaping), eg: <script> becomes &lt;script&gt;
   *
   * The given schema is not trusted, as malicious code could be injected (XSS)
   * into the json-ld script.
   */
  escapeHtml(schema) {
    const div = this.renderer.createElement("div");
    div.textContent = JSON.stringify(schema);
    return div.innerHTML;
  }
};
_JsonLdScriptFactory.\u0275fac = function JsonLdScriptFactory_Factory(t) {
  return new (t || _JsonLdScriptFactory)(\u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(WindowRef), \u0275\u0275inject(RendererFactory2), \u0275\u0275inject(SeoConfig));
};
_JsonLdScriptFactory.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _JsonLdScriptFactory,
  factory: _JsonLdScriptFactory.\u0275fac,
  providedIn: "root"
});
var JsonLdScriptFactory = _JsonLdScriptFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonLdScriptFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: WindowRef
  }, {
    type: RendererFactory2
  }, {
    type: SeoConfig
  }], null);
})();
var _JsonLdDirective = class _JsonLdDirective {
  /**
   * Writes the schema data to a json-ld script element.
   */
  set cxJsonLd(schema) {
    this.generateJsonLdScript(schema);
  }
  constructor(renderer, jsonLdScriptFactory, element) {
    this.renderer = renderer;
    this.jsonLdScriptFactory = jsonLdScriptFactory;
    this.element = element;
  }
  /**
   * attach the json-ld script tag to DOM with the schema data secured by encoding html tags (aka escaping)
   */
  generateJsonLdScript(schema) {
    if (schema && this.jsonLdScriptFactory.isJsonLdRequired()) {
      const script = this.renderer.createElement("script");
      script.type = "application/ld+json";
      script.textContent = this.jsonLdScriptFactory.escapeHtml(schema);
      this.renderer.appendChild(this.element.nativeElement, script);
    }
  }
};
_JsonLdDirective.\u0275fac = function JsonLdDirective_Factory(t) {
  return new (t || _JsonLdDirective)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(JsonLdScriptFactory), \u0275\u0275directiveInject(ElementRef));
};
_JsonLdDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _JsonLdDirective,
  selectors: [["", "cxJsonLd", ""]],
  inputs: {
    cxJsonLd: "cxJsonLd"
  }
});
var JsonLdDirective = _JsonLdDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonLdDirective, [{
    type: Directive,
    args: [{
      selector: "[cxJsonLd]"
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: JsonLdScriptFactory
  }, {
    type: ElementRef
  }], {
    cxJsonLd: [{
      type: Input
    }]
  });
})();
var SCHEMA_BUILDER = new InjectionToken("SchemaBuilderToken");
var JSONLD_PRODUCT_BUILDER = new InjectionToken("JsonLdProductBuilderToken");
var _StructuredDataFactory = class _StructuredDataFactory {
  constructor(scriptBuilder, builders) {
    this.scriptBuilder = scriptBuilder;
    this.builders = builders;
    this.subscription = new Subscription();
  }
  /**
   * Initiates the build of structured data by collecting all schema
   * builders.
   */
  build() {
    if (this.scriptBuilder.isJsonLdRequired() && this.builders) {
      this.subscription.add(this.collectSchemas().subscribe((schema) => {
        this.scriptBuilder.build(schema);
      }));
    }
  }
  /**
   * Collects all schema builders and observe their structured data.
   */
  collectSchemas() {
    return combineLatest(this.builders.map((builder) => builder.build()));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_StructuredDataFactory.\u0275fac = function StructuredDataFactory_Factory(t) {
  return new (t || _StructuredDataFactory)(\u0275\u0275inject(JsonLdScriptFactory), \u0275\u0275inject(SCHEMA_BUILDER, 8));
};
_StructuredDataFactory.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _StructuredDataFactory,
  factory: _StructuredDataFactory.\u0275fac,
  providedIn: "root"
});
var StructuredDataFactory = _StructuredDataFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StructuredDataFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: JsonLdScriptFactory
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [SCHEMA_BUILDER]
    }]
  }], null);
})();
function getStructuredDataFactory(injector) {
  const result = () => {
    const factory = injector.get(StructuredDataFactory);
    factory.build();
  };
  return result;
}
var _StructuredDataModule = class _StructuredDataModule {
};
_StructuredDataModule.\u0275fac = function StructuredDataModule_Factory(t) {
  return new (t || _StructuredDataModule)();
};
_StructuredDataModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _StructuredDataModule
});
_StructuredDataModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: APP_INITIALIZER,
    useFactory: getStructuredDataFactory,
    deps: [Injector],
    multi: true
  }],
  imports: [CommonModule]
});
var StructuredDataModule = _StructuredDataModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StructuredDataModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [JsonLdDirective],
      exports: [JsonLdDirective],
      providers: [{
        provide: APP_INITIALIZER,
        useFactory: getStructuredDataFactory,
        deps: [Injector],
        multi: true
      }]
    }]
  }], null, null);
})();
function initSeoService(injector) {
  const result = () => {
    const service = injector.get(SeoMetaService);
    service.init();
  };
  return result;
}
var _SeoModule = class _SeoModule {
};
_SeoModule.\u0275fac = function SeoModule_Factory(t) {
  return new (t || _SeoModule)();
};
_SeoModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SeoModule
});
_SeoModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultSeoConfig), {
    provide: APP_INITIALIZER,
    useFactory: initSeoService,
    deps: [Injector],
    multi: true
  }, htmlLangProvider],
  imports: [StructuredDataModule]
});
var SeoModule = _SeoModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeoModule, [{
    type: NgModule,
    args: [{
      imports: [StructuredDataModule],
      providers: [provideDefaultConfig(defaultSeoConfig), {
        provide: APP_INITIALIZER,
        useFactory: initSeoService,
        deps: [Injector],
        multi: true
      }, htmlLangProvider]
    }]
  }], null, null);
})();
var _BreadcrumbSchemaBuilder = class _BreadcrumbSchemaBuilder {
  constructor(pageMetaService) {
    this.pageMetaService = pageMetaService;
  }
  build() {
    return this.pageMetaService.getMeta().pipe(map((pageMeta) => this.collect(pageMeta)));
  }
  collect(pageMeta) {
    if (!pageMeta?.breadcrumbs) {
      return;
    }
    const crumbs = pageMeta.breadcrumbs.map((crumb, index) => {
      return {
        "@type": "ListItem",
        position: index + 1,
        item: {
          "@id": crumb.link,
          name: crumb.label
        }
      };
    });
    if (pageMeta.title) {
      crumbs.push({
        "@type": "ListItem",
        position: crumbs.length + 1,
        item: {
          "@id": pageMeta.title,
          name: pageMeta.title
        }
      });
    }
    return {
      "@context": "http://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: crumbs
    };
  }
};
_BreadcrumbSchemaBuilder.\u0275fac = function BreadcrumbSchemaBuilder_Factory(t) {
  return new (t || _BreadcrumbSchemaBuilder)(\u0275\u0275inject(PageMetaService));
};
_BreadcrumbSchemaBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _BreadcrumbSchemaBuilder,
  factory: _BreadcrumbSchemaBuilder.\u0275fac,
  providedIn: "root"
});
var BreadcrumbSchemaBuilder = _BreadcrumbSchemaBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadcrumbSchemaBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PageMetaService
  }], null);
})();
var _JsonLdBaseProductBuilder = class _JsonLdBaseProductBuilder {
  build(product) {
    return of(__spreadValues(__spreadValues(__spreadValues({}, this.getProductBase(product)), this.getProductBrand(product)), this.getProductImage(product)));
  }
  /**
   * Returns the product sku, name and description.
   */
  getProductBase(product) {
    const result = {
      sku: product.code
    };
    if (product.name) {
      result.name = product.name;
    }
    if (product.summary) {
      result.description = product.summary;
    }
    return result;
  }
  /**
   * Returns the image object with the main product image url.
   *
   * If the image is not available, an empty object is returned.
   */
  getProductImage(product) {
    const image = product.images?.PRIMARY?.zoom?.url;
    return image ? {
      image
    } : {};
  }
  /**
   * Returns the brand object with the product manufacturer.
   *
   * If the brand is not available, an empty object is returned.
   */
  getProductBrand(product) {
    const brand = product.manufacturer;
    return brand ? {
      brand
    } : {};
  }
};
_JsonLdBaseProductBuilder.\u0275fac = function JsonLdBaseProductBuilder_Factory(t) {
  return new (t || _JsonLdBaseProductBuilder)();
};
_JsonLdBaseProductBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _JsonLdBaseProductBuilder,
  factory: _JsonLdBaseProductBuilder.\u0275fac,
  providedIn: "root"
});
var JsonLdBaseProductBuilder = _JsonLdBaseProductBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonLdBaseProductBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _JsonLdProductOfferBuilder = class _JsonLdProductOfferBuilder {
  build(product) {
    const schema = {
      "@type": "Offer"
    };
    if (product.price?.value) {
      schema.price = product.price.value;
      if (product.price.currencyIso) {
        schema.priceCurrency = product.price.currencyIso;
      }
    }
    if (product.stock && product.stock.stockLevelStatus) {
      schema.availability = product.stock.stockLevelStatus === "inStock" ? "InStock" : "OutOfStock";
    }
    return of({
      offers: schema
    });
  }
};
_JsonLdProductOfferBuilder.\u0275fac = function JsonLdProductOfferBuilder_Factory(t) {
  return new (t || _JsonLdProductOfferBuilder)();
};
_JsonLdProductOfferBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _JsonLdProductOfferBuilder,
  factory: _JsonLdProductOfferBuilder.\u0275fac,
  providedIn: "root"
});
var JsonLdProductOfferBuilder = _JsonLdProductOfferBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonLdProductOfferBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _JsonLdProductReviewBuilder = class _JsonLdProductReviewBuilder {
  constructor(reviewService, config) {
    this.reviewService = reviewService;
    this.config = config;
  }
  build(product) {
    return this.reviewService.getByProductCode(product.code ?? "").pipe(map((reviews) => reviews?.length > 0 ? {
      aggregateRating: this.buildAggregatedReviews(product, reviews),
      review: reviews.map((review) => this.buildReviews(review))
    } : {}));
  }
  buildAggregatedReviews(product, reviews) {
    const aggregated = {
      "@type": "AggregateRating"
    };
    if (product.averageRating) {
      aggregated.ratingValue = product.averageRating;
    }
    if (reviews) {
      aggregated.ratingCount = reviews.filter((rev) => !!rev.rating).length;
      aggregated.reviewCount = reviews.filter((rev) => !!rev.comment).length;
    }
    return aggregated;
  }
  buildReviews(review) {
    const reviewSchema = {
      "@type": "review"
    };
    if (review.principal && review.principal.name) {
      reviewSchema.author = review.principal.name;
    }
    if (review.date) {
      const date = new Date(review.date);
      reviewSchema.datePublished = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
    }
    if (review.headline) {
      reviewSchema.name = review.headline;
    }
    if (review.comment) {
      reviewSchema.description = review.comment;
    }
    if (review.rating) {
      reviewSchema.reviewRating = {
        "@type": "Rating",
        ratingValue: review.rating.toString()
      };
    }
    return reviewSchema;
  }
};
_JsonLdProductReviewBuilder.\u0275fac = function JsonLdProductReviewBuilder_Factory(t) {
  return new (t || _JsonLdProductReviewBuilder)(\u0275\u0275inject(ProductReviewService), \u0275\u0275inject(SeoConfig));
};
_JsonLdProductReviewBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _JsonLdProductReviewBuilder,
  factory: _JsonLdProductReviewBuilder.\u0275fac,
  providedIn: "root"
});
var JsonLdProductReviewBuilder = _JsonLdProductReviewBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonLdProductReviewBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ProductReviewService
  }, {
    type: SeoConfig
  }], null);
})();
var _CurrentProductService = class _CurrentProductService {
  constructor(routingService, productService) {
    this.routingService = routingService;
    this.productService = productService;
    this.DEFAULT_PRODUCT_SCOPE = "details";
  }
  /**
   * Returns an observable for the current product
   * @returns Product
   * @returns null if product can't be found
   *
   * @param scopes
   */
  getProduct(scopes) {
    return this.getCode().pipe(distinctUntilChanged(), switchMap((productCode) => {
      return productCode ? this.productService.get(productCode, scopes || this.DEFAULT_PRODUCT_SCOPE) : of(null);
    }), filter(isNotUndefined));
  }
  getCode() {
    return this.routingService.getRouterState().pipe(map((state) => state.state.params["productCode"]));
  }
};
_CurrentProductService.\u0275fac = function CurrentProductService_Factory(t) {
  return new (t || _CurrentProductService)(\u0275\u0275inject(RoutingService), \u0275\u0275inject(ProductService));
};
_CurrentProductService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CurrentProductService,
  factory: _CurrentProductService.\u0275fac,
  providedIn: "root"
});
var CurrentProductService = _CurrentProductService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrentProductService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RoutingService
  }, {
    type: ProductService
  }], null);
})();
var _ProductSchemaBuilder = class _ProductSchemaBuilder {
  constructor(currentProduct, builders) {
    this.currentProduct = currentProduct;
    this.builders = builders;
  }
  build() {
    return this.currentProduct.getProduct().pipe(switchMap((product) => {
      if (product) {
        return combineLatest(this.collect(product)).pipe(map((res) => Object.assign({}, ...res)));
      }
      return of({});
    }));
  }
  collect(product) {
    if (!product || !product.code) {
      return [];
    }
    const builders = this.builders ? this.builders.map((builder) => builder.build(product)) : [];
    return [of({
      "@context": "http://schema.org",
      "@type": "Product"
    }), ...builders];
  }
};
_ProductSchemaBuilder.\u0275fac = function ProductSchemaBuilder_Factory(t) {
  return new (t || _ProductSchemaBuilder)(\u0275\u0275inject(CurrentProductService), \u0275\u0275inject(JSONLD_PRODUCT_BUILDER, 8));
};
_ProductSchemaBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ProductSchemaBuilder,
  factory: _ProductSchemaBuilder.\u0275fac,
  providedIn: "root"
});
var ProductSchemaBuilder = _ProductSchemaBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductSchemaBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CurrentProductService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [JSONLD_PRODUCT_BUILDER]
    }]
  }], null);
})();
var _JsonLdBuilderModule = class _JsonLdBuilderModule {
};
_JsonLdBuilderModule.\u0275fac = function JsonLdBuilderModule_Factory(t) {
  return new (t || _JsonLdBuilderModule)();
};
_JsonLdBuilderModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _JsonLdBuilderModule
});
_JsonLdBuilderModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [
    {
      provide: SCHEMA_BUILDER,
      useExisting: ProductSchemaBuilder,
      multi: true
    },
    {
      provide: SCHEMA_BUILDER,
      useExisting: BreadcrumbSchemaBuilder,
      multi: true
    },
    // lower level json-ld builder classes offering fine-grained control
    // for product related schemas
    {
      provide: JSONLD_PRODUCT_BUILDER,
      useExisting: JsonLdBaseProductBuilder,
      multi: true
    },
    {
      provide: JSONLD_PRODUCT_BUILDER,
      useExisting: JsonLdProductOfferBuilder,
      multi: true
    },
    {
      provide: JSONLD_PRODUCT_BUILDER,
      useExisting: JsonLdProductReviewBuilder,
      multi: true
    }
  ]
});
var JsonLdBuilderModule = _JsonLdBuilderModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonLdBuilderModule, [{
    type: NgModule,
    args: [{
      providers: [
        {
          provide: SCHEMA_BUILDER,
          useExisting: ProductSchemaBuilder,
          multi: true
        },
        {
          provide: SCHEMA_BUILDER,
          useExisting: BreadcrumbSchemaBuilder,
          multi: true
        },
        // lower level json-ld builder classes offering fine-grained control
        // for product related schemas
        {
          provide: JSONLD_PRODUCT_BUILDER,
          useExisting: JsonLdBaseProductBuilder,
          multi: true
        },
        {
          provide: JSONLD_PRODUCT_BUILDER,
          useExisting: JsonLdProductOfferBuilder,
          multi: true
        },
        {
          provide: JSONLD_PRODUCT_BUILDER,
          useExisting: JsonLdProductReviewBuilder,
          multi: true
        }
      ]
    }]
  }], null, null);
})();
var PageSection;
(function(PageSection2) {
  PageSection2["HEADER"] = "header";
  PageSection2["FOOTER"] = "footer";
  PageSection2["NAVIGATION"] = "navigation";
})(PageSection || (PageSection = {}));
function provideCmsStructure(options) {
  return provideConfig(__spreadValues(__spreadValues({}, buildCmsStructure(options)), buildLayoutConfig(options)));
}
function buildCmsStructure({
  componentId,
  pageSlotPosition
} = {}) {
  const config = {
    cmsStructure: {}
  };
  if (componentId) {
    config.cmsStructure = {
      components: {
        [componentId]: {
          typeCode: componentId,
          flexType: componentId
        }
      }
    };
  }
  if (componentId && pageSlotPosition && config.cmsStructure) {
    config.cmsStructure.slots = {
      [pageSlotPosition]: {
        componentIds: [componentId]
      }
    };
  }
  return config;
}
function buildLayoutConfig({
  pageTemplate,
  pageSlotPosition,
  breakpoint,
  section
} = {}) {
  const layoutConfig2 = {};
  if (pageTemplate && pageSlotPosition) {
    const pageTemplateSlots = {};
    if (breakpoint) {
      pageTemplateSlots[breakpoint] = {
        slots: [pageSlotPosition]
      };
    } else {
      pageTemplateSlots.slots = [pageSlotPosition];
    }
    layoutConfig2.layoutSlots = {
      [pageTemplate]: pageTemplateSlots
    };
  }
  if (section && pageSlotPosition) {
    const sectionSlots = {};
    if (breakpoint) {
      sectionSlots[breakpoint] = {
        slots: [pageSlotPosition]
      };
    } else {
      sectionSlots.slots = [pageSlotPosition];
    }
    if (layoutConfig2.layoutSlots) {
      layoutConfig2.layoutSlots[section] = sectionSlots;
    } else {
      layoutConfig2.layoutSlots = {
        [section]: sectionSlots
      };
    }
  }
  return layoutConfig2;
}
var _CarouselService = class _CarouselService {
  constructor(winRef) {
    this.winRef = winRef;
  }
  /**
   * The number of items per slide is calculated by the help of
   * the item width and the available width of the host element.
   * This appoach makes it possible to place the carousel in different
   * layouts. Instead of using the page breakpoints, the host size is
   * taken into account.
   *
   * Since there's no element resize API available, we use the
   * window `resize` event, so that we can adjust the number of items
   * whenever the window got resized.
   */
  getItemsPerSlide(nativeElement, itemWidth) {
    return this.winRef.resize$.pipe(map(() => nativeElement.clientWidth), map((totalWidth) => this.calculateItems(totalWidth, itemWidth)));
  }
  /**
   * Calculates the number of items per given hostSize.  calculated based on the given
   * intended size in pixels or percentages. The
   *
   * @param availableWidth The available width in pixels for the carousel items.
   * @param itemWidth The width per carousel item, in px or percentage.
   */
  calculateItems(availableWidth, itemWidth) {
    let calculatedItems = 0;
    if (itemWidth.endsWith("px")) {
      const num = itemWidth.substring(0, itemWidth.length - 2);
      calculatedItems = availableWidth / num;
    }
    if (itemWidth.endsWith("%")) {
      const perc = itemWidth.substring(0, itemWidth.length - 1);
      calculatedItems = availableWidth / (availableWidth * (perc / 100));
    }
    return Math.floor(calculatedItems) || 1;
  }
};
_CarouselService.\u0275fac = function CarouselService_Factory(t) {
  return new (t || _CarouselService)(\u0275\u0275inject(WindowRef));
};
_CarouselService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CarouselService,
  factory: _CarouselService.\u0275fac,
  providedIn: "root"
});
var CarouselService = _CarouselService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CarouselService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: WindowRef
  }], null);
})();
var _CarouselComponent = class _CarouselComponent {
  set setItems(inputItems) {
    this.items = inputItems;
    this.activeSlide = 0;
  }
  constructor(el, service) {
    this.el = el;
    this.service = service;
    this.itemWidth = "300px";
    this.hideIndicators = false;
    this.indicatorIcon = ICON_TYPE.CIRCLE;
    this.previousIcon = ICON_TYPE.CARET_LEFT;
    this.nextIcon = ICON_TYPE.CARET_RIGHT;
    this.logger = inject(LoggerService);
  }
  ngOnInit() {
    if (!this.template && isDevMode()) {
      this.logger.error("No template reference provided to render the carousel items for the `cx-carousel`");
      return;
    }
    this.size$ = this.service.getItemsPerSlide(this.el.nativeElement, this.itemWidth).pipe(tap(() => this.activeSlide = 0));
  }
  getSlideNumber(size, currentIndex) {
    const normalizedCurrentIndex = currentIndex + 1;
    return Math.ceil(normalizedCurrentIndex / size);
  }
};
_CarouselComponent.\u0275fac = function CarouselComponent_Factory(t) {
  return new (t || _CarouselComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(CarouselService));
};
_CarouselComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CarouselComponent,
  selectors: [["cx-carousel"]],
  inputs: {
    title: "title",
    setItems: [InputFlags.None, "items", "setItems"],
    template: "template",
    itemWidth: "itemWidth",
    hideIndicators: "hideIndicators",
    indicatorIcon: "indicatorIcon",
    previousIcon: "previousIcon",
    nextIcon: "nextIcon"
  },
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [1, "carousel-panel", 3, "ngClass"], ["class", "previous", 3, "disabled", "click", 4, "ngIf"], [1, "slides"], [4, "ngFor", "ngForOf"], ["class", "next", "tabindex", "-1", 3, "disabled", "click", 4, "ngIf"], ["class", "indicators", 4, "ngIf"], [1, "previous", 3, "click", "disabled"], [3, "type"], ["class", "slide", 3, "active", 4, "ngIf"], [1, "slide"], ["class", "item", 3, "active", 4, "ngIf"], [1, "item"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["tabindex", "-1", 1, "next", 3, "click", "disabled"], [1, "indicators"], ["tabindex", "-1", 3, "disabled", "click", 4, "ngIf"], ["tabindex", "-1", 3, "click", "disabled"], ["aria-hidden", "true", 3, "type"]],
  template: function CarouselComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, CarouselComponent_ng_container_0_Template, 8, 6, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.items && ctx.items.length > 0 && \u0275\u0275pipeBind1(1, 1, ctx.size$));
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, IconComponent, AsyncPipe, SlicePipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var CarouselComponent = _CarouselComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CarouselComponent, [{
    type: Component,
    args: [{
      selector: "cx-carousel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="items && items.length > 0 && (size$ | async) as size">
  <h2 *ngIf="title">{{ title }}</h2>

  <div class="carousel-panel" [ngClass]="'size-' + size">
    <button
      *ngIf="size < items.length"
      class="previous"
      (click)="activeSlide = activeSlide - size"
      [disabled]="activeSlide === 0"
      [attr.aria-label]="'carousel.previousSlide' | cxTranslate"
    >
      <cx-icon [type]="previousIcon"></cx-icon>
    </button>

    <div class="slides">
      <ng-container *ngFor="let _ of items; let i = index">
        <div
          class="slide"
          *ngIf="i % size === 0"
          [class.active]="i === activeSlide"
        >
          <ng-container
            *ngFor="let item of items | slice: i:i + size; let j = index"
          >
            <div
              *ngIf="item | async as data"
              class="item"
              [class.active]="i === activeSlide"
            >
              <ng-container
                *ngTemplateOutlet="template; context: { item: data }"
              ></ng-container>
            </div>
          </ng-container>
        </div>
      </ng-container>
    </div>

    <button
      *ngIf="size < items.length"
      class="next"
      (click)="activeSlide = activeSlide + size"
      tabindex="-1"
      [disabled]="activeSlide > items.length - size - 1"
      [attr.aria-label]="'carousel.nextSlide' | cxTranslate"
    >
      <cx-icon [type]="nextIcon"></cx-icon>
    </button>
  </div>

  <div *ngIf="!hideIndicators && size < items.length" class="indicators">
    <ng-container *ngFor="let _ of items; let i = index">
      <button
        *ngIf="i % size === 0"
        (click)="activeSlide = i"
        [disabled]="i === activeSlide"
        [attr.aria-label]="
          'carousel.slideNumber'
            | cxTranslate: { currentSlideNumber: getSlideNumber(size, i) }
        "
        tabindex="-1"
      >
        <cx-icon [type]="indicatorIcon" aria-hidden="true"></cx-icon>
      </button>
    </ng-container>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: CarouselService
  }], {
    title: [{
      type: Input
    }],
    setItems: [{
      type: Input,
      args: ["items"]
    }],
    template: [{
      type: Input
    }],
    itemWidth: [{
      type: Input
    }],
    hideIndicators: [{
      type: Input
    }],
    indicatorIcon: [{
      type: Input
    }],
    previousIcon: [{
      type: Input
    }],
    nextIcon: [{
      type: Input
    }]
  });
})();
var _BannerCarouselComponent = class _BannerCarouselComponent {
  constructor(componentData, cmsService) {
    this.componentData = componentData;
    this.cmsService = cmsService;
    this.componentData$ = this.componentData.data$.pipe(filter((data) => Boolean(data)), tap((d) => this.theme = `${d.effect}-theme`));
    this.items$ = this.componentData$.pipe(map((data) => data.banners?.trim().split(" ") ?? []), map((codes) => codes.map((code) => this.cmsService.getComponentData(code))));
    this.theme = "";
  }
  /**
   * Returns an Obervable with an Array of Observables. This is done, so that
   * the component UI could consider to lazy load the UI components when they're
   * in the viewpoint.
   */
  getItems() {
    return this.items$;
  }
};
_BannerCarouselComponent.\u0275fac = function BannerCarouselComponent_Factory(t) {
  return new (t || _BannerCarouselComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(CmsService));
};
_BannerCarouselComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BannerCarouselComponent,
  selectors: [["cx-banner-carousel"]],
  hostVars: 2,
  hostBindings: function BannerCarouselComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.theme);
    }
  },
  decls: 4,
  vars: 3,
  consts: [["template", ""], ["itemWidth", "100%", "class", "inline-navigation", 3, "items", "template", 4, "ngIf"], ["itemWidth", "100%", 1, "inline-navigation", 3, "items", "template"], [3, "cxComponentWrapper"]],
  template: function BannerCarouselComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, BannerCarouselComponent_cx_carousel_0_Template, 1, 2, "cx-carousel", 1);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, BannerCarouselComponent_ng_template_2_Template, 1, 5, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.getItems()));
    }
  },
  dependencies: [NgIf, ComponentWrapperDirective, CarouselComponent, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var BannerCarouselComponent = _BannerCarouselComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BannerCarouselComponent, [{
    type: Component,
    args: [{
      selector: "cx-banner-carousel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<cx-carousel\n  *ngIf="getItems() | async as items"\n  [items]="items"\n  [template]="template"\n  itemWidth="100%"\n  class="inline-navigation"\n></cx-carousel>\n\n<ng-template #template let-item="item">\n  <ng-container\n    [cxComponentWrapper]="{\n      flexType: item.typeCode,\n      typeCode: item.typeCode,\n      uid: item?.uid\n    }"\n  >\n  </ng-container>\n</ng-template>\n'
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: CmsService
  }], {
    theme: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _SpinnerModule = class _SpinnerModule {
};
_SpinnerModule.\u0275fac = function SpinnerModule_Factory(t) {
  return new (t || _SpinnerModule)();
};
_SpinnerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SpinnerModule
});
_SpinnerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule]
});
var SpinnerModule = _SpinnerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule],
      declarations: [SpinnerComponent],
      exports: [SpinnerComponent]
    }]
  }], null, null);
})();
var _ConsentManagementComponentService = class _ConsentManagementComponentService {
  constructor(anonymousConsentsConfig) {
    this.anonymousConsentsConfig = anonymousConsentsConfig;
  }
  /**
   * Returns the list of mandatory consents
   * @param _templateList - list of all active consents. This parameter is not needed in core
   * implementation. But is needed in CDC implementation to fetch only the required consents
   * from this list
   * @returns array of consent IDs
   */
  getRequiredConsents(_templateList) {
    return this.anonymousConsentsConfig?.anonymousConsents?.requiredConsents || [];
  }
};
_ConsentManagementComponentService.\u0275fac = function ConsentManagementComponentService_Factory(t) {
  return new (t || _ConsentManagementComponentService)(\u0275\u0275inject(AnonymousConsentsConfig));
};
_ConsentManagementComponentService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ConsentManagementComponentService,
  factory: _ConsentManagementComponentService.\u0275fac
});
var ConsentManagementComponentService = _ConsentManagementComponentService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConsentManagementComponentService, [{
    type: Injectable
  }], () => [{
    type: AnonymousConsentsConfig
  }], null);
})();
var _ConsentManagementComponent = class _ConsentManagementComponent {
  constructor(userConsentService, globalMessageService, anonymousConsentsConfig, anonymousConsentsService, authService, consentManagementComponentService) {
    this.userConsentService = userConsentService;
    this.globalMessageService = globalMessageService;
    this.anonymousConsentsConfig = anonymousConsentsConfig;
    this.anonymousConsentsService = anonymousConsentsService;
    this.authService = authService;
    this.consentManagementComponentService = consentManagementComponentService;
    this.subscriptions = new Subscription();
    this.allConsentsLoading = new BehaviorSubject(false);
    this.requiredConsents = [];
  }
  ngOnInit() {
    this.loading$ = combineLatest([this.userConsentService.getConsentsResultLoading(), this.userConsentService.getGiveConsentResultLoading(), this.userConsentService.getWithdrawConsentResultLoading(), this.authService.isUserLoggedIn(), this.allConsentsLoading]).pipe(map(([consentLoading, giveConsentLoading, withdrawConsentLoading, isUserLoggedIn, allConsentsLoading]) => consentLoading || giveConsentLoading || withdrawConsentLoading || !isUserLoggedIn || allConsentsLoading));
    this.consentListInit();
    this.giveConsentInit();
    this.withdrawConsentInit();
  }
  consentListInit() {
    this.templateList$ = this.userConsentService.getConsents().pipe(withLatestFrom(this.anonymousConsentsService.getTemplates(), this.authService.isUserLoggedIn()), filter(([_templateList, _anonymousTemplates, isUserLoggedIn]) => isUserLoggedIn), tap(([templateList, _anonymousTemplates]) => {
      if (!this.consentsExists(templateList)) {
        this.userConsentService.loadConsents();
      }
    }), map(([templateList, anonymousTemplates]) => {
      this.requiredConsents = this.consentManagementComponentService ? this.consentManagementComponentService.getRequiredConsents(templateList) : [];
      if (this.anonymousConsentsConfig.anonymousConsents) {
        if (this.anonymousConsentsConfig.anonymousConsents.consentManagementPage) {
          return this.hideAnonymousConsents(templateList, anonymousTemplates);
        }
      }
      return templateList;
    }));
  }
  hideAnonymousConsents(templateList, anonymousTemplates = []) {
    let hideTemplateIds = [];
    if (!this.anonymousConsentsConfig.anonymousConsents?.consentManagementPage?.showAnonymousConsents) {
      hideTemplateIds = anonymousTemplates.map((template) => template.id ?? "");
      return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
    }
    if (this.anonymousConsentsConfig.anonymousConsents.consentManagementPage.hideConsents && this.anonymousConsentsConfig.anonymousConsents.consentManagementPage.hideConsents.length > 0) {
      hideTemplateIds = this.anonymousConsentsConfig.anonymousConsents.consentManagementPage.hideConsents;
    }
    return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
  }
  giveConsentInit() {
    this.userConsentService.resetGiveConsentProcessState();
    this.subscriptions.add(this.userConsentService.getGiveConsentResultSuccess().subscribe((success) => this.onConsentGivenSuccess(success)));
  }
  withdrawConsentInit() {
    this.userConsentService.resetWithdrawConsentProcessState();
    this.subscriptions.add(this.userConsentService.getWithdrawConsentResultLoading().pipe(skipWhile(Boolean), withLatestFrom(this.userConsentService.getWithdrawConsentResultSuccess()), map(([, withdrawalSuccess]) => withdrawalSuccess), tap((withdrawalSuccess) => {
      if (withdrawalSuccess) {
        this.userConsentService.loadConsents();
      }
    })).subscribe((withdrawalSuccess) => this.onConsentWithdrawnSuccess(withdrawalSuccess)));
  }
  consentsExists(templateList) {
    return Boolean(templateList) && templateList.length > 0;
  }
  onConsentChange({
    given,
    template
  }) {
    if (given && template.id && template.version !== void 0) {
      this.userConsentService.giveConsent(template.id, template.version);
    } else if (template.currentConsent?.code) {
      this.userConsentService.withdrawConsent(template.currentConsent.code, template?.id);
    }
  }
  onConsentGivenSuccess(success) {
    if (success) {
      this.userConsentService.resetGiveConsentProcessState();
      this.globalMessageService.add({
        key: "consentManagementForm.message.success.given"
      }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
    }
  }
  onConsentWithdrawnSuccess(success) {
    if (success) {
      this.userConsentService.resetWithdrawConsentProcessState();
      this.globalMessageService.add({
        key: "consentManagementForm.message.success.withdrawn"
      }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
    }
  }
  rejectAll(templates = []) {
    const consentsToWithdraw = [];
    templates.forEach((template) => {
      if (template.currentConsent && this.userConsentService.isConsentGiven(template.currentConsent)) {
        if (this.isRequiredConsent(template)) {
          return;
        }
        consentsToWithdraw.push(template);
      }
    });
    this.allConsentsLoading.next(true);
    this.subscriptions.add(this.setupWithdrawalStream(consentsToWithdraw).pipe(tap((_timesLoaded) => this.allConsentsLoading.next(false))).subscribe());
  }
  setupWithdrawalStream(consentsToWithdraw = []) {
    const loading$ = concat(this.userConsentService.getWithdrawConsentResultLoading()).pipe(distinctUntilChanged(), filter((loading) => !loading));
    const count$ = loading$.pipe(scan((acc, _value) => acc + 1, -1));
    const withdraw$ = count$.pipe(tap((i) => {
      if (i < consentsToWithdraw.length) {
        const code = consentsToWithdraw[i].currentConsent?.code;
        const id = consentsToWithdraw[i]?.id;
        if (code) {
          this.userConsentService.withdrawConsent(code, id);
        }
      }
    }));
    const checkTimesLoaded$ = withdraw$.pipe(filter((timesLoaded) => timesLoaded === consentsToWithdraw.length));
    return checkTimesLoaded$;
  }
  allowAll(templates = []) {
    const consentsToGive = [];
    templates.forEach((template) => {
      const givenDate = template.currentConsent?.consentGivenDate;
      const withdrawnDate = template.currentConsent?.consentWithdrawnDate;
      const isConsentGiven = givenDate && !withdrawnDate || givenDate && withdrawnDate && givenDate > withdrawnDate;
      if (isConsentGiven) {
        return;
      }
      if (template.currentConsent && this.userConsentService.isConsentWithdrawn(template.currentConsent)) {
        if (this.isRequiredConsent(template)) {
          return;
        }
      }
      consentsToGive.push(template);
    });
    this.allConsentsLoading.next(true);
    this.subscriptions.add(this.setupGiveStream(consentsToGive).pipe(tap((_timesLoaded) => this.allConsentsLoading.next(false))).subscribe());
  }
  setupGiveStream(consentsToGive = []) {
    const loading$ = concat(this.userConsentService.getGiveConsentResultLoading()).pipe(distinctUntilChanged(), filter((loading) => !loading));
    const count$ = loading$.pipe(scan((acc, _value) => acc + 1, -1));
    const giveConsent$ = count$.pipe(tap((i) => {
      if (i < consentsToGive.length) {
        const consent = consentsToGive[i];
        if (consent.id && consent.version !== void 0) {
          this.userConsentService.giveConsent(consent.id, consent.version);
        }
      }
    }));
    const checkTimesLoaded$ = giveConsent$.pipe(filter((timesLoaded) => timesLoaded === consentsToGive.length));
    return checkTimesLoaded$;
  }
  isRequiredConsent(template) {
    return Boolean(template.id && this.anonymousConsentsConfig.anonymousConsents && this.anonymousConsentsConfig.anonymousConsents?.requiredConsents && this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.allConsentsLoading.unsubscribe();
    this.userConsentService.resetGiveConsentProcessState();
    this.userConsentService.resetWithdrawConsentProcessState();
  }
};
_ConsentManagementComponent.\u0275fac = function ConsentManagementComponent_Factory(t) {
  return new (t || _ConsentManagementComponent)(\u0275\u0275directiveInject(UserConsentService), \u0275\u0275directiveInject(GlobalMessageService), \u0275\u0275directiveInject(AnonymousConsentsConfig), \u0275\u0275directiveInject(AnonymousConsentsService), \u0275\u0275directiveInject(AuthService), \u0275\u0275directiveInject(ConsentManagementComponentService));
};
_ConsentManagementComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ConsentManagementComponent,
  selectors: [["cx-consent-management"]],
  decls: 4,
  vars: 4,
  consts: [["consentManagementForm", ""], [4, "ngIf", "ngIfElse"], [1, "cx-spinner"], ["role", "status"], [4, "ngIf"], [1, "cx-consent-action-links"], [1, "col-sm-12", "col-md-8", "col-lg-6"], ["tabindex", "0", 1, "btn", "btn-link", "cx-action-link", 3, "click"], [1, "cx-consent-toggles"], [3, "consentTemplate", "requiredConsents", "consentChanged", 4, "ngFor", "ngForOf"], [3, "consentChanged", "consentTemplate", "requiredConsents"]],
  template: function ConsentManagementComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ConsentManagementComponent_div_0_Template, 3, 0, "div", 1);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, ConsentManagementComponent_ng_template_2_Template, 4, 6, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const consentManagementForm_r6 = \u0275\u0275reference(3);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 2, ctx.loading$))("ngIfElse", consentManagementForm_r6);
    }
  },
  dependencies: [NgForOf, NgIf, SpinnerComponent, ConsentManagementFormComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var ConsentManagementComponent = _ConsentManagementComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConsentManagementComponent, [{
    type: Component,
    args: [{
      selector: "cx-consent-management",
      template: `<div *ngIf="loading$ | async; else consentManagementForm">
  <div class="cx-spinner">
    <cx-spinner></cx-spinner>
  </div>
</div>

<ng-template #consentManagementForm>
  <div role="status" [attr.aria-label]="'common.loaded' | cxTranslate"></div>
  <ng-container *ngIf="templateList$ | async as templateList">
    <div class="cx-consent-action-links">
      <div class="col-sm-12 col-md-8 col-lg-6">
        <button
          tabindex="0"
          class="btn btn-link cx-action-link"
          (click)="rejectAll(templateList)"
        >
          {{ 'consentManagementForm.clearAll' | cxTranslate }}
        </button>
        <button
          tabindex="0"
          class="btn btn-link cx-action-link"
          (click)="allowAll(templateList)"
        >
          {{ 'consentManagementForm.selectAll' | cxTranslate }}
        </button>
      </div>
    </div>

    <div class="cx-consent-toggles">
      <div class="col-sm-12 col-md-8 col-lg-6">
        <cx-consent-management-form
          *ngFor="let consentTemplate of templateList"
          [consentTemplate]="consentTemplate"
          [requiredConsents]="requiredConsents"
          (consentChanged)="onConsentChange($event)"
        ></cx-consent-management-form>
      </div>
    </div>
  </ng-container>
</ng-template>
`
    }]
  }], () => [{
    type: UserConsentService
  }, {
    type: GlobalMessageService
  }, {
    type: AnonymousConsentsConfig
  }, {
    type: AnonymousConsentsService
  }, {
    type: AuthService
  }, {
    type: ConsentManagementComponentService
  }], null);
})();
var _ConsentManagementModule = class _ConsentManagementModule {
};
_ConsentManagementModule.\u0275fac = function ConsentManagementModule_Factory(t) {
  return new (t || _ConsentManagementModule)();
};
_ConsentManagementModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ConsentManagementModule
});
_ConsentManagementModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [ConsentManagementComponentService, provideDefaultConfig({
    cmsComponents: {
      ConsentManagementComponent: {
        component: ConsentManagementComponent,
        guards: [AuthGuard]
      }
    }
  })],
  imports: [CommonModule, FormsModule, ReactiveFormsModule, SpinnerModule, I18nModule, IconModule]
});
var ConsentManagementModule = _ConsentManagementModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConsentManagementModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ReactiveFormsModule, SpinnerModule, I18nModule, IconModule],
      providers: [ConsentManagementComponentService, provideDefaultConfig({
        cmsComponents: {
          ConsentManagementComponent: {
            component: ConsentManagementComponent,
            guards: [AuthGuard]
          }
        }
      })],
      declarations: [ConsentManagementComponent, ConsentManagementFormComponent],
      exports: [ConsentManagementComponent, ConsentManagementFormComponent]
    }]
  }], null, null);
})();
var _AnonymousConsentsDialogModule = class _AnonymousConsentsDialogModule {
};
_AnonymousConsentsDialogModule.\u0275fac = function AnonymousConsentsDialogModule_Factory(t) {
  return new (t || _AnonymousConsentsDialogModule)();
};
_AnonymousConsentsDialogModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _AnonymousConsentsDialogModule
});
_AnonymousConsentsDialogModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule, IconModule, SpinnerModule, ConsentManagementModule, KeyboardFocusModule]
});
var AnonymousConsentsDialogModule = _AnonymousConsentsDialogModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnonymousConsentsDialogModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, IconModule, SpinnerModule, ConsentManagementModule, KeyboardFocusModule],
      declarations: [AnonymousConsentDialogComponent],
      exports: [AnonymousConsentDialogComponent]
    }]
  }], null, null);
})();
var _AtMessageDirective = class _AtMessageDirective {
  constructor(elementRef, templateRef, globalMessageService) {
    this.elementRef = elementRef;
    this.templateRef = templateRef;
    this.globalMessageService = globalMessageService;
  }
  get host() {
    return !!this.templateRef ? this.templateRef.elementRef.nativeElement.parentElement : this.elementRef.nativeElement;
  }
  /**
   * Emit assistive global meesage to improve screen reader vocalization.
   * @param event
   */
  handleClick(event) {
    event?.preventDefault();
    if (event?.target === this.host && this.cxAtMessage) {
      const message = Array.isArray(this.cxAtMessage) ? this.cxAtMessage.join("\n") : this.cxAtMessage;
      this.globalMessageService.get().pipe(take(1)).subscribe((globalMessageEntities) => {
        if (globalMessageEntities[GlobalMessageType.MSG_TYPE_ASSISTIVE]) {
          this.globalMessageService.remove(GlobalMessageType.MSG_TYPE_ASSISTIVE);
        }
        this.globalMessageService.add(message, GlobalMessageType.MSG_TYPE_ASSISTIVE);
      });
    }
  }
};
_AtMessageDirective.\u0275fac = function AtMessageDirective_Factory(t) {
  return new (t || _AtMessageDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(TemplateRef, 8), \u0275\u0275directiveInject(GlobalMessageService));
};
_AtMessageDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AtMessageDirective,
  selectors: [["", "cxAtMessage", ""]],
  hostBindings: function AtMessageDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function AtMessageDirective_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
  },
  inputs: {
    cxAtMessage: "cxAtMessage"
  }
});
var AtMessageDirective = _AtMessageDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AtMessageDirective, [{
    type: Directive,
    args: [{
      selector: "[cxAtMessage]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }, {
    type: GlobalMessageService
  }], {
    cxAtMessage: [{
      type: Input
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var PopoverEvent;
(function(PopoverEvent2) {
  PopoverEvent2["INSIDE_CLICK"] = "insideClick";
  PopoverEvent2["OUTSIDE_CLICK"] = "outsideClick";
  PopoverEvent2["ESCAPE_KEYDOWN"] = "escapeKeydown";
  PopoverEvent2["CLOSE_BUTTON_CLICK"] = "closeButtonClick";
  PopoverEvent2["CLOSE_BUTTON_KEYDOWN"] = "closeButtonKeydown";
  PopoverEvent2["ROUTE_CHANGE"] = "routeChange";
  PopoverEvent2["OPEN"] = "open";
  PopoverEvent2["OPEN_BY_KEYBOARD"] = "openByKeyboard";
})(PopoverEvent || (PopoverEvent = {}));
var _PositioningService = class _PositioningService {
  constructor(winRef) {
    this.winRef = winRef;
  }
  get allowedPlacements() {
    return ["top", "bottom", "left", "right", "top-left", "top-right", "bottom-left", "bottom-right", "left-top", "left-bottom", "right-top", "right-bottom"];
  }
  get placementSeparator() {
    return /\s+/;
  }
  get window() {
    return this.winRef.nativeWindow;
  }
  get document() {
    return this.winRef.document;
  }
  getAllStyles(element) {
    return this.window?.getComputedStyle(element);
  }
  getPositionStyleProperty(element) {
    const styles = this.getAllStyles(element);
    if (styles) {
      return styles["position"] || void 0;
    }
  }
  isStaticPositioned(element) {
    return (this.getPositionStyleProperty(element) || "static") === "static";
  }
  offsetParent(element) {
    let offsetParentEl = element.offsetParent || this.document.documentElement;
    while (offsetParentEl && offsetParentEl !== this.document.documentElement && this.isStaticPositioned(offsetParentEl)) {
      offsetParentEl = offsetParentEl.offsetParent;
    }
    return offsetParentEl || this.document.documentElement;
  }
  position(element, round = true) {
    let elPosition;
    let parentOffset = {
      width: 0,
      height: 0,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    if (this.getPositionStyleProperty(element) === "fixed") {
      elPosition = element.getBoundingClientRect();
      elPosition = {
        top: elPosition.top,
        bottom: elPosition.bottom,
        left: elPosition.left,
        right: elPosition.right,
        height: elPosition.height,
        width: elPosition.width
      };
    } else {
      const offsetParentEl = this.offsetParent(element);
      elPosition = this.offset(element, false);
      if (offsetParentEl !== this.document.documentElement) {
        parentOffset = this.offset(offsetParentEl, false);
      }
      parentOffset.top += offsetParentEl.clientTop;
      parentOffset.left += offsetParentEl.clientLeft;
    }
    elPosition.top -= parentOffset.top;
    elPosition.bottom -= parentOffset.top;
    elPosition.left -= parentOffset.left;
    elPosition.right -= parentOffset.left;
    if (round) {
      elPosition.top = Math.round(elPosition.top);
      elPosition.bottom = Math.round(elPosition.bottom);
      elPosition.left = Math.round(elPosition.left);
      elPosition.right = Math.round(elPosition.right);
    }
    return elPosition;
  }
  offset(element, round = true) {
    const elBcr = element.getBoundingClientRect();
    const viewportOffset = {
      top: this.window && this.window.pageYOffset - this.document.documentElement.clientTop || 0,
      left: this.window && this.window.pageXOffset - this.document.documentElement.clientLeft || 0
    };
    const elOffset = {
      height: elBcr.height || element.offsetHeight,
      width: elBcr.width || element.offsetWidth,
      top: elBcr.top + viewportOffset.top,
      bottom: elBcr.bottom + viewportOffset.top,
      left: elBcr.left + viewportOffset.left,
      right: elBcr.right + viewportOffset.left
    };
    if (round) {
      elOffset.height = Math.round(elOffset.height);
      elOffset.width = Math.round(elOffset.width);
      elOffset.top = Math.round(elOffset.top);
      elOffset.bottom = Math.round(elOffset.bottom);
      elOffset.left = Math.round(elOffset.left);
      elOffset.right = Math.round(elOffset.right);
    }
    return elOffset;
  }
  /*
    Return false if the element to position is outside the viewport.
  */
  _positionElements(hostElement, targetElement, placement, appendToBody) {
    const [placementPrimary = "top", placementSecondary = "center"] = placement.split("-");
    const hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);
    const targetElStyles = this.getAllStyles(targetElement);
    if (targetElStyles) {
      const marginTop = parseFloat(targetElStyles.marginTop);
      const marginBottom = parseFloat(targetElStyles.marginBottom);
      const marginLeft = parseFloat(targetElStyles.marginLeft);
      const marginRight = parseFloat(targetElStyles.marginRight);
      let topPosition = 0;
      let leftPosition = 0;
      switch (placementPrimary) {
        case "top":
          topPosition = hostElPosition.top - (targetElement.offsetHeight + marginTop + marginBottom);
          break;
        case "bottom":
          topPosition = hostElPosition.top + hostElPosition.height;
          break;
        case "left":
          leftPosition = hostElPosition.left - (targetElement.offsetWidth + marginLeft + marginRight);
          break;
        case "right":
          leftPosition = hostElPosition.left + hostElPosition.width;
          break;
      }
      switch (placementSecondary) {
        case "top":
          topPosition = hostElPosition.top;
          break;
        case "bottom":
          topPosition = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;
          break;
        case "left":
          leftPosition = hostElPosition.left;
          break;
        case "right":
          leftPosition = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;
          break;
        case "center":
          if (placementPrimary === "top" || placementPrimary === "bottom") {
            leftPosition = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;
          } else {
            topPosition = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;
          }
          break;
      }
      targetElement.style.transform = `translate(${Math.round(leftPosition)}px, ${Math.round(topPosition)}px)`;
      const targetElBCR = targetElement.getBoundingClientRect();
      const html = this.document.documentElement;
      const windowHeight = this.window?.innerHeight || html.clientHeight;
      const windowWidth = this.window?.innerWidth || html.clientWidth;
      return targetElBCR.left >= 0 && targetElBCR.top >= 0 && targetElBCR.right <= windowWidth && targetElBCR.bottom <= windowHeight;
    }
    return false;
  }
  /*
   * Accept the placement array and applies the appropriate placement dependent on the viewport.
   * Returns the applied placement.
   * In case of auto placement, placements are selected in order
   *   'top', 'bottom', 'left', 'right',
   *   'top-left', 'top-right',
   *   'bottom-left', 'bottom-right',
   *   'left-top', 'left-bottom',
   *   'right-top', 'right-bottom'.
   * */
  positionElements(hostElement, targetElement, placement, appendToBody) {
    const placementVals = Array.isArray(placement) ? placement : placement.split(this.placementSeparator);
    let hasAuto = placementVals.findIndex((val) => val === "auto");
    if (hasAuto >= 0) {
      this.allowedPlacements.forEach((obj) => {
        if (placementVals.find((val) => val.search("^" + obj) !== -1) == null) {
          placementVals.splice(hasAuto++, 1, obj);
        }
      });
    }
    const style = targetElement.style;
    style.position = "absolute";
    style.top = "0";
    style.left = "0";
    let testPlacement = "auto";
    let isInViewport = false;
    for (testPlacement of placementVals) {
      if (this._positionElements(hostElement, targetElement, testPlacement, appendToBody)) {
        isInViewport = true;
        break;
      }
    }
    if (!isInViewport) {
      this._positionElements(hostElement, targetElement, testPlacement, appendToBody);
    }
    return testPlacement;
  }
  getPositioningClass(position, autoPositioning) {
    let positionClass = `${position || "top"}`;
    if (autoPositioning && positionClass !== "auto") {
      positionClass = `${positionClass} auto`;
    }
    return positionClass;
  }
};
_PositioningService.\u0275fac = function PositioningService_Factory(t) {
  return new (t || _PositioningService)(\u0275\u0275inject(WindowRef));
};
_PositioningService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PositioningService,
  factory: _PositioningService.\u0275fac,
  providedIn: "root"
});
var PositioningService = _PositioningService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PositioningService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: WindowRef
  }], null);
})();
var _PopoverComponent = class _PopoverComponent {
  /**
   * Listens for click inside popover component wrapper.
   */
  insideClick() {
    this.eventSubject.next(PopoverEvent.INSIDE_CLICK);
  }
  /**
   * Listens for every document click and ignores clicks
   * inside component.
   */
  outsideClick(event) {
    if (!this.isClickedOnPopover(event) && !this.isClickedOnDirective(event)) {
      this.eventSubject.next(PopoverEvent.OUTSIDE_CLICK);
    }
  }
  /**
   * Listens for `escape` keydown event.
   */
  escapeKeydown() {
    this.eventSubject.next(PopoverEvent.ESCAPE_KEYDOWN);
  }
  isClickedOnPopover(event) {
    return this.popoverInstance.location.nativeElement.contains(event.target);
  }
  isClickedOnDirective(event) {
    return this.triggerElement.nativeElement.contains(event.target);
  }
  /**
   * Emits close event trigger.
   */
  close(event) {
    event.preventDefault();
    if (event instanceof MouseEvent) {
      this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_CLICK);
    } else {
      this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
    }
  }
  /**
   * Method uses `Renderer2` service to listen window scroll event.
   *
   * Registered only if property `positionOnScroll` is set to `true`.
   */
  triggerScrollEvent() {
    this.scrollEventUnlistener = this.renderer.listen(this.winRef.nativeWindow, "scroll", () => this.positionPopover());
  }
  /**
   * Method uses positioning service calculation and based on that
   * updates class name for popover component instance.
   */
  positionPopover() {
    this.popoverClass = this.positioningService.positionElements(this.triggerElement.nativeElement, this.popoverInstance.location.nativeElement, this.positioningService.getPositioningClass(this.position, this.autoPositioning), this.appendToBody);
    this.changeDetectionRef.markForCheck();
    this.baseClass = `${this.customClass} ${this.popoverClass} opened`;
  }
  ngOnInit() {
    if (!this.customClass) {
      this.customClass = "cx-popover";
    }
    if (!this.position) {
      this.position = "top";
    }
    if (this.autoPositioning === void 0) {
      this.autoPositioning = true;
    }
    this.baseClass = `${this.customClass}`;
    this.resizeSub = this.winRef.resize$.subscribe(() => {
      this.positionPopover();
    });
    this.routeChangeSub = this.router.events.pipe(filter((event) => event instanceof NavigationStart)).subscribe(() => {
      this.eventSubject.next(PopoverEvent.ROUTE_CHANGE);
    });
    if (this.positionOnScroll) {
      this.triggerScrollEvent();
    }
  }
  /**
   * indicates if passed content is a TemplateRef or string.
   */
  isTemplate(content) {
    return content instanceof TemplateRef;
  }
  isString(content) {
    return !(content instanceof TemplateRef);
  }
  ngAfterViewChecked() {
    this.positionPopover();
  }
  ngOnDestroy() {
    if (this.resizeSub) {
      this.resizeSub.unsubscribe();
    }
    if (this.routeChangeSub) {
      this.routeChangeSub.unsubscribe();
    }
    if (this.scrollEventUnlistener) {
      this.scrollEventUnlistener();
    }
  }
  constructor(positioningService, winRef, changeDetectionRef, renderer, router) {
    this.positioningService = positioningService;
    this.winRef = winRef;
    this.changeDetectionRef = changeDetectionRef;
    this.renderer = renderer;
    this.router = router;
    this.iconTypes = ICON_TYPE;
  }
};
_PopoverComponent.\u0275fac = function PopoverComponent_Factory(t) {
  return new (t || _PopoverComponent)(\u0275\u0275directiveInject(PositioningService), \u0275\u0275directiveInject(WindowRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Router));
};
_PopoverComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PopoverComponent,
  selectors: [["cx-popover"]],
  hostVars: 1,
  hostBindings: function PopoverComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function PopoverComponent_click_HostBindingHandler() {
        return ctx.insideClick();
      })("click", function PopoverComponent_click_HostBindingHandler($event) {
        return ctx.outsideClick($event);
      }, false, \u0275\u0275resolveDocument)("keydown.escape", function PopoverComponent_keydown_escape_HostBindingHandler() {
        return ctx.escapeKeydown();
      });
    }
    if (rf & 2) {
      \u0275\u0275hostProperty("className", ctx.baseClass);
    }
  },
  decls: 6,
  vars: 4,
  consts: [[1, "arrow"], [1, "popover-body", 3, "cxFocus"], [1, "cx-close-row"], ["type", "button", "class", "close", 3, "keydown.enter", "keydown.space", "click", 4, "ngIf"], [4, "ngIf"], ["type", "button", 1, "close", 3, "keydown.enter", "keydown.space", "click"], [3, "type"], [4, "ngTemplateOutlet"]],
  template: function PopoverComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "div", 0);
      \u0275\u0275elementStart(1, "div", 1)(2, "div", 2);
      \u0275\u0275template(3, PopoverComponent_button_3_Template, 2, 1, "button", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, PopoverComponent_ng_container_4_Template, 2, 1, "ng-container", 4)(5, PopoverComponent_span_5_Template, 2, 1, "span", 4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("cxFocus", ctx.focusConfig);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.displayCloseButton);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isTemplate(ctx.content));
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isString(ctx.content));
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, FocusDirective, IconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var PopoverComponent = _PopoverComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverComponent, [{
    type: Component,
    args: [{
      selector: "cx-popover",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div class="arrow"></div>\n<div class="popover-body" [cxFocus]="focusConfig">\n  <div class="cx-close-row">\n    <button\n      *ngIf="displayCloseButton"\n      type="button"\n      class="close"\n      (keydown.enter)="close($event)"\n      (keydown.space)="close($event)"\n      (click)="close($event)"\n    >\n      <cx-icon [type]="iconTypes.CLOSE"></cx-icon>\n    </button>\n  </div>\n  <ng-container *ngIf="isTemplate(content)">\n    <ng-container *ngTemplateOutlet="content"></ng-container>\n  </ng-container>\n  <span *ngIf="isString(content)">{{ content }}</span>\n</div>\n'
    }]
  }], () => [{
    type: PositioningService
  }, {
    type: WindowRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: Router
  }], {
    baseClass: [{
      type: HostBinding,
      args: ["className"]
    }],
    insideClick: [{
      type: HostListener,
      args: ["click"]
    }],
    outsideClick: [{
      type: HostListener,
      args: ["document:click", ["$event"]]
    }],
    escapeKeydown: [{
      type: HostListener,
      args: ["keydown.escape"]
    }]
  });
})();
var _PopoverService = class _PopoverService {
  /**
   * For a11y improvements method returns different `FocusConfig`
   * based on which event popover was triggered.
   */
  getFocusConfig(event, appendToBody) {
    let config = {};
    if (event === PopoverEvent.OPEN_BY_KEYBOARD && appendToBody) {
      config = {
        trap: true,
        block: true,
        focusOnEscape: false,
        autofocus: true
      };
    }
    return config;
  }
  setFocusOnElement(element, focusConfig, appendToBody) {
    if (focusConfig && appendToBody) {
      element.nativeElement.focus();
    }
  }
};
_PopoverService.\u0275fac = function PopoverService_Factory(t) {
  return new (t || _PopoverService)();
};
_PopoverService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PopoverService,
  factory: _PopoverService.\u0275fac,
  providedIn: "root"
});
var PopoverService = _PopoverService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _PopoverDirective = class _PopoverDirective {
  /**
   * Listen events fired on element binded to popover directive.
   *
   * Based on event type some a11y improvements can be made.
   * For example if popover was opened by `space` or `enter` key
   * dedicated `FocusConfig` can be set to autofocus first
   * focusable element in popover container.
   */
  handlePress(event) {
    event?.preventDefault();
    if (event?.target === this.element.nativeElement && !this.isOpen) {
      this.eventSubject.next(PopoverEvent.OPEN_BY_KEYBOARD);
    } else if (this.isOpen) {
      this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
    }
  }
  handleTab() {
    if (!this.focusConfig?.trap && this.isOpen) {
      this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
    }
  }
  handleEscape() {
    this.eventSubject.next(PopoverEvent.ESCAPE_KEYDOWN);
  }
  handleClick(event) {
    event?.preventDefault();
    if (event?.target === this.element.nativeElement && !this.isOpen) {
      this.eventSubject.next(PopoverEvent.OPEN);
    } else if (this.isOpen) {
      this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_CLICK);
    }
  }
  /**
   * Method performs open action for popover component.
   */
  open(event) {
    if (!this.cxPopoverOptions?.disable) {
      this.isOpen = true;
      this.focusConfig = this.popoverService.getFocusConfig(event, this.cxPopoverOptions?.appendToBody || false);
      this.renderPopover();
      this.openPopover.emit();
    }
  }
  /**
   * Method performs close action for popover component.
   */
  close() {
    this.isOpen = false;
    this.viewContainer.clear();
    this.closePopover.emit();
  }
  /**
   * Method subscribes for events emitted by popover component
   * and based on event performs specific action.
   */
  handlePopoverEvents() {
    this.eventSubject.subscribe((event) => {
      if (this.openTriggerEvents.includes(event)) {
        this.open(event);
      }
      if (this.focusPopoverTriggerEvents.includes(event)) {
        this.popoverContainer.location.nativeElement.focus();
      }
      if (this.closeTriggerEvents.includes(event)) {
        this.close();
      }
      if (this.focusDirectiveTriggerEvents.includes(event)) {
        this.popoverService.setFocusOnElement(this.element, this.focusConfig, this.cxPopoverOptions?.appendToBody);
      }
    });
  }
  /**
   * Method creates instance and pass parameters to popover component.
   */
  renderPopover() {
    const containerFactory = this.componentFactoryResolver.resolveComponentFactory(PopoverComponent);
    this.popoverContainer = this.viewContainer.createComponent(containerFactory);
    const componentInstance = this.popoverContainer.instance;
    if (componentInstance) {
      componentInstance.content = this.cxPopover;
      componentInstance.triggerElement = this.element;
      componentInstance.popoverInstance = this.popoverContainer;
      componentInstance.focusConfig = this.focusConfig;
      componentInstance.eventSubject = this.eventSubject;
      componentInstance.position = this.cxPopoverOptions?.placement;
      componentInstance.customClass = this.cxPopoverOptions?.class;
      componentInstance.appendToBody = this.cxPopoverOptions?.appendToBody;
      componentInstance.positionOnScroll = this.cxPopoverOptions?.positionOnScroll;
      componentInstance.displayCloseButton = this.cxPopoverOptions?.displayCloseButton;
      componentInstance.autoPositioning = this.cxPopoverOptions?.autoPositioning;
      if (this.cxPopoverOptions?.appendToBody) {
        this.renderer.appendChild(this.winRef.document.body, this.popoverContainer.location.nativeElement);
      }
      this.popoverContainer.changeDetectorRef.detectChanges();
    }
  }
  ngOnInit() {
    this.handlePopoverEvents();
  }
  constructor(element, viewContainer, componentFactoryResolver, renderer, changeDetectorRef, popoverService, winRef) {
    this.element = element;
    this.viewContainer = viewContainer;
    this.componentFactoryResolver = componentFactoryResolver;
    this.renderer = renderer;
    this.changeDetectorRef = changeDetectorRef;
    this.popoverService = popoverService;
    this.winRef = winRef;
    this.openPopover = new EventEmitter();
    this.closePopover = new EventEmitter();
    this.eventSubject = new Subject();
    this.openTriggerEvents = [PopoverEvent.OPEN, PopoverEvent.OPEN_BY_KEYBOARD];
    this.focusPopoverTriggerEvents = [PopoverEvent.OPEN_BY_KEYBOARD];
    this.closeTriggerEvents = [PopoverEvent.ROUTE_CHANGE, PopoverEvent.ESCAPE_KEYDOWN, PopoverEvent.OUTSIDE_CLICK, PopoverEvent.CLOSE_BUTTON_KEYDOWN, PopoverEvent.CLOSE_BUTTON_CLICK];
    this.focusDirectiveTriggerEvents = [PopoverEvent.ESCAPE_KEYDOWN, PopoverEvent.CLOSE_BUTTON_KEYDOWN];
  }
};
_PopoverDirective.\u0275fac = function PopoverDirective_Factory(t) {
  return new (t || _PopoverDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(ComponentFactoryResolver$1), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(PopoverService), \u0275\u0275directiveInject(WindowRef));
};
_PopoverDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PopoverDirective,
  selectors: [["", "cxPopover", ""]],
  hostBindings: function PopoverDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown.enter", function PopoverDirective_keydown_enter_HostBindingHandler($event) {
        return ctx.handlePress($event);
      })("keydown.space", function PopoverDirective_keydown_space_HostBindingHandler($event) {
        return ctx.handlePress($event);
      })("keydown.tab", function PopoverDirective_keydown_tab_HostBindingHandler() {
        return ctx.handleTab();
      })("keydown.shift.tab", function PopoverDirective_keydown_shift_tab_HostBindingHandler() {
        return ctx.handleTab();
      })("keydown.escape", function PopoverDirective_keydown_escape_HostBindingHandler() {
        return ctx.handleEscape();
      })("click", function PopoverDirective_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
  },
  inputs: {
    cxPopover: "cxPopover",
    cxPopoverOptions: "cxPopoverOptions"
  },
  outputs: {
    openPopover: "openPopover",
    closePopover: "closePopover"
  }
});
var PopoverDirective = _PopoverDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverDirective, [{
    type: Directive,
    args: [{
      selector: "[cxPopover]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: PopoverService
  }, {
    type: WindowRef
  }], {
    cxPopover: [{
      type: Input
    }],
    cxPopoverOptions: [{
      type: Input
    }],
    openPopover: [{
      type: Output
    }],
    closePopover: [{
      type: Output
    }],
    handlePress: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }],
    handleTab: [{
      type: HostListener,
      args: ["keydown.tab"]
    }, {
      type: HostListener,
      args: ["keydown.shift.tab"]
    }],
    handleEscape: [{
      type: HostListener,
      args: ["keydown.escape"]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var defaultLimit = 20;
var _TruncatePipe = class _TruncatePipe {
  /**
   * example usage {{ exampleString | cxTruncate: [1, ''] }}
   */
  transform(value, args) {
    if (!args) {
      return value;
    }
    let trail = "...";
    const limit = args.length > 0 && args[0] && Number.isInteger(+args[0]) ? args[0] : defaultLimit;
    if (args.length > 1 && args[1] !== void 0) {
      trail = args[1];
    }
    return value.length > limit ? value.substring(0, limit) + trail : value;
  }
};
_TruncatePipe.\u0275fac = function TruncatePipe_Factory(t) {
  return new (t || _TruncatePipe)();
};
_TruncatePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "cxTruncate",
  type: _TruncatePipe,
  pure: true
});
var TruncatePipe = _TruncatePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TruncatePipe, [{
    type: Pipe,
    args: [{
      name: "cxTruncate"
    }]
  }], null, null);
})();
var _TruncateTextPopoverComponent = class _TruncateTextPopoverComponent {
  constructor() {
    this.charactersLimit = 100;
  }
  get isTruncated() {
    return this.content.length > +this.charactersLimit;
  }
};
_TruncateTextPopoverComponent.\u0275fac = function TruncateTextPopoverComponent_Factory(t) {
  return new (t || _TruncateTextPopoverComponent)();
};
_TruncateTextPopoverComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TruncateTextPopoverComponent,
  selectors: [["cx-truncate-text-popover"]],
  inputs: {
    content: "content",
    charactersLimit: "charactersLimit",
    customClass: "customClass"
  },
  decls: 8,
  vars: 8,
  consts: [["fullText", ""], [1, "truncated-text", 3, "ngClass"], ["class", "ml-1 link cx-action-link", 3, "cxPopover", "cxPopoverOptions", 4, "ngIf"], [1, "ml-1", "link", "cx-action-link", 3, "cxPopover", "cxPopoverOptions"]],
  template: function TruncateTextPopoverComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainerStart(0)(1);
      \u0275\u0275elementStart(2, "span", 1);
      \u0275\u0275text(3);
      \u0275\u0275pipe(4, "cxTruncate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementContainerEnd();
      \u0275\u0275template(5, TruncateTextPopoverComponent_ng_template_5_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(7, TruncateTextPopoverComponent_button_7_Template, 3, 6, "button", 2);
      \u0275\u0275elementContainerEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngClass", ctx.customClass);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(4, 3, ctx.content, \u0275\u0275pureFunction1(6, _c92, ctx.charactersLimit)), " ");
      \u0275\u0275advance(4);
      \u0275\u0275property("ngIf", ctx.isTruncated);
    }
  },
  dependencies: [NgClass, NgIf, PopoverDirective, TranslatePipe, TruncatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var TruncateTextPopoverComponent = _TruncateTextPopoverComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TruncateTextPopoverComponent, [{
    type: Component,
    args: [{
      selector: "cx-truncate-text-popover",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container>
  <ng-container>
    <span class="truncated-text" [ngClass]="customClass">
      {{ content | cxTruncate: [charactersLimit] }}
    </span>
  </ng-container>

  <ng-template #fullText>
    {{ content }}
  </ng-template>

  <button
    *ngIf="isTruncated"
    [cxPopover]="fullText"
    [cxPopoverOptions]="{
      placement: 'auto',
      appendToBody: true,
      displayCloseButton: true
    }"
    class="ml-1 link cx-action-link"
  >
    {{ 'common.more' | cxTranslate }}
  </button>
</ng-container>
`
    }]
  }], null, {
    content: [{
      type: Input
    }],
    charactersLimit: [{
      type: Input
    }],
    customClass: [{
      type: Input
    }]
  });
})();
var _CardComponent = class _CardComponent {
  // ACTIONS
  setEditMode() {
    this.editMode = true;
  }
  cancelEdit() {
    this.editMode = false;
    this.cancelCard.emit(5);
  }
  delete() {
    this.deleteCard.emit(1);
  }
  setDefault() {
    this.isDefault = true;
    this.setDefaultCard.emit(2);
  }
  send() {
    this.sendCard.emit(3);
  }
  edit() {
    this.editCard.emit(4);
  }
  isCardAction(action) {
    return action.event !== void 0;
  }
  isCardLinkAction(action) {
    return action.link !== void 0;
  }
  constructor() {
    this.iconTypes = ICON_TYPE;
    this.deleteCard = new EventEmitter();
    this.setDefaultCard = new EventEmitter();
    this.sendCard = new EventEmitter();
    this.editCard = new EventEmitter();
    this.cancelCard = new EventEmitter();
    this.border = false;
    this.editMode = false;
    this.isDefault = false;
    this.fitToContainer = false;
    this.truncateText = false;
    this.charactersLimit = 100;
  }
  /* eslint @angular-eslint/no-empty-lifecycle-method: 1 */
  ngOnInit() {
  }
};
_CardComponent.\u0275fac = function CardComponent_Factory(t) {
  return new (t || _CardComponent)();
};
_CardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CardComponent,
  selectors: [["cx-card"]],
  inputs: {
    border: "border",
    editMode: "editMode",
    isDefault: "isDefault",
    content: "content",
    fitToContainer: "fitToContainer",
    truncateText: "truncateText",
    charactersLimit: "charactersLimit",
    index: "index"
  },
  outputs: {
    deleteCard: "deleteCard",
    setDefaultCard: "setDefaultCard",
    sendCard: "sendCard",
    editCard: "editCard",
    cancelCard: "cancelCard"
  },
  ngContentSelectors: _c122,
  decls: 1,
  vars: 1,
  consts: [["truncate", ""], ["class", "cx-card", 3, "tabindex", "cx-card-border", "cx-card-fit-to-container", 4, "ngIf"], [1, "cx-card", 3, "tabindex"], ["class", "card-header", 3, "id", 4, "ngIf"], [1, "card-body", "cx-card-body"], ["role", "alert", "class", "cx-card-delete-msg", 4, "ngIf"], ["class", "cx-card-title", 4, "ngIf"], [1, "cx-card-container"], [1, "cx-card-label-container"], ["class", "cx-card-label-bold", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["class", "cx-card-paragraph", 4, "ngFor", "ngForOf"], ["class", "cx-card-img-container", 4, "ngIf"], ["class", "row cx-card-body-delete", 4, "ngIf"], ["class", "cx-card-actions", 4, "ngIf"], [1, "card-header", 3, "id"], ["role", "alert", 1, "cx-card-delete-msg"], [1, "cx-card-title"], [1, "cx-card-label-bold"], ["class", "cx-card-label", 3, "ngClass", 4, "ngIf", "ngIfElse"], [1, "cx-card-label", 3, "ngClass"], [3, "charactersLimit", "content", "customClass"], [1, "cx-card-paragraph"], [1, "cx-card-paragraph-title"], [1, "cx-card-paragraph-text"], [1, "cx-card-img-container"], [3, "type"], [1, "row", "cx-card-body-delete"], [1, "col-md-6"], [1, "btn", "btn-block", "btn-secondary", 3, "click", "cxAtMessage"], [1, "col-md-6", 3, "cxFocus"], [1, "btn", "btn-block", "btn-primary", 3, "click"], [1, "cx-card-actions"], [3, "ngSwitch", 4, "ngIf"], ["class", "link cx-action-link", 3, "href", 4, "ngIf"], [3, "ngSwitch"], ["type", "button", "class", "link cx-action-link", 3, "click", 4, "ngSwitchCase"], ["type", "button", 1, "link", "cx-action-link", 3, "click"], [1, "link", "cx-action-link", 3, "href"]],
  template: function CardComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c11);
      \u0275\u0275template(0, CardComponent_div_0_Template, 15, 23, "div", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.content);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgSwitch, NgSwitchCase, AtMessageDirective, IconComponent, TruncateTextPopoverComponent, FocusDirective, TranslatePipe],
  encapsulation: 2
});
var CardComponent = _CardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardComponent, [{
    type: Component,
    args: [{
      selector: "cx-card",
      template: `<div
  *ngIf="content"
  class="cx-card"
  [tabindex]="border ? 0 : -1"
  [attr.role]="content.role ?? null"
  [attr.aria-label]="
    content.label ? (content.label | cxTranslate: { number: this.index }) : null
  "
  [class.cx-card-border]="border"
  [class.cx-card-fit-to-container]="fitToContainer"
>
  <!-- Card Header -->
  <div
    *ngIf="content.header && !editMode"
    class="card-header"
    [id]="'content-header' + (index >= 0 ? '-' + index : '')"
  >
    {{ content.header }}
  </div>
  <!-- Card Body -->
  <div class="card-body cx-card-body" [class.cx-card-delete]="editMode">
    <!-- Edit message -->
    <div *ngIf="editMode" role="alert" class="cx-card-delete-msg">
      {{ content.deleteMsg }}
    </div>
    <!-- Card title -->
    <span *ngIf="content.title" class="cx-card-title">
      {{ content.title }}
    </span>
    <!-- Card Content -->
    <div class="cx-card-container">
      <!-- Card Label -->
      <div class="cx-card-label-container">
        <div *ngIf="content.textBold" class="cx-card-label-bold">
          {{ content.textBold }}
        </div>
        <div *ngFor="let line of content.text">
          <div
            *ngIf="!truncateText; else truncate"
            class="cx-card-label"
            [ngClass]="content.customClass"
          >
            {{ line }}
          </div>

          <ng-template #truncate>
            <cx-truncate-text-popover
              [charactersLimit]="charactersLimit"
              [content]="line"
              [customClass]="content.customClass"
            ></cx-truncate-text-popover>
          </ng-template>
        </div>
        <div class="cx-card-paragraph" *ngFor="let item of content.paragraphs">
          <div class="cx-card-paragraph-title">{{ item.title }}</div>
          <div *ngFor="let text of item.text">
            <div class="cx-card-paragraph-text">
              {{ text }}
            </div>
          </div>
        </div>
        <ng-content select="[label_container_bottom]"></ng-content>
      </div>
      <!-- Image -->
      <div *ngIf="content.img" class="cx-card-img-container">
        <cx-icon [type]="content.img"></cx-icon>
      </div>
    </div>
    <!-- Edit Mode Actions -->
    <div *ngIf="editMode" class="row cx-card-body-delete">
      <div class="col-md-6">
        <button
          [cxAtMessage]="'assistiveMessage.actionCancelled' | cxTranslate"
          class="btn btn-block btn-secondary"
          (click)="cancelEdit()"
        >
          {{ 'common.cancel' | cxTranslate }}
        </button>
      </div>
      <div class="col-md-6" [cxFocus]="{ autofocus: true }">
        <button class="btn btn-block btn-primary" (click)="delete()">
          {{ 'common.delete' | cxTranslate }}
        </button>
      </div>
    </div>
    <!-- Actions -->
    <div *ngIf="content.actions && !editMode" class="cx-card-actions">
      <div *ngFor="let action of content.actions">
        <div>
          <ng-container *ngIf="isCardAction(action)" [ngSwitch]="action.event">
            <button
              type="button"
              *ngSwitchCase="'delete'"
              class="link cx-action-link"
              (click)="delete()"
            >
              {{ action.name }}
            </button>
            <button
              type="button"
              *ngSwitchCase="'default'"
              class="link cx-action-link"
              (click)="setDefault()"
            >
              {{ action.name }}
            </button>
            <button
              type="button"
              *ngSwitchCase="'send'"
              class="link cx-action-link"
              (click)="send()"
              [attr.aria-describedby]="
                index >= 0 && content.header && !editMode
                  ? 'content-header-' + index
                  : null
              "
            >
              {{ action.name }}
            </button>
            <button
              type="button"
              *ngSwitchCase="'edit'"
              class="link cx-action-link"
              (click)="edit()"
            >
              {{ action.name }}
            </button>
          </ng-container>
          <a
            *ngIf="isCardLinkAction(action)"
            href="{{ action.link }}"
            class="link cx-action-link"
          >
            {{ action.name }}
          </a>
        </div>
      </div>
    </div>
  </div>
</div>
`
    }]
  }], () => [], {
    deleteCard: [{
      type: Output
    }],
    setDefaultCard: [{
      type: Output
    }],
    sendCard: [{
      type: Output
    }],
    editCard: [{
      type: Output
    }],
    cancelCard: [{
      type: Output
    }],
    border: [{
      type: Input
    }],
    editMode: [{
      type: Input
    }],
    isDefault: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    fitToContainer: [{
      type: Input
    }],
    truncateText: [{
      type: Input
    }],
    charactersLimit: [{
      type: Input
    }],
    index: [{
      type: Input
    }]
  });
})();
var _PopoverModule = class _PopoverModule {
};
_PopoverModule.\u0275fac = function PopoverModule_Factory(t) {
  return new (t || _PopoverModule)();
};
_PopoverModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PopoverModule
});
_PopoverModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule, KeyboardFocusModule, IconModule]
});
var PopoverModule = _PopoverModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, KeyboardFocusModule, IconModule],
      declarations: [PopoverDirective, PopoverComponent],
      exports: [PopoverDirective, PopoverComponent]
    }]
  }], null, null);
})();
var _TruncateTextPopoverModule = class _TruncateTextPopoverModule {
};
_TruncateTextPopoverModule.\u0275fac = function TruncateTextPopoverModule_Factory(t) {
  return new (t || _TruncateTextPopoverModule)();
};
_TruncateTextPopoverModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TruncateTextPopoverModule
});
_TruncateTextPopoverModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule, PopoverModule]
});
var TruncateTextPopoverModule = _TruncateTextPopoverModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TruncateTextPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, PopoverModule],
      declarations: [TruncateTextPopoverComponent, TruncatePipe],
      exports: [TruncateTextPopoverComponent, TruncatePipe]
    }]
  }], null, null);
})();
var _AtMessageModule = class _AtMessageModule {
};
_AtMessageModule.\u0275fac = function AtMessageModule_Factory(t) {
  return new (t || _AtMessageModule)();
};
_AtMessageModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _AtMessageModule
});
_AtMessageModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var AtMessageModule = _AtMessageModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AtMessageModule, [{
    type: NgModule,
    args: [{
      declarations: [AtMessageDirective],
      exports: [AtMessageDirective]
    }]
  }], null, null);
})();
var _CardModule = class _CardModule {
};
_CardModule.\u0275fac = function CardModule_Factory(t) {
  return new (t || _CardModule)();
};
_CardModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CardModule
});
_CardModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, AtMessageModule, I18nModule, IconModule, TruncateTextPopoverModule, KeyboardFocusModule]
});
var CardModule = _CardModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, AtMessageModule, I18nModule, IconModule, TruncateTextPopoverModule, KeyboardFocusModule],
      declarations: [CardComponent],
      exports: [CardComponent]
    }]
  }], null, null);
})();
var _MediaSourcesPipe = class _MediaSourcesPipe {
  transform(sizes) {
    const sources = [];
    return sizes.split(/,\s*/).reduceRight((acc, set) => {
      let [srcset, media] = set.split(" ");
      if (!srcset || !media) {
        return acc;
      }
      media = `(min-width: ${media.replace("w", "px")})`;
      acc.push({
        srcset,
        media
      });
      return acc;
    }, sources);
  }
};
_MediaSourcesPipe.\u0275fac = function MediaSourcesPipe_Factory(t) {
  return new (t || _MediaSourcesPipe)();
};
_MediaSourcesPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "cxMediaSources",
  type: _MediaSourcesPipe,
  pure: true
});
var MediaSourcesPipe = _MediaSourcesPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaSourcesPipe, [{
    type: Pipe,
    args: [{
      name: "cxMediaSources"
    }]
  }], null, null);
})();
var ImageLoadingStrategy;
(function(ImageLoadingStrategy2) {
  ImageLoadingStrategy2["EAGER"] = "eager";
  ImageLoadingStrategy2["LAZY"] = "lazy";
})(ImageLoadingStrategy || (ImageLoadingStrategy = {}));
var USE_LEGACY_MEDIA_COMPONENT = new InjectionToken("USE_LEGACY_MEDIA_COMPONENT");
var _MediaService = class _MediaService {
  constructor(config) {
    this.config = config;
  }
  /**
   * Returns a `Media` object with the main media (`src`) and various media (`src`)
   * for specific formats.
   */
  getMedia(mediaContainer, format, alt, role) {
    if (!mediaContainer) {
      return;
    }
    const mainMedia = mediaContainer.url ? mediaContainer : this.resolveMedia(mediaContainer, format);
    return {
      src: this.resolveAbsoluteUrl(mainMedia?.url ?? ""),
      alt: alt ?? mainMedia?.altText,
      role: role ?? mainMedia?.role,
      srcset: this.resolveSrcSet(mediaContainer, format)
    };
  }
  /**
   * Reads the loading strategy from the `MediaConfig`.
   *
   * Defaults to `ImageLoadingStrategy.EAGER`.
   */
  get loadingStrategy() {
    return this.config?.imageLoadingStrategy ?? ImageLoadingStrategy.EAGER;
  }
  /**
   * Creates the media formats in a logical sorted order. The map contains the
   * format key and the format size information. We do this only once for performance
   * benefits.
   */
  get sortedFormats() {
    const mediaFormats = this.config?.mediaFormats;
    if (!this._sortedFormats && mediaFormats) {
      this._sortedFormats = Object.keys(mediaFormats).map((key) => ({
        code: key,
        size: mediaFormats[key]
      })).sort((a, b) => a.size.width && b.size.width && a.size.width > b.size.width ? 1 : -1);
    }
    return this._sortedFormats ?? [];
  }
  /**
   * Creates the media formats in a reversed sorted order.
   */
  get reversedFormats() {
    if (!this._reversedFormats) {
      this._reversedFormats = this.sortedFormats.slice().reverse();
    }
    return this._reversedFormats;
  }
  /**
   * Resolves the right media for the given format. The fo
   */
  resolveMedia(media, format) {
    return media[this.resolveFormat(media, format)];
  }
  /**
   * Validates the format against the given mediaContainer. If there is no format available,
   * or if the mediaContainer doesn't contain a media for the given media, the most optimal
   * format is resolved. If even that is not possible, the first format is returned.
   */
  resolveFormat(mediaContainer, format) {
    if (format && mediaContainer[format]) {
      return format;
    }
    return this.resolveBestFormat(mediaContainer) || Object.keys(mediaContainer)[0];
  }
  /**
   * Returns the media format code with the best size.
   */
  resolveBestFormat(media) {
    return this.reversedFormats.find((format) => media.hasOwnProperty(format.code))?.code;
  }
  /**
   * Returns a set of media for the available media formats. Additionally, the configured media
   * format width is added to the srcset, so that browsers can select the appropriate media.
   *
   * The optional maxFormat indicates that only sources till a certain format should be added
   * to the srcset.
   */
  resolveSrcSet(media, maxFormat) {
    if (!media) {
      return void 0;
    }
    let formats = this.sortedFormats;
    const max = formats.findIndex((f) => f.code === maxFormat);
    if (max > -1) {
      formats = formats.slice(0, max + 1);
    }
    const srcset = formats.reduce((set, format) => {
      const image = media[format.code];
      if (!!image) {
        if (set) {
          set += ", ";
        }
        set += `${this.resolveAbsoluteUrl(image.url ?? "")} ${format.size.width}w`;
      }
      return set;
    }, "");
    return srcset === "" ? void 0 : srcset;
  }
  /**
   * Resolves the absolute URL for the given url. In most cases, this URL represents
   * the relative URL on the backend. In that case, we prefix the url with the baseUrl.
   *
   * When we have receive an absolute URL, we return the URL as-is. An absolute URL might also
   * start with double slash, which is used to resolve media cross from http and https.
   */
  resolveAbsoluteUrl(url) {
    return !url || url.startsWith("http") || url.startsWith("//") ? url : this.getBaseUrl() + url;
  }
  /**
   * The base URL is either driven by a specific `backend.media.baseUrl`, or by the
   * `backend.occ.baseUrl`.
   *
   * The `backend.media.baseUrl` can be used to load media from a different location.
   *
   * In Commerce Cloud, a different location could mean a different "aspect".
   *
   * Defaults to empty string in case no config is provided.
   */
  getBaseUrl() {
    return this.config.backend?.media?.baseUrl ?? this.config.backend?.occ?.baseUrl ?? "";
  }
};
_MediaService.\u0275fac = function MediaService_Factory(t) {
  return new (t || _MediaService)(\u0275\u0275inject(Config));
};
_MediaService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _MediaService,
  factory: _MediaService.\u0275fac,
  providedIn: "root"
});
var MediaService = _MediaService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Config
  }], null);
})();
var _MediaComponent = class _MediaComponent {
  constructor(mediaService) {
    this.mediaService = mediaService;
    this.loading = this.loadingStrategy;
    this.loaded = new EventEmitter();
    this.isInitialized = false;
    this.isLoading = true;
    this.isMissing = false;
    this.trackByMedia = (_, item) => item.media;
    this.isLegacy = inject(USE_LEGACY_MEDIA_COMPONENT, {
      optional: true
    }) || inject(Config)["useLegacyMediaComponent"] || false;
  }
  ngOnChanges() {
    this.create();
  }
  /**
   * Creates the `Media` object
   */
  create() {
    this.media = this.mediaService.getMedia(this.container instanceof Array ? this.container[0] : this.container, this.format, this.alt, this.role);
    if (!this.media?.src) {
      this.handleMissing();
    }
  }
  /**
   * This handler is called from the UI when the image is loaded.
   */
  loadHandler() {
    this.isLoading = false;
    this.isInitialized = true;
    this.isMissing = false;
    this.loaded.emit(true);
  }
  /**
   * Indicates whether the browser should lazy load the image.
   */
  get loadingStrategy() {
    return this.mediaService.loadingStrategy === ImageLoadingStrategy.LAZY ? ImageLoadingStrategy.LAZY : null;
  }
  /**
   * Whenever an error happens during load, we mark the component
   * with css classes to have a missing media.
   */
  errorHandler() {
    this.handleMissing();
  }
  handleMissing() {
    this.isLoading = false;
    this.isInitialized = true;
    this.isMissing = true;
    this.loaded.emit(false);
  }
};
_MediaComponent.\u0275fac = function MediaComponent_Factory(t) {
  return new (t || _MediaComponent)(\u0275\u0275directiveInject(MediaService));
};
_MediaComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MediaComponent,
  selectors: [["cx-media"]],
  hostVars: 6,
  hostBindings: function MediaComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("is-initialized", ctx.isInitialized)("is-loading", ctx.isLoading)("is-missing", ctx.isMissing);
    }
  },
  inputs: {
    container: "container",
    format: "format",
    alt: "alt",
    role: "role",
    loading: "loading"
  },
  outputs: {
    loaded: "loaded"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 3,
  vars: 2,
  consts: [["tmpImg", ""], [4, "ngIf", "ngIfElse"], [3, "srcset", "media", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngTemplateOutlet"], [3, "srcset", "media"], [3, "alt", "src", "srcset", "loading", "load", "error", 4, "ngIf"], [3, "load", "error", "alt", "src", "srcset", "loading"]],
  template: function MediaComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, MediaComponent_picture_0_Template, 4, 5, "picture", 1)(1, MediaComponent_ng_template_1_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const tmpImg_r3 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", (ctx.media == null ? null : ctx.media.srcset) && !ctx.isLegacy)("ngIfElse", tmpImg_r3);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, MediaSourcesPipe],
  encapsulation: 2,
  changeDetection: 0
});
var MediaComponent = _MediaComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaComponent, [{
    type: Component,
    args: [{
      selector: "cx-media",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<picture *ngIf="media?.srcset && !isLegacy; else tmpImg">\n  <source\n    *ngFor="\n      let source of media!.srcset! | cxMediaSources;\n      trackBy: trackByMedia\n    "\n    [srcset]="source.srcset"\n    [media]="source.media"\n  />\n\n  <ng-container [ngTemplateOutlet]="tmpImg"></ng-container>\n</picture>\n\n<ng-template #tmpImg>\n  <img\n    *ngIf="media && media.src"\n    [alt]="media.alt"\n    [src]="media.src"\n    [srcset]="media.srcset || media.src"\n    [attr.role]="media.role"\n    [loading]="loading"\n    (load)="loadHandler()"\n    (error)="errorHandler()"\n  />\n</ng-template>\n'
    }]
  }], () => [{
    type: MediaService
  }], {
    container: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    alt: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    loaded: [{
      type: Output
    }],
    isInitialized: [{
      type: HostBinding,
      args: ["class.is-initialized"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.is-loading"]
    }],
    isMissing: [{
      type: HostBinding,
      args: ["class.is-missing"]
    }]
  });
})();
var _MediaModule = class _MediaModule {
  static forRoot() {
    return {
      ngModule: _MediaModule
    };
  }
};
_MediaModule.\u0275fac = function MediaModule_Factory(t) {
  return new (t || _MediaModule)();
};
_MediaModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _MediaModule
});
_MediaModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var MediaModule = _MediaModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [MediaComponent, MediaSourcesPipe],
      exports: [MediaComponent]
    }]
  }], null, null);
})();
var _CarouselModule = class _CarouselModule {
};
_CarouselModule.\u0275fac = function CarouselModule_Factory(t) {
  return new (t || _CarouselModule)();
};
_CarouselModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CarouselModule
});
_CarouselModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule, IconModule, MediaModule, UrlModule, I18nModule]
});
var CarouselModule = _CarouselModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CarouselModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, IconModule, MediaModule, UrlModule, I18nModule],
      declarations: [CarouselComponent],
      exports: [CarouselComponent]
    }]
  }], null, null);
})();
var _DatePickerService = class _DatePickerService {
  get placeholder() {
    return "yyyy-mm-dd";
  }
  /**
   * The default date pattern is based on the placeholder string;
   */
  get pattern() {
    return this.placeholder.replace("yyyy", "\\d{4}").replace("mm", "\\d{1,2}").replace("dd", "\\d{1,2}");
  }
  /**
   * Validates if the string based date value is a valid date.
   */
  isValidFormat(date, pattern) {
    const patternRegex = new RegExp(`^${pattern ?? this.pattern}$`);
    return patternRegex.test(date);
  }
  /**
   * Since Safari doesn't support proper date formats (ISO 8601), we need to do this
   * ourselves. We cannot rely on `new Date('2020-1-1')`. This will fail, only
   * `new Date('2020-01-01')` works.
   */
  getDate(value) {
    if (!value) {
      return;
    }
    const delimiter = this.placeholder.replace("yyyy", "").replace("mm", "").replace("dd", "").substring(0, 1);
    const dateParts = value.split(delimiter);
    const placeholderParts = this.placeholder.split(delimiter);
    const y = placeholderParts.indexOf("yyyy");
    const m = placeholderParts.indexOf("mm");
    const d = placeholderParts.indexOf("dd");
    return new Date(Number(dateParts[y]), Number(dateParts[m]) - 1, Number(dateParts[d]));
  }
};
_DatePickerService.\u0275fac = function DatePickerService_Factory(t) {
  return new (t || _DatePickerService)();
};
_DatePickerService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DatePickerService,
  factory: _DatePickerService.\u0275fac,
  providedIn: "root"
});
var DatePickerService = _DatePickerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _FormErrorsComponent = class _FormErrorsComponent {
  constructor(ChangeDetectionRef, keyValueDiffers) {
    this.ChangeDetectionRef = ChangeDetectionRef;
    this.keyValueDiffers = keyValueDiffers;
    this.prefix = "formErrors";
    this.role = "alert";
  }
  set control(control) {
    if (!control) {
      return;
    }
    this._control = control;
    this.differ = this.keyValueDiffers.find(this.control).create();
    this.errorsDetails$ = control?.statusChanges.pipe(startWith({}), map(() => control.errors || {}), map((errors) => Object.entries(errors).filter(([_key, details]) => details)));
  }
  get control() {
    return this._control;
  }
  ngDoCheck() {
    const changes = this.differ?.diff(this.control);
    if (changes) {
      changes.forEachChangedItem((r) => {
        if (r?.key === "touched") {
          this.ChangeDetectionRef.markForCheck();
        }
      });
    }
  }
  /**
   * Returns translation params composed of
   * the argument `errorDetails` (if only is an object) merged with
   * the component input object `translationParams`.
   *
   * In case of a conflicting object key, the value from
   * `translationParams` takes precedence.
   */
  getTranslationParams(errorDetails) {
    errorDetails = isObject(errorDetails) ? errorDetails : {};
    return __spreadValues(__spreadValues({}, errorDetails), this.translationParams);
  }
  get invalid() {
    return this.control?.invalid;
  }
  get dirty() {
    return this.control?.dirty;
  }
  get touched() {
    return this.control?.touched;
  }
  get hidden() {
    return !(this.invalid && (this.touched || this.dirty));
  }
};
_FormErrorsComponent.\u0275fac = function FormErrorsComponent_Factory(t) {
  return new (t || _FormErrorsComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(KeyValueDiffers));
};
_FormErrorsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FormErrorsComponent,
  selectors: [["cx-form-errors"]],
  hostVars: 9,
  hostBindings: function FormErrorsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("role", ctx.role);
      \u0275\u0275classProp("control-invalid", ctx.invalid)("control-dirty", ctx.dirty)("control-touched", ctx.touched)("cx-visually-hidden", ctx.hidden);
    }
  },
  inputs: {
    prefix: "prefix",
    translationParams: "translationParams",
    control: "control"
  },
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"]],
  template: function FormErrorsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, FormErrorsComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.errorsDetails$));
    }
  },
  dependencies: [NgForOf, NgIf, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var FormErrorsComponent = _FormErrorsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormErrorsComponent, [{
    type: Component,
    args: [{
      selector: "cx-form-errors",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="errorsDetails$ | async as errorDetails">
  <ng-container *ngIf="!hidden">
    <p *ngFor="let error of errorDetails">
      {{
        prefix + '.' + error[0] | cxTranslate: getTranslationParams(error[1])
      }}
    </p>
  </ng-container>
</ng-container>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: KeyValueDiffers
  }], {
    prefix: [{
      type: Input
    }],
    translationParams: [{
      type: Input
    }],
    control: [{
      type: Input
    }],
    invalid: [{
      type: HostBinding,
      args: ["class.control-invalid"]
    }],
    dirty: [{
      type: HostBinding,
      args: ["class.control-dirty"]
    }],
    touched: [{
      type: HostBinding,
      args: ["class.control-touched"]
    }],
    hidden: [{
      type: HostBinding,
      args: ["class.cx-visually-hidden"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var _DatePickerComponent = class _DatePickerComponent {
  constructor(service) {
    this.service = service;
    this.update = new EventEmitter();
  }
  change() {
    this.update.emit();
  }
  get placeholder() {
    return this.service.placeholder;
  }
  get pattern() {
    return this.service.pattern;
  }
  /**
   * Only returns the date if we have a valid format. We do this to avoid
   * loads of console errors coming from the datePipe while the user is typing
   * (in those browsers where the date picker isn't supported).
   */
  getDate(date) {
    return date && this.service.isValidFormat(date) ? date : void 0;
  }
};
_DatePickerComponent.\u0275fac = function DatePickerComponent_Factory(t) {
  return new (t || _DatePickerComponent)(\u0275\u0275directiveInject(DatePickerService));
};
_DatePickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _DatePickerComponent,
  selectors: [["cx-date-picker"]],
  inputs: {
    control: "control",
    min: "min",
    max: "max",
    required: "required"
  },
  outputs: {
    update: "update"
  },
  decls: 4,
  vars: 15,
  consts: [["type", "date", 1, "form-control", 3, "change", "formControl", "placeholder", "pattern"], ["prefix", "formErrors.date", 3, "control", "translationParams"]],
  template: function DatePickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "input", 0);
      \u0275\u0275listener("change", function DatePickerComponent_Template_input_change_0_listener() {
        return ctx.change();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275element(1, "cx-form-errors", 1);
      \u0275\u0275pipe(2, "cxDate");
      \u0275\u0275pipe(3, "cxDate");
    }
    if (rf & 2) {
      \u0275\u0275property("formControl", ctx.control)("placeholder", ctx.placeholder)("pattern", ctx.pattern);
      \u0275\u0275attribute("min", ctx.min)("max", ctx.max)("required", ctx.required === false ? void 0 : ctx.required);
      \u0275\u0275advance();
      \u0275\u0275property("control", ctx.control)("translationParams", \u0275\u0275pureFunction2(12, _c15, \u0275\u0275pipeBind1(2, 8, ctx.getDate(ctx.max)), \u0275\u0275pipeBind1(3, 10, ctx.getDate(ctx.min))));
    }
  },
  dependencies: [DefaultValueAccessor, NgControlStatus, PatternValidator, FormControlDirective, FormErrorsComponent, CxDatePipe],
  encapsulation: 2
});
var DatePickerComponent = _DatePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerComponent, [{
    type: Component,
    args: [{
      selector: "cx-date-picker",
      template: '<input\n  class="form-control"\n  type="date"\n  [formControl]="control"\n  [attr.min]="min"\n  [attr.max]="max"\n  [attr.required]="required === false ? undefined : required"\n  (change)="change()"\n  [placeholder]="placeholder"\n  [pattern]="pattern"\n/>\n<cx-form-errors\n  [control]="control"\n  prefix="formErrors.date"\n  [translationParams]="{\n    max: getDate(max) | cxDate,\n    min: getDate(min) | cxDate\n  }"\n></cx-form-errors>\n'
    }]
  }], () => [{
    type: DatePickerService
  }], {
    control: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    update: [{
      type: Output
    }]
  });
})();
var _FormErrorsModule = class _FormErrorsModule {
};
_FormErrorsModule.\u0275fac = function FormErrorsModule_Factory(t) {
  return new (t || _FormErrorsModule)();
};
_FormErrorsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FormErrorsModule
});
_FormErrorsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule]
});
var FormErrorsModule = _FormErrorsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormErrorsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule],
      declarations: [FormErrorsComponent],
      exports: [FormErrorsComponent]
    }]
  }], null, null);
})();
var _DatePickerModule = class _DatePickerModule {
};
_DatePickerModule.\u0275fac = function DatePickerModule_Factory(t) {
  return new (t || _DatePickerModule)();
};
_DatePickerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _DatePickerModule
});
_DatePickerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule]
});
var DatePickerModule = _DatePickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule],
      declarations: [DatePickerComponent],
      exports: [DatePickerComponent]
    }]
  }], null, null);
})();
var _FileUploadComponent = class _FileUploadComponent {
  constructor() {
    this.accept = "*";
    this.multiple = false;
    this.update = new EventEmitter();
    this.onChangeCallback = () => {
    };
    this.onTouchedCallback = () => {
    };
  }
  selectFile($event) {
    const files = $event.target?.files;
    this.onChangeCallback(files);
    this.update.emit(files);
  }
  removeFile() {
    this.fileInput.nativeElement.value = "";
  }
  get selectedFiles() {
    if (this.fileInput.nativeElement.files) {
      return Array.from(this.fileInput.nativeElement.files);
    }
    return void 0;
  }
  registerOnChange(callback) {
    this.onChangeCallback = callback;
  }
  registerOnTouched(callback) {
    this.onTouchedCallback = callback;
  }
  setDisabledState(disabled) {
    this.fileInput.nativeElement.disabled = disabled;
  }
  writeValue(value) {
    if (value instanceof FileList) {
      this.fileInput.nativeElement.files = value;
    }
  }
};
_FileUploadComponent.\u0275fac = function FileUploadComponent_Factory(t) {
  return new (t || _FileUploadComponent)();
};
_FileUploadComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FileUploadComponent,
  selectors: [["cx-file-upload"]],
  contentQueries: function FileUploadComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, TemplateRef, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.customButton = _t.first);
    }
  },
  viewQuery: function FileUploadComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c16, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.fileInput = _t.first);
    }
  },
  inputs: {
    accept: "accept",
    multiple: "multiple"
  },
  outputs: {
    update: "update"
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _FileUploadComponent),
    multi: true
  }])],
  ngContentSelectors: _c12,
  decls: 5,
  vars: 5,
  consts: [["fileInput", ""], ["type", "file", "aria-hidden", "true", 3, "change", "accept", "multiple"], ["class", "btn btn-secondary", "type", "button", 3, "click", 4, "ngIf"], ["class", "link cx-action-link", 3, "click", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["type", "button", 1, "btn", "btn-secondary", 3, "click"], [1, "link", "cx-action-link", 3, "click"], [4, "ngTemplateOutlet"]],
  template: function FileUploadComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "input", 1, 0);
      \u0275\u0275listener("change", function FileUploadComponent_Template_input_change_0_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.selectFile($event));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, FileUploadComponent_button_2_Template, 3, 3, "button", 2)(3, FileUploadComponent_button_3_Template, 2, 1, "button", 3)(4, FileUploadComponent_p_4_Template, 2, 1, "p", 4);
    }
    if (rf & 2) {
      \u0275\u0275property("accept", ctx.accept)("multiple", ctx.multiple);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", !ctx.customButton);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.customButton);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.selectedFiles);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, TranslatePipe],
  encapsulation: 2
});
var FileUploadComponent = _FileUploadComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileUploadComponent, [{
    type: Component,
    args: [{
      selector: "cx-file-upload",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => FileUploadComponent),
        multi: true
      }],
      template: `<input
  type="file"
  aria-hidden="true"
  [accept]="accept"
  [multiple]="multiple"
  (change)="selectFile($event)"
  #fileInput
/>
<button
  *ngIf="!customButton"
  [attr.aria-label]="'common.selectFile' | cxTranslate"
  class="btn btn-secondary"
  type="button"
  (click)="fileInput.click()"
>
  <ng-content></ng-content>
</button>
<!-- TODO(Brian-Parth): CXEC-17196 -->
<button
  class="link cx-action-link"
  *ngIf="customButton"
  (click)="fileInput.click()"
>
  <ng-container *ngTemplateOutlet="customButton"> </ng-container>
</button>
<p *ngFor="let file of selectedFiles">
  {{ file?.name }}
</p>
`
    }]
  }], null, {
    accept: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    customButton: [{
      type: ContentChild,
      args: [TemplateRef]
    }],
    update: [{
      type: Output
    }],
    fileInput: [{
      type: ViewChild,
      args: ["fileInput", {
        static: true
      }]
    }]
  });
})();
var _FileUploadModule = class _FileUploadModule {
};
_FileUploadModule.\u0275fac = function FileUploadModule_Factory(t) {
  return new (t || _FileUploadModule)();
};
_FileUploadModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FileUploadModule
});
_FileUploadModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule]
});
var FileUploadModule = _FileUploadModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileUploadModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule],
      declarations: [FileUploadComponent],
      exports: [FileUploadComponent]
    }]
  }], null, null);
})();
var _PasswordVisibilityToggleComponent = class _PasswordVisibilityToggleComponent {
  constructor() {
    this.showState = {
      icon: ICON_TYPE.EYE_SLASH,
      inputType: "text",
      ariaLabel: "passwordVisibility.hidePassword"
    };
    this.hideState = {
      icon: ICON_TYPE.EYE,
      inputType: "password",
      ariaLabel: "passwordVisibility.showPassword"
    };
    this.state = this.hideState;
  }
  /**
   * Toggle the visibility of the text of the input field.
   */
  toggle() {
    this.state = this.state === this.hideState ? this.showState : this.hideState;
    this.inputElement.setAttribute("type", this.state.inputType);
  }
};
_PasswordVisibilityToggleComponent.\u0275fac = function PasswordVisibilityToggleComponent_Factory(t) {
  return new (t || _PasswordVisibilityToggleComponent)();
};
_PasswordVisibilityToggleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PasswordVisibilityToggleComponent,
  selectors: [["cx-password-visibility-toggle"]],
  inputs: {
    inputElement: "inputElement"
  },
  decls: 4,
  vars: 4,
  consts: [["type", "button", 3, "click"], ["aria-hidden", "true"], [3, "type"]],
  template: function PasswordVisibilityToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275pipe(1, "cxTranslate");
      \u0275\u0275listener("click", function PasswordVisibilityToggleComponent_Template_button_click_0_listener() {
        return ctx.toggle();
      });
      \u0275\u0275elementStart(2, "span", 1);
      \u0275\u0275element(3, "cx-icon", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 2, ctx.state.ariaLabel));
      \u0275\u0275advance(3);
      \u0275\u0275property("type", ctx.state.icon);
    }
  },
  dependencies: [IconComponent, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var PasswordVisibilityToggleComponent = _PasswordVisibilityToggleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordVisibilityToggleComponent, [{
    type: Component,
    args: [{
      selector: "cx-password-visibility-toggle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<button\n  type="button"\n  (click)="toggle()"\n  [attr.aria-label]="state.ariaLabel | cxTranslate"\n>\n  <span aria-hidden="true">\n    <cx-icon [type]="state.icon"></cx-icon>\n  </span>\n</button>\n'
    }]
  }], null, {
    inputElement: [{
      type: Input
    }]
  });
})();
var _FormConfig = class _FormConfig {
};
_FormConfig.\u0275fac = function FormConfig_Factory(t) {
  return new (t || _FormConfig)();
};
_FormConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FormConfig,
  factory: function FormConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _FormConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var FormConfig = _FormConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var _PasswordVisibilityToggleDirective = class _PasswordVisibilityToggleDirective {
  constructor(winRef, config, elementRef, viewContainerRef, changeDetectorRef) {
    this.winRef = winRef;
    this.config = config;
    this.elementRef = elementRef;
    this.viewContainerRef = viewContainerRef;
    this.changeDetectorRef = changeDetectorRef;
  }
  ngAfterViewInit() {
    if (this.config.form?.passwordVisibilityToggle) {
      this.wrapInput();
      this.insertComponent();
      this.changeDetectorRef.detectChanges();
    }
  }
  insertComponent() {
    const component = this.viewContainerRef.createComponent(PasswordVisibilityToggleComponent);
    component.instance.inputElement = this.elementRef.nativeElement;
    this.inputWrapper?.appendChild(component.location.nativeElement);
  }
  /**
   * We need to wrap the input element in a div to be able to position the toggle button in the right place.
   */
  wrapInput() {
    const input = this.elementRef.nativeElement;
    const parent = input.parentNode;
    this.inputWrapper = this.winRef.document.createElement("div");
    this.inputWrapper.setAttribute("class", "cx-password-input-wrapper");
    parent.replaceChild(this.inputWrapper, input);
    this.inputWrapper.appendChild(input);
  }
};
_PasswordVisibilityToggleDirective.\u0275fac = function PasswordVisibilityToggleDirective_Factory(t) {
  return new (t || _PasswordVisibilityToggleDirective)(\u0275\u0275directiveInject(WindowRef), \u0275\u0275directiveInject(FormConfig), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_PasswordVisibilityToggleDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PasswordVisibilityToggleDirective,
  selectors: [["", "cxPasswordVisibilitySwitch", "", "type", "password"]]
});
var PasswordVisibilityToggleDirective = _PasswordVisibilityToggleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordVisibilityToggleDirective, [{
    type: Directive,
    args: [{
      selector: '[cxPasswordVisibilitySwitch][type="password"]'
    }]
  }], () => [{
    type: WindowRef
  }, {
    type: FormConfig
  }, {
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var defaultFormConfig = {
  form: {
    passwordVisibilityToggle: true
  }
};
var _PasswordVisibilityToggleModule = class _PasswordVisibilityToggleModule {
};
_PasswordVisibilityToggleModule.\u0275fac = function PasswordVisibilityToggleModule_Factory(t) {
  return new (t || _PasswordVisibilityToggleModule)();
};
_PasswordVisibilityToggleModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PasswordVisibilityToggleModule
});
_PasswordVisibilityToggleModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultFormConfig)],
  imports: [CommonModule, IconModule, I18nModule]
});
var PasswordVisibilityToggleModule = _PasswordVisibilityToggleModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordVisibilityToggleModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, IconModule, I18nModule],
      providers: [provideDefaultConfig(defaultFormConfig)],
      declarations: [PasswordVisibilityToggleDirective, PasswordVisibilityToggleComponent],
      exports: [PasswordVisibilityToggleDirective, PasswordVisibilityToggleComponent]
    }]
  }], null, null);
})();
var _GenericLinkComponentService = class _GenericLinkComponentService {
  constructor() {
    this.HTTP_PROTOCOL_REGEX = /^https?:\/\//i;
    this.MAILTO_PROTOCOL_REGEX = /^mailto:/i;
    this.TEL_PROTOCOL_REGEX = /^tel:/i;
  }
  /**
   * Returns true when the @Input `url` is a string starting with `http://`, `https://`, `mailto:`, `tel:`.
   */
  isExternalUrl(url) {
    return typeof url === "string" && (this.HTTP_PROTOCOL_REGEX.test(url) || this.MAILTO_PROTOCOL_REGEX.test(url) || this.TEL_PROTOCOL_REGEX.test(url));
  }
};
_GenericLinkComponentService.\u0275fac = function GenericLinkComponentService_Factory(t) {
  return new (t || _GenericLinkComponentService)();
};
_GenericLinkComponentService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _GenericLinkComponentService,
  factory: _GenericLinkComponentService.\u0275fac,
  providedIn: "root"
});
var GenericLinkComponentService = _GenericLinkComponentService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GenericLinkComponentService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _GenericLinkComponent = class _GenericLinkComponent {
  constructor(router, service) {
    this.router = router;
    this.service = service;
    this.URL_SPLIT = /(^[^#?]*)(.*)/;
    this.routeParts = {};
  }
  isExternalUrl() {
    return this.service.isExternalUrl(this.url);
  }
  get rel() {
    return this.target === "_blank" ? "noopener" : null;
  }
  ngOnChanges(changes) {
    if (changes["url"]) {
      this.setUrlParts(changes["url"].currentValue);
    }
  }
  /**
   * The part with the path of the local url.
   */
  get routerUrl() {
    return this.routeParts.path;
  }
  /**
   * The part with the query params of the local url.
   */
  get queryParams() {
    return this.routeParts.queryParams;
  }
  /**
   * The part with the hash fragment of the local url.
   */
  get fragment() {
    return this.routeParts.fragment ?? void 0;
  }
  /**
   * Parses the given url and sets the property `urlParts` accordingly.
   */
  setUrlParts(url) {
    if (typeof url === "string") {
      url = this.getAbsoluteUrl(url);
      this.routeParts = this.splitUrl(url);
    } else {
      this.routeParts = {
        path: url
      };
    }
  }
  /**
   * Parses the given string into 3 parts:
   * - string path (wrapped in an array to be compatible with Angular syntax for the `routerLink`)
   * - query params (as an object)
   * - hash fragment (string)
   */
  splitUrl(url = "") {
    const {
      queryParams,
      fragment
    } = this.router.parseUrl(url);
    const [, path] = url.match(this.URL_SPLIT) ?? [, ""];
    return {
      path: [path ?? ""],
      queryParams,
      fragment
    };
  }
  /**
   * Prepends a leading slash to the given URL string, in case it doesn't have it.
   */
  getAbsoluteUrl(url) {
    return url.startsWith("/") ? url : "/" + url;
  }
};
_GenericLinkComponent.\u0275fac = function GenericLinkComponent_Factory(t) {
  return new (t || _GenericLinkComponent)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(GenericLinkComponentService));
};
_GenericLinkComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GenericLinkComponent,
  selectors: [["cx-generic-link"]],
  inputs: {
    url: "url",
    target: "target",
    id: "id",
    class: "class",
    style: "style",
    title: "title"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c12,
  decls: 5,
  vars: 2,
  consts: [["isLocalUrl", ""], ["content", ""], [4, "ngIf", "ngIfElse"], [3, "href"], [4, "ngTemplateOutlet"], [3, "routerLink", "queryParams", "fragment", "target"]],
  template: function GenericLinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, GenericLinkComponent_ng_container_0_Template, 3, 8, "ng-container", 2)(1, GenericLinkComponent_ng_template_1_Template, 2, 9, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(3, GenericLinkComponent_ng_template_3_Template, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const isLocalUrl_r3 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.isExternalUrl())("ngIfElse", isLocalUrl_r3);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, RouterLink],
  encapsulation: 2
});
var GenericLinkComponent = _GenericLinkComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GenericLinkComponent, [{
    type: Component,
    args: [{
      selector: "cx-generic-link",
      template: '<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf="isExternalUrl(); else isLocalUrl">\n  <a\n    [href]="url"\n    [attr.target]="target"\n    [attr.rel]="rel"\n    [attr.id]="id"\n    [attr.class]="class"\n    [attr.style]="style"\n    [attr.title]="title"\n  >\n    <ng-container *ngTemplateOutlet="content"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    [routerLink]="routerUrl"\n    [queryParams]="queryParams"\n    [fragment]="fragment"\n    [target]="target || undefined"\n    [attr.id]="id"\n    [attr.class]="class"\n    [attr.style]="style"\n    [attr.title]="title"\n  >\n    <ng-container *ngTemplateOutlet="content"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n'
    }]
  }], () => [{
    type: Router
  }, {
    type: GenericLinkComponentService
  }], {
    url: [{
      type: Input
    }],
    target: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var _GenericLinkModule = class _GenericLinkModule {
};
_GenericLinkModule.\u0275fac = function GenericLinkModule_Factory(t) {
  return new (t || _GenericLinkModule)();
};
_GenericLinkModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _GenericLinkModule
});
_GenericLinkModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule]
});
var GenericLinkModule = _GenericLinkModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GenericLinkModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      declarations: [GenericLinkComponent],
      exports: [GenericLinkComponent]
    }]
  }], null, null);
})();
var _ItemCounterComponent = class _ItemCounterComponent {
  constructor() {
    this.min = 1;
    this.step = 1;
    this.allowZero = false;
    this.readonly = false;
  }
  handleClick() {
    this.input.nativeElement.focus();
  }
  ngOnInit() {
    this.sub = this.control.valueChanges.pipe(startWith(this.control.value)).subscribe((value) => this.control.setValue(this.getValidCount(value), {
      emitEvent: false
    }));
  }
  ngOnDestroy() {
    if (this.sub) {
      this.sub.unsubscribe();
    }
  }
  increment() {
    this.control.setValue(this.control.value + this.step);
    this.control.markAsDirty();
  }
  decrement() {
    this.control.setValue(this.control.value - this.step);
    this.control.markAsDirty();
  }
  /**
   * Validate that the given value is in between
   * the `min` and `max` value. If the value is out
   * of  the min/max range, it will be altered.
   * If `allowZero` is set to true, the 0 value is ignored.
   *
   */
  getValidCount(value) {
    if (value < this.min && !(value === 0 && this.allowZero)) {
      value = this.min;
    }
    if (this.max && value > this.max) {
      value = this.max;
    }
    return value;
  }
};
_ItemCounterComponent.\u0275fac = function ItemCounterComponent_Factory(t) {
  return new (t || _ItemCounterComponent)();
};
_ItemCounterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ItemCounterComponent,
  selectors: [["cx-item-counter"]],
  viewQuery: function ItemCounterComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c17, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.input = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ItemCounterComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function ItemCounterComponent_click_HostBindingHandler() {
        return ctx.handleClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("readonly", ctx.readonly);
    }
  },
  inputs: {
    control: "control",
    min: "min",
    max: "max",
    step: "step",
    allowZero: "allowZero",
    readonly: "readonly"
  },
  decls: 9,
  vars: 18,
  consts: [["qty", ""], ["type", "button", 3, "click", "disabled", "tabindex"], ["type", "number", 3, "min", "max", "step", "readonly", "tabindex", "formControl"], ["type", "button", "tabindex", "0", 3, "click", "disabled"]],
  template: function ItemCounterComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "button", 1);
      \u0275\u0275pipe(1, "cxTranslate");
      \u0275\u0275listener("click", function ItemCounterComponent_Template_button_click_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.decrement());
      });
      \u0275\u0275text(2, " -\n");
      \u0275\u0275elementEnd();
      \u0275\u0275element(3, "input", 2, 0);
      \u0275\u0275pipe(5, "cxTranslate");
      \u0275\u0275elementStart(6, "button", 3);
      \u0275\u0275pipe(7, "cxTranslate");
      \u0275\u0275listener("click", function ItemCounterComponent_Template_button_click_6_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.increment());
      });
      \u0275\u0275text(8, " +\n");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("disabled", ctx.control.disabled || ctx.control.value <= ctx.min)("tabindex", ctx.control.disabled || ctx.control.value <= ctx.min ? -1 : 0);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 12, "itemCounter.removeOne"));
      \u0275\u0275advance(3);
      \u0275\u0275property("min", ctx.min)("max", ctx.max)("step", ctx.step)("readonly", ctx.readonly)("tabindex", ctx.readonly ? -1 : 0)("formControl", ctx.control);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(5, 14, "itemCounter.quantity"));
      \u0275\u0275advance(3);
      \u0275\u0275property("disabled", ctx.control.disabled || ctx.control.value >= ctx.max);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(7, 16, "itemCounter.addOneMore"));
    }
  },
  dependencies: [DefaultValueAccessor, NumberValueAccessor, NgControlStatus, MinValidator, MaxValidator, FormControlDirective, TranslatePipe],
  encapsulation: 2
});
var ItemCounterComponent = _ItemCounterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemCounterComponent, [{
    type: Component,
    args: [{
      selector: "cx-item-counter",
      template: `<button
  type="button"
  (click)="decrement()"
  [disabled]="control.disabled || control.value <= min"
  [tabindex]="control.disabled || control.value <= min ? -1 : 0"
  attr.aria-label="{{ 'itemCounter.removeOne' | cxTranslate }}"
>
  -
</button>
<input
  #qty
  type="number"
  [min]="min"
  [max]="max"
  [step]="step"
  [readonly]="readonly"
  [tabindex]="readonly ? -1 : 0"
  [formControl]="control"
  attr.aria-label="{{ 'itemCounter.quantity' | cxTranslate }}"
/>
<button
  type="button"
  (click)="increment()"
  [disabled]="control.disabled || control.value >= max"
  tabindex="0"
  attr.aria-label="{{ 'itemCounter.addOneMore' | cxTranslate }}"
>
  +
</button>
`
    }]
  }], null, {
    control: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    allowZero: [{
      type: Input
    }],
    readonly: [{
      type: HostBinding,
      args: ["class.readonly"]
    }, {
      type: Input
    }],
    input: [{
      type: ViewChild,
      args: ["qty"]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _ItemCounterModule = class _ItemCounterModule {
};
_ItemCounterModule.\u0275fac = function ItemCounterModule_Factory(t) {
  return new (t || _ItemCounterModule)();
};
_ItemCounterModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ItemCounterModule
});
_ItemCounterModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, ReactiveFormsModule, I18nModule]
});
var ItemCounterModule = _ItemCounterModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemCounterModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ReactiveFormsModule, I18nModule],
      declarations: [ItemCounterComponent],
      exports: [ItemCounterComponent]
    }]
  }], null, null);
})();
var _NgSelectA11yDirective = class _NgSelectA11yDirective {
  constructor(renderer, elementRef) {
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  ngAfterViewInit() {
    const divCombobox = this.elementRef.nativeElement.querySelector('[role="combobox"]');
    const ariaLabel = this.cxNgSelectA11y.ariaLabel;
    const elementId = this.elementRef.nativeElement.id;
    const ariaControls = this.cxNgSelectA11y.ariaControls ?? elementId;
    if (ariaLabel) {
      this.renderer.setAttribute(divCombobox, "aria-label", ariaLabel);
    }
    if (ariaControls) {
      this.renderer.setAttribute(divCombobox, "aria-controls", ariaControls);
    }
  }
};
_NgSelectA11yDirective.\u0275fac = function NgSelectA11yDirective_Factory(t) {
  return new (t || _NgSelectA11yDirective)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_NgSelectA11yDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgSelectA11yDirective,
  selectors: [["", "cxNgSelectA11y", ""]],
  inputs: {
    cxNgSelectA11y: "cxNgSelectA11y"
  }
});
var NgSelectA11yDirective = _NgSelectA11yDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectA11yDirective, [{
    type: Directive,
    args: [{
      selector: "[cxNgSelectA11y]"
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    cxNgSelectA11y: [{
      type: Input
    }]
  });
})();
var _SortingComponent = class _SortingComponent {
  constructor() {
    this.sortListEvent = new EventEmitter();
  }
  sortList(sortCode) {
    this.sortListEvent.emit(sortCode);
  }
  get selectedLabel() {
    if (this.selectedOption) {
      return this.sortOptions?.find((sort) => sort.code === this.selectedOption)?.name ?? this.sortLabels?.[this.selectedOption];
    }
  }
};
_SortingComponent.\u0275fac = function SortingComponent_Factory(t) {
  return new (t || _SortingComponent)();
};
_SortingComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SortingComponent,
  selectors: [["cx-sorting"]],
  inputs: {
    sortOptions: "sortOptions",
    ariaControls: "ariaControls",
    ariaLabel: "ariaLabel",
    selectedOption: "selectedOption",
    placeholder: "placeholder",
    sortLabels: "sortLabels"
  },
  outputs: {
    sortListEvent: "sortListEvent"
  },
  decls: 3,
  vars: 11,
  consts: [[3, "change", "searchable", "clearable", "placeholder", "ngModel", "cxNgSelectA11y"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]],
  template: function SortingComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ng-select", 0);
      \u0275\u0275pipe(1, "cxTranslate");
      \u0275\u0275listener("change", function SortingComponent_Template_ng_select_change_0_listener($event) {
        return ctx.sortList($event);
      });
      \u0275\u0275template(2, SortingComponent_ng_option_2_Template, 2, 2, "ng-option", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275propertyInterpolate("placeholder", ctx.placeholder);
      \u0275\u0275property("searchable", false)("clearable", false)("ngModel", ctx.selectedOption)("cxNgSelectA11y", \u0275\u0275pureFunction2(8, _c18, ctx.ariaLabel || \u0275\u0275pipeBind1(1, 6, "productList.sortResults"), ctx.ariaControls));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.sortOptions);
    }
  },
  dependencies: [NgForOf, NgSelectComponent, NgOptionComponent, NgControlStatus, NgModel, NgSelectA11yDirective, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var SortingComponent = _SortingComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SortingComponent, [{
    type: Component,
    args: [{
      selector: "cx-sorting",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-select
  [searchable]="false"
  [clearable]="false"
  placeholder="{{ placeholder }}"
  (change)="sortList($event)"
  [ngModel]="selectedOption"
  [cxNgSelectA11y]="{
    ariaLabel: ariaLabel || ('productList.sortResults' | cxTranslate),
    ariaControls: ariaControls
  }"
>
  <ng-option *ngFor="let sort of sortOptions" [value]="sort.code">{{
    sort.name ? sort.name : sortLabels && sort.code ? sortLabels[sort.code] : ''
  }}</ng-option>
</ng-select>
`
    }]
  }], () => [], {
    sortOptions: [{
      type: Input
    }],
    ariaControls: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    selectedOption: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    sortLabels: [{
      type: Input
    }],
    sortListEvent: [{
      type: Output
    }]
  });
})();
var _NgSelectA11yModule = class _NgSelectA11yModule {
};
_NgSelectA11yModule.\u0275fac = function NgSelectA11yModule_Factory(t) {
  return new (t || _NgSelectA11yModule)();
};
_NgSelectA11yModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NgSelectA11yModule
});
_NgSelectA11yModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NgSelectA11yModule = _NgSelectA11yModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectA11yModule, [{
    type: NgModule,
    args: [{
      declarations: [NgSelectA11yDirective],
      exports: [NgSelectA11yDirective]
    }]
  }], null, null);
})();
var _SortingModule = class _SortingModule {
};
_SortingModule.\u0275fac = function SortingModule_Factory(t) {
  return new (t || _SortingModule)();
};
_SortingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SortingModule
});
_SortingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NgSelectModule, FormsModule, NgSelectA11yModule, I18nModule]
});
var SortingModule = _SortingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SortingModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NgSelectModule, FormsModule, NgSelectA11yModule, I18nModule],
      declarations: [SortingComponent],
      exports: [SortingComponent]
    }]
  }], null, null);
})();
var defaultPaginationConfig = {
  pagination: {
    addStart: true,
    addEnd: true
  }
};
var _PaginationConfig = class _PaginationConfig {
};
_PaginationConfig.\u0275fac = function PaginationConfig_Factory(t) {
  return new (t || _PaginationConfig)();
};
_PaginationConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PaginationConfig,
  factory: function PaginationConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _PaginationConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var PaginationConfig = _PaginationConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var PaginationItemType;
(function(PaginationItemType2) {
  PaginationItemType2["GAP"] = "gap";
  PaginationItemType2["FIRST"] = "first";
  PaginationItemType2["LAST"] = "last";
  PaginationItemType2["PREVIOUS"] = "previous";
  PaginationItemType2["NEXT"] = "next";
  PaginationItemType2["START"] = "start";
  PaginationItemType2["END"] = "end";
  PaginationItemType2["PAGE"] = "page";
})(PaginationItemType || (PaginationItemType = {}));
var PaginationNavigationPosition;
(function(PaginationNavigationPosition2) {
  PaginationNavigationPosition2["ASIDE"] = "aside";
  PaginationNavigationPosition2["BEFORE"] = "before";
  PaginationNavigationPosition2["AFTER"] = "after";
})(PaginationNavigationPosition || (PaginationNavigationPosition = {}));
var FALLBACK_PAGINATION_OPTIONS = {
  rangeCount: 3,
  dotsLabel: "...",
  startLabel: "\xAB",
  previousLabel: "\u2039",
  nextLabel: "\u203A",
  endLabel: "\xBB"
};
var _PaginationBuilder = class _PaginationBuilder {
  constructor(paginationConfig) {
    this.paginationConfig = paginationConfig;
  }
  /**
   * Builds a list of `PaginationItem`. The give pageCount and current are used
   * to build out the full pagination. There are various {@link PaginationConfig} options
   * which can be used to configure the behavior of the build. Alternatively, CSS
   * can be used to further specialize visibility of the pagination.
   *
   * @param pageCount The total number of pages
   * @param current The current page number, 0-index based
   * @returns An array of `PaginationItem`
   */
  paginate(pageCount, current) {
    const pages = [];
    if (!pageCount || pageCount < 2) {
      return pages;
    }
    this.addPages(pages, pageCount, current);
    this.addDots(pages, pageCount);
    this.addFirstLast(pages, pageCount);
    this.addNavigation(pages, pageCount, current);
    return pages;
  }
  /**
   * Returns the current page with surrounding pages (based on the `config.rangeCount`).
   * The current page is always centered to provide direct access to the previous and next page.
   *
   * @param pages The list of page items that is used to amend
   * @param pageCount The total number of pages
   * @param current The current page number, 0-index based
   */
  addPages(pages, pageCount, current) {
    const start = this.getStartOfRange(pageCount, current);
    if (this.config.rangeCount !== void 0 && start !== null) {
      const max = Math.min(this.config.rangeCount, pageCount);
      Array.from(Array(max)).forEach((_, i) => {
        pages.push({
          number: i + start,
          label: String(i + start + 1),
          type: PaginationItemType.PAGE
        });
      });
    }
  }
  /**
   * Adds dots before and after the given pages, if configured (defaults to true).
   * If the dots only represent a single page, the page number is added instead of
   * the dots, unless the configuration requires dots always.
   *
   * @param pages The list of page items that is used to amend
   * @param pageCount The total number of pages
   */
  addDots(pages, pageCount) {
    if (!this.config.addDots) {
      return;
    }
    pages.unshift(...this.addFirstGapToDots(pages));
    pages.push(...this.addLastGapToDots(pages, pageCount));
  }
  /**
   * Helper method for addDots() whether to add the first gap.
   */
  addFirstGapToDots(pages) {
    const firstItemNumber = pages[0].number;
    const gapNumber = Number(this.config.addFirst);
    if (firstItemNumber !== void 0 && firstItemNumber > gapNumber) {
      const isGap = !this.config.substituteDotsForSingularPage || firstItemNumber !== gapNumber + 1;
      const isSubstituted = this.config.addFirst && this.config.substituteDotsForSingularPage && gapNumber === 0;
      const type = isGap ? PaginationItemType.GAP : isSubstituted ? PaginationItemType.FIRST : PaginationItemType.PAGE;
      return [Object.assign({
        label: isGap ? this.config.dotsLabel : String(gapNumber + 1),
        type
      }, isGap ? null : {
        number: gapNumber
      })];
    } else {
      return [];
    }
  }
  /**
   * Helper method for addDots() whether to add the last gap.
   */
  addLastGapToDots(pages, pageCount) {
    const pageNumber = pages[pages.length - 1].number;
    const nextPageNumber = pageNumber ? pageNumber + 1 : void 0;
    const last = pageCount - (Number(this.config.addLast) + 1);
    if (nextPageNumber && nextPageNumber <= last) {
      const isSubstituted = this.config.addLast && this.config.substituteDotsForSingularPage && nextPageNumber === last;
      const isGap = nextPageNumber < pageCount - Number(this.config.substituteDotsForSingularPage) - Number(this.config.addLast);
      const type = isGap ? PaginationItemType.GAP : isSubstituted ? PaginationItemType.LAST : PaginationItemType.PAGE;
      return [Object.assign({
        label: isGap ? this.config.dotsLabel : String(nextPageNumber + 1),
        type
      }, isGap ? null : {
        number: nextPageNumber
      })];
    } else {
      return [];
    }
  }
  /**
   * Add links to the first and last page, if configured to do so.
   *
   * @param pages The list of page items that is used to amend
   * @param pageCount The total number of pages
   *
   */
  addFirstLast(pages, pageCount) {
    if (this.config.addFirst && pages[0].number !== 0) {
      pages.unshift({
        number: 0,
        label: "1",
        type: PaginationItemType.FIRST
      });
    }
    if (this.config.addLast && pages[pages.length - 1].number !== pageCount - 1) {
      pages.push({
        number: pageCount - 1,
        label: String(pageCount),
        type: PaginationItemType.LAST
      });
    }
  }
  /**
   * Add links to the start, previous, next and last page, if configured to do so.
   * The order of the links can be configured by using the {@link PaginationConfig},
   * using the `PaginationNavigationPosition` (`BEFORE` or `AFTER`).
   * The `PaginationNavigationPosition` allows for 3 flavours:
   *
   * - by default the pagination starts with start and previous and ends with the next and end links
   * - BEFORE – all navigation links are added in the front of the pagination list
   * - AFTER – all navigation links are pushed to the end of the pagination list
   *
   * @param pages The list of page items that is used to amend
   * @param pageCount The total number of pages
   * @param current The current page number, 0-index based
   *
   */
  addNavigation(pages, pageCount, current) {
    const before = this.getBeforeLinks(current);
    const after = this.getAfterLinks(pageCount, current);
    const pos = this.config.navigationPosition;
    if (!pos || pos === PaginationNavigationPosition.ASIDE) {
      pages.unshift(...before);
      pages.push(...after);
    } else {
      if (pos === PaginationNavigationPosition.BEFORE) {
        pages.unshift(...before, ...after);
      }
      if (pos === PaginationNavigationPosition.AFTER) {
        pages.push(...before, ...after);
      }
    }
  }
  /**
   * Returns the start and previous links, if applicable.
   */
  getBeforeLinks(current) {
    const list = [];
    if (this.config.addStart) {
      const start = () => {
        return Object.assign({
          label: this.config.startLabel,
          type: PaginationItemType.START
        }, current > 0 ? {
          number: 0
        } : null);
      };
      list.push(start());
    }
    if (this.config.addPrevious) {
      const previous = () => {
        return Object.assign({
          label: this.config.previousLabel,
          type: PaginationItemType.PREVIOUS
        }, current > 0 ? {
          number: current - 1
        } : null);
      };
      list.push(previous());
    }
    return list;
  }
  /**
   * Returns the next and end links, if applicable.
   */
  getAfterLinks(pageCount, current) {
    const list = [];
    if (this.config.addNext) {
      const next = () => {
        return Object.assign({
          label: this.config.nextLabel,
          type: PaginationItemType.NEXT
        }, current < pageCount - 1 ? {
          number: current + 1
        } : null);
      };
      list.push(next());
    }
    if (this.config.addEnd) {
      const end = () => {
        return Object.assign({
          label: this.config.endLabel,
          type: PaginationItemType.END
        }, current < pageCount - 1 ? {
          number: pageCount - 1
        } : null);
      };
      list.push(end());
    }
    return list;
  }
  /**
   * Resolves the first page of the range we need to build.
   * This is the page that is leading up to the range of the
   * current page.
   *
   * @param pageCount The total number of pages.
   * @param current The current page number, 0-index based.
   */
  getStartOfRange(pageCount, current) {
    if (this.config.rangeCount !== void 0) {
      const count = this.config.rangeCount - 1;
      const delta = Math.round(count / 2);
      const minStart = Math.max(0, current - delta);
      const maxStart = Math.max(0, pageCount - count - 1);
      return Math.min(maxStart, minStart);
    }
    return null;
  }
  /**
   * Returns the pagination configuration. The configuration is driven by the
   * (default) application configuration.
   *
   * The default application is limited to adding the start and end link:
   * ```ts
   *   addStart: true,
   *   addEnd: true
   * ```
   *
   * The application configuration is however merged into the following static configuration:
   * ```ts
   * {
   *   rangeCount: 3,
   *   dotsLabel: '...',
   *   startLabel: '«',
   *   previousLabel: '‹',
   *   nextLabel: '›',
   *   endLabel: '»'
   * }
   * ```
   */
  get config() {
    return Object.assign(FALLBACK_PAGINATION_OPTIONS, this.paginationConfig.pagination);
  }
};
_PaginationBuilder.\u0275fac = function PaginationBuilder_Factory(t) {
  return new (t || _PaginationBuilder)(\u0275\u0275inject(PaginationConfig));
};
_PaginationBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PaginationBuilder,
  factory: _PaginationBuilder.\u0275fac,
  providedIn: "root"
});
var PaginationBuilder = _PaginationBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PaginationConfig
  }], null);
})();
var _PaginationComponent = class _PaginationComponent {
  get pagination() {
    return this._pagination;
  }
  set pagination(value) {
    if (value) {
      this._pagination = value;
      this.render(value);
    }
  }
  constructor(paginationBuilder, activatedRoute) {
    this.paginationBuilder = paginationBuilder;
    this.activatedRoute = activatedRoute;
    this.pageRoute = ".";
    this.viewPageEvent = new EventEmitter();
    this.pages = [];
  }
  render(pagination) {
    if (!pagination) {
      return;
    }
    this.pages = this.paginationBuilder.paginate(pagination.totalPages ?? 0, pagination.currentPage ?? 0);
  }
  /**
   * Format aria-label based on pagination item type.
   *
   * @param label string
   * @param type PaginationItemType
   * @returns string
   */
  getAriaLabel(label, type) {
    type = type === PaginationItemType.START ? PaginationItemType.FIRST : type;
    type = type === PaginationItemType.END ? PaginationItemType.LAST : type;
    return type === PaginationItemType.PAGE ? `${type} ${label}` : `${type} ${PaginationItemType.PAGE}`;
  }
  /**
   * Indicates whether the given item is the current item.
   *
   * @param item PaginationItem
   * @returns boolean
   */
  isCurrent(item) {
    return item.type === PaginationItemType.PAGE && item.number === this.pagination.currentPage;
  }
  /**
   * Indicates whether the pagination item is inactive. This is used
   * to disabled a link or set the tabindex to `-1`.
   *
   * Defaults to true
   *
   * @param item PaginationItem
   * @returns returns -1 in case of a disabled
   */
  isInactive(item) {
    return !item.hasOwnProperty("number") || item.number === this.pagination.currentPage;
  }
  getQueryParams(item) {
    const queryParams = Object.assign({}, this.activatedRoute.snapshot.queryParams);
    if (this.queryParam && item.number !== void 0 && this.pagination.totalPages !== void 0 && item.number < this.pagination.totalPages && !this.isCurrent(item)) {
      queryParams[this.queryParam] = item.number;
    }
    if (queryParams[this.queryParam] === this.defaultPage) {
      delete queryParams[this.queryParam];
    }
    return queryParams;
  }
  pageChange(page) {
    this.viewPageEvent.emit(page.number);
  }
};
_PaginationComponent.\u0275fac = function PaginationComponent_Factory(t) {
  return new (t || _PaginationComponent)(\u0275\u0275directiveInject(PaginationBuilder), \u0275\u0275directiveInject(ActivatedRoute));
};
_PaginationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PaginationComponent,
  selectors: [["cx-pagination"]],
  inputs: {
    pageRoute: "pageRoute",
    queryParam: "queryParam",
    defaultPage: "defaultPage",
    pagination: "pagination"
  },
  outputs: {
    viewPageEvent: "viewPageEvent"
  },
  decls: 1,
  vars: 1,
  consts: [[3, "class", "disabled", "current", "routerLink", "queryParams", "tabIndex", "click", 4, "ngFor", "ngForOf"], [3, "click", "routerLink", "queryParams", "tabIndex"]],
  template: function PaginationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, PaginationComponent_a_0_Template, 2, 11, "a", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.pages);
    }
  },
  dependencies: [NgForOf, RouterLink],
  encapsulation: 2,
  changeDetection: 0
});
var PaginationComponent = _PaginationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationComponent, [{
    type: Component,
    args: [{
      selector: "cx-pagination",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<a\n  *ngFor="let item of pages"\n  [class]="item.type"\n  [class.disabled]="isInactive(item)"\n  [class.current]="isCurrent(item)"\n  [routerLink]="pageRoute"\n  [queryParams]="getQueryParams(item)"\n  [tabIndex]="isInactive(item) ? -1 : 0"\n  (click)="pageChange(item)"\n  [attr.aria-label]="getAriaLabel(item.label, item.type)"\n>\n  {{ item.label }}\n</a>\n'
    }]
  }], () => [{
    type: PaginationBuilder
  }, {
    type: ActivatedRoute
  }], {
    pageRoute: [{
      type: Input
    }],
    queryParam: [{
      type: Input
    }],
    defaultPage: [{
      type: Input
    }],
    pagination: [{
      type: Input
    }],
    viewPageEvent: [{
      type: Output
    }]
  });
})();
var _PaginationModule = class _PaginationModule {
};
_PaginationModule.\u0275fac = function PaginationModule_Factory(t) {
  return new (t || _PaginationModule)();
};
_PaginationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PaginationModule
});
_PaginationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultPaginationConfig)],
  imports: [CommonModule, RouterModule]
});
var PaginationModule = _PaginationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      providers: [provideDefaultConfig(defaultPaginationConfig)],
      declarations: [PaginationComponent],
      exports: [PaginationComponent]
    }]
  }], null, null);
})();
var _TotalComponent = class _TotalComponent {
  get pagination() {
    return this._pagination;
  }
  set pagination(paginationModel) {
    this._pagination = paginationModel ?? {
      totalResults: 0
    };
  }
  /**
   * Current page, starting form page 0
   * */
  get currentPage() {
    return this.pagination?.currentPage ?? 0;
  }
  get pageSize() {
    return this.pagination?.pageSize ?? 0;
  }
  get totalResults() {
    return this.pagination?.totalResults ?? 0;
  }
  get fromItem() {
    return this.currentPage * this.pageSize + 1;
  }
  get toItem() {
    const lastItem = (this.currentPage + 1) * this.pageSize;
    return lastItem > this.totalResults ? this.totalResults : lastItem;
  }
};
_TotalComponent.\u0275fac = function TotalComponent_Factory(t) {
  return new (t || _TotalComponent)();
};
_TotalComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TotalComponent,
  selectors: [["cx-total"]],
  inputs: {
    pagination: "pagination"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [1, "cx-vertical-line-separator"]],
  template: function TotalComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, TotalComponent_ng_container_0_Template, 8, 10, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.totalResults > 0);
    }
  },
  dependencies: [NgIf, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var TotalComponent = _TotalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TotalComponent, [{
    type: Component,
    args: [{
      selector: "cx-total",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="totalResults > 0">
  <div>{{ totalResults }} {{ 'common.results' | cxTranslate }}</div>
  <div class="cx-vertical-line-separator"></div>
  <div>
    {{ fromItem }}-{{ toItem }} {{ 'common.of' | cxTranslate }}
    {{ totalResults }}
  </div>
</ng-container>
`
    }]
  }], null, {
    pagination: [{
      type: Input
    }]
  });
})();
var _TotalModule = class _TotalModule {
};
_TotalModule.\u0275fac = function TotalModule_Factory(t) {
  return new (t || _TotalModule)();
};
_TotalModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TotalModule
});
_TotalModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FormsModule, I18nModule]
});
var TotalModule = _TotalModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TotalModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, I18nModule],
      declarations: [TotalComponent],
      exports: [TotalComponent]
    }]
  }], null, null);
})();
var _ListNavigationModule = class _ListNavigationModule {
};
_ListNavigationModule.\u0275fac = function ListNavigationModule_Factory(t) {
  return new (t || _ListNavigationModule)();
};
_ListNavigationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ListNavigationModule
});
_ListNavigationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NgSelectModule, FormsModule, ReactiveFormsModule, IconModule, PaginationModule, SortingModule, TotalModule]
});
var ListNavigationModule = _ListNavigationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NgSelectModule, FormsModule, ReactiveFormsModule, IconModule, PaginationModule, SortingModule, TotalModule],
      exports: [SortingComponent, PaginationComponent, TotalComponent]
    }]
  }], null, null);
})();
var _MediaConfig = class _MediaConfig {
};
_MediaConfig.\u0275fac = function MediaConfig_Factory(t) {
  return new (t || _MediaConfig)();
};
_MediaConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _MediaConfig,
  factory: function MediaConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _MediaConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var MediaConfig = _MediaConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var _ProgressButtonComponent = class _ProgressButtonComponent {
  constructor() {
    this.ariaLabel = "";
    this.class = "";
    this.disabled = false;
    this.loading = false;
    this.clickEvent = new EventEmitter();
  }
};
_ProgressButtonComponent.\u0275fac = function ProgressButtonComponent_Factory(t) {
  return new (t || _ProgressButtonComponent)();
};
_ProgressButtonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProgressButtonComponent,
  selectors: [["cx-progress-button"]],
  inputs: {
    ariaLabel: "ariaLabel",
    class: "class",
    disabled: "disabled",
    loading: "loading"
  },
  outputs: {
    clickEvent: "clickEvent"
  },
  ngContentSelectors: _c12,
  decls: 4,
  vars: 4,
  consts: [[1, "btn", "btn-primary", 3, "click", "disabled", "ngClass"], [1, "cx-progress-button-container"], ["class", "loader-container", 4, "ngIf"], [1, "loader-container"], [1, "loader"]],
  template: function ProgressButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275listener("click", function ProgressButtonComponent_Template_button_click_0_listener() {
        return ctx.clickEvent.emit();
      });
      \u0275\u0275elementStart(1, "div", 1);
      \u0275\u0275template(2, ProgressButtonComponent_div_2_Template, 4, 3, "div", 2);
      \u0275\u0275projection(3);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("disabled", ctx.disabled || ctx.loading)("ngClass", ctx.class);
      \u0275\u0275attribute("aria-label", ctx.ariaLabel);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.loading);
    }
  },
  dependencies: [NgClass, NgIf, TranslatePipe],
  encapsulation: 2
});
var ProgressButtonComponent = _ProgressButtonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressButtonComponent, [{
    type: Component,
    args: [{
      selector: "cx-progress-button",
      template: `<button
  (click)="clickEvent.emit()"
  [attr.aria-label]="ariaLabel"
  [disabled]="disabled || loading"
  [ngClass]="class"
  class="btn btn-primary"
>
  <div class="cx-progress-button-container">
    <div *ngIf="loading" class="loader-container">
      <div class="loader">{{ 'spinner.loading' | cxTranslate }}</div>
    </div>
    <ng-content></ng-content>
  </div>
</button>
`
    }]
  }], () => [], {
    ariaLabel: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    clickEvent: [{
      type: Output
    }]
  });
})();
var _ProgressButtonModule = class _ProgressButtonModule {
};
_ProgressButtonModule.\u0275fac = function ProgressButtonModule_Factory(t) {
  return new (t || _ProgressButtonModule)();
};
_ProgressButtonModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProgressButtonModule
});
_ProgressButtonModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule]
});
var ProgressButtonModule = _ProgressButtonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressButtonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule],
      declarations: [ProgressButtonComponent],
      exports: [ProgressButtonComponent]
    }]
  }], null, null);
})();
var _SplitViewService = class _SplitViewService {
  constructor() {
    this.defaultHideMode = true;
    this.splitViewCount = 1;
    this._views$ = new BehaviorSubject([]);
  }
  /**
   * Adds a view to the list of views. The view is initialized with the `SplitViewState`
   * state. If no state is provided, the state is created with the hidden property. The hidden
   * property is provided by the `defaultHideMode`, unless it's the first view (position: 0).
   */
  add(position, initialState) {
    const state = __spreadValues(__spreadValues({}, {
      hidden: position === 0 ? false : this.defaultHideMode
    }), initialState);
    if (!this.views[position]) {
      this.views[position] = state;
      this.updateState(position, state.hidden);
      this._views$.next(this.views);
    }
  }
  /**
   * The split view is based on a number of views that can be used next to each other.
   * When the number changes (i.e. if the screen goes from wide to small), the visibility state
   * of the views should be updated.
   */
  updateSplitView(splitViewCount) {
    if (splitViewCount !== this.splitViewCount) {
      this.splitViewCount = splitViewCount;
      this.updateState();
    }
  }
  /**
   * Returns an observable with the active view number. The active view number
   * represents the last visible view.
   */
  getActiveView() {
    return this._views$.pipe(map((views) => this.getActive(views)), distinctUntilChanged());
  }
  /**
   * Returns an observable with the SplitViewState for the given view position.
   */
  getViewState(position) {
    return this._views$.pipe(
      map((views) => views[position]),
      // we must filter here, since outlet driven views will destroyed the view
      filter((view) => Boolean(view))
    );
  }
  /**
   * Removes a view from the list of views.
   *
   * Removing a view is different from hiding a view. Removing a view is typically done
   * when a component is destroyed.
   *
   * When the view is removed, the SplitViewState is updated to reflect that new organization
   * of views.
   */
  remove(position) {
    const activePosition = this.getActive(this.views);
    this._views$.next(this.views.splice(0, position));
    if (activePosition >= position) {
      this.updateState(position);
    }
  }
  /**
   * Returns the next view position. This is useful for views that do not want to be bothered
   * with controlling view numbers.
   */
  get nextPosition() {
    return this.views.length || 0;
  }
  /**
   * Toggles the visibility of the views based on the given view position. If the view
   * is already visible, we close the view and active the former view. Unless the hide flag
   * is used, to force the view.
   *
   * The view state of other views in the split view are updated as well.
   *
   * @param position The zero-based position number of the view.
   * @param forceHide The (optional) hide state for the view position.
   */
  toggle(position, forceHide) {
    if (!this.views[position]) {
      this.add(position, {
        hidden: forceHide ?? false
      });
    }
    if (this.views[position] && forceHide === void 0 && !this.views[position].hidden) {
      position--;
    }
    this.updateState(position, forceHide === true);
  }
  /**
   * Updates the hidden state of all the views.
   */
  updateState(position, hide) {
    const views = [...this.views];
    if (hide !== void 0 && position && views[position]) {
      views[position].hidden = hide;
    }
    let lastVisible = views.length - [...views].reverse().findIndex((view) => !view.hidden) - 1;
    if (lastVisible === views.length) {
      if (position) {
        lastVisible = position - 1;
      } else {
        lastVisible = views.length - 1;
      }
    }
    views.forEach((view, pos) => {
      if (view && pos !== position) {
        view.hidden = pos > lastVisible || pos < lastVisible - (this.splitViewCount - 1);
      }
    });
    this._views$.next(views);
  }
  /**
   * Returns the active view count for the list of views.
   */
  getActive(views) {
    const l = [...views].reverse().findIndex((view) => !view.hidden);
    const last = l === -1 ? 0 : views.length - l - 1;
    return last;
  }
  /**
   * Utility method that resolves all views from the subject.
   */
  get views() {
    return this._views$.value;
  }
};
_SplitViewService.\u0275fac = function SplitViewService_Factory(t) {
  return new (t || _SplitViewService)();
};
_SplitViewService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SplitViewService,
  factory: _SplitViewService.\u0275fac
});
var SplitViewService = _SplitViewService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitViewService, [{
    type: Injectable
  }], null, null);
})();
var _SplitViewComponent = class _SplitViewComponent {
  /**
   * Sets the default hide mode for views. This mode is useful in case views are dynamically being created,
   * for example when they are created by router components.
   *
   * The mode defaults to true, unless this is the first view; the first view is never hidden.
   */
  set hideMode(mode) {
    this.splitService.defaultHideMode = mode;
  }
  constructor(splitService, breakpointService, elementRef) {
    this.splitService = splitService;
    this.breakpointService = breakpointService;
    this.elementRef = elementRef;
    this.subscription = new Subscription();
    this.lastVisibleView = 1;
  }
  ngOnInit() {
    this.subscription.add(this.splitService.getActiveView().subscribe((lastVisible) => this.lastVisibleView = lastVisible + 1));
    this.subscription.add(this.breakpointService.breakpoint$.subscribe(() => {
      this.splitService.updateSplitView(this.splitViewCount);
    }));
  }
  /**
   * Returns the maximum number of views per split-view. The number is based on the
   * CSS custom property `--cx-max-views`.
   */
  get splitViewCount() {
    return Number(getComputedStyle(this.elementRef.nativeElement).getPropertyValue("--cx-max-views"));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_SplitViewComponent.\u0275fac = function SplitViewComponent_Factory(t) {
  return new (t || _SplitViewComponent)(\u0275\u0275directiveInject(SplitViewService), \u0275\u0275directiveInject(BreakpointService), \u0275\u0275directiveInject(ElementRef));
};
_SplitViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SplitViewComponent,
  selectors: [["cx-split-view"]],
  hostVars: 3,
  hostBindings: function SplitViewComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("active-view", ctx.lastVisibleView);
      \u0275\u0275styleProp("--cx-active-view", ctx.lastVisibleView);
    }
  },
  inputs: {
    hideMode: "hideMode"
  },
  features: [\u0275\u0275ProvidersFeature([SplitViewService])],
  ngContentSelectors: _c12,
  decls: 1,
  vars: 0,
  template: function SplitViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var SplitViewComponent = _SplitViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitViewComponent, [{
    type: Component,
    args: [{
      selector: "cx-split-view",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [SplitViewService],
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: SplitViewService
  }, {
    type: BreakpointService
  }, {
    type: ElementRef
  }], {
    hideMode: [{
      type: Input
    }],
    lastVisibleView: [{
      type: HostBinding,
      args: ["style.--cx-active-view"]
    }, {
      type: HostBinding,
      args: ["attr.active-view"]
    }]
  });
})();
var _ViewComponent = class _ViewComponent {
  /**
   * The hidden input is used to set the initial visible state of the view.
   * The hidden state defaults to false.
   *
   * The hidden input supports 2-way binding, see `hiddenChange` property.
   */
  set hidden(hidden) {
    this._hidden = hidden;
    this.splitService.toggle(this.viewPosition, hidden);
  }
  constructor(splitService, elementRef, cd) {
    this.splitService = splitService;
    this.elementRef = elementRef;
    this.cd = cd;
    this.disappeared = true;
    this.hiddenChange = new EventEmitter();
  }
  ngOnInit() {
    const hidden = this._hidden ? {
      hidden: this._hidden
    } : {};
    this.splitService.add(this.viewPosition, hidden);
    this.subscription = this.splitService.getViewState(this.viewPosition).pipe(delayWhen((view) => timer(view.hidden ? this.duration * 1.25 : 0))).subscribe((view) => {
      this.hiddenChange.emit(view.hidden);
      this._hidden = view.hidden;
      this.disappeared = view.hidden;
      this.cd.markForCheck();
    });
  }
  /**
   * Toggles the visibility of the view.
   *
   * An optional force flag can be used to explicitly show or hide view component.
   */
  toggle(force) {
    this.splitService.toggle(this.viewPosition, force);
  }
  /**
   * Returns the position for the view.
   *
   * The position is either taken from the input `position` or generated by the `SplitService`.
   */
  get viewPosition() {
    if (!(Number(this.position) >= 0)) {
      this.position = this.splitService.nextPosition.toString();
    }
    return Number(this.position);
  }
  /**
   * Returns the duration in milliseconds. The duration is based on the CSS custom property
   * `--cx-transition-duration`. Defaults to 300 milliseconds.
   */
  get duration() {
    const duration = getComputedStyle(this.elementRef.nativeElement).getPropertyValue("--cx-transition-duration").trim();
    if (duration.indexOf("ms") > -1) {
      return Number(duration.split("ms")[0]);
    } else if (duration.indexOf("s") > -1) {
      return Number(duration.split("s")[0]) * 1e3;
    } else {
      return 300;
    }
  }
  /**
   * The view is removed from the `SplitService` so that the view no longer
   * plays a role in the overall split view.
   */
  ngOnDestroy() {
    this.splitService.remove(this.viewPosition);
    this.subscription?.unsubscribe();
  }
};
_ViewComponent.\u0275fac = function ViewComponent_Factory(t) {
  return new (t || _ViewComponent)(\u0275\u0275directiveInject(SplitViewService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ViewComponent,
  selectors: [["cx-view"]],
  hostVars: 4,
  hostBindings: function ViewComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("position", ctx.position)("disappeared", ctx.disappeared);
      \u0275\u0275styleProp("--cx-view-position", ctx.position);
    }
  },
  inputs: {
    position: "position",
    hidden: "hidden"
  },
  outputs: {
    hiddenChange: "hiddenChange"
  },
  ngContentSelectors: _c12,
  decls: 1,
  vars: 0,
  template: function ViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var ViewComponent = _ViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewComponent, [{
    type: Component,
    args: [{
      selector: "cx-view",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: SplitViewService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    position: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.position"]
    }, {
      type: HostBinding,
      args: ["style.--cx-view-position"]
    }],
    disappeared: [{
      type: HostBinding,
      args: ["attr.disappeared"]
    }],
    hidden: [{
      type: Input
    }],
    hiddenChange: [{
      type: Output
    }]
  });
})();
var _SplitViewModule = class _SplitViewModule {
};
_SplitViewModule.\u0275fac = function SplitViewModule_Factory(t) {
  return new (t || _SplitViewModule)();
};
_SplitViewModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SplitViewModule
});
_SplitViewModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule]
});
var SplitViewModule = _SplitViewModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitViewModule, [{
    type: NgModule,
    args: [{
      declarations: [SplitViewComponent, ViewComponent],
      imports: [CommonModule, RouterModule],
      exports: [SplitViewComponent, ViewComponent]
    }]
  }], null, null);
})();
var _GlobalMessageComponent = class _GlobalMessageComponent {
  constructor(globalMessageService) {
    this.globalMessageService = globalMessageService;
    this.iconTypes = ICON_TYPE;
    this.messageType = GlobalMessageType;
  }
  ngOnInit() {
    this.messages$ = this.globalMessageService.get();
  }
  clear(type, index) {
    this.globalMessageService.remove(type, index);
  }
};
_GlobalMessageComponent.\u0275fac = function GlobalMessageComponent_Factory(t) {
  return new (t || _GlobalMessageComponent)(\u0275\u0275directiveInject(GlobalMessageService));
};
_GlobalMessageComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GlobalMessageComponent,
  selectors: [["cx-global-message"]],
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], ["class", "cx-visually-hidden", 4, "ngFor", "ngForOf"], ["class", "alert alert-success", 4, "ngFor", "ngForOf"], ["class", "alert alert-info", 4, "ngFor", "ngForOf"], ["class", "alert alert-warning", 4, "ngFor", "ngForOf"], ["class", "alert alert-danger", 4, "ngFor", "ngForOf"], [1, "cx-visually-hidden"], [1, "alert", "alert-success"], [1, "alert-icon"], [3, "type"], ["type", "button", 1, "close", 3, "click"], [1, "alert", "alert-info"], [1, "alert", "alert-warning"], [1, "alert", "alert-danger"]],
  template: function GlobalMessageComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, GlobalMessageComponent_div_0_Template, 6, 5, "div", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.messages$));
    }
  },
  dependencies: [NgForOf, NgIf, IconComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var GlobalMessageComponent = _GlobalMessageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalMessageComponent, [{
    type: Component,
    args: [{
      selector: "cx-global-message",
      template: '<div *ngIf="messages$ | async as messages">\n  <div\n    class="cx-visually-hidden"\n    *ngFor="let assistiveMsg of messages[messageType.MSG_TYPE_ASSISTIVE]"\n  >\n    <span>{{ assistiveMsg | cxTranslate }}</span>\n  </div>\n  <div\n    class="alert alert-success"\n    *ngFor="\n      let confMsg of messages[messageType.MSG_TYPE_CONFIRMATION];\n      let i = index\n    "\n  >\n    <span class="alert-icon">\n      <cx-icon [type]="iconTypes.SUCCESS"></cx-icon>\n    </span>\n    <span>{{ confMsg | cxTranslate }}</span>\n    <button\n      class="close"\n      type="button"\n      (click)="clear(messageType.MSG_TYPE_CONFIRMATION, i)"\n    >\n      <cx-icon [type]="iconTypes.CLOSE"></cx-icon>\n    </button>\n  </div>\n  <div\n    class="alert alert-info"\n    *ngFor="let infoMsg of messages[messageType.MSG_TYPE_INFO]; let i = index"\n  >\n    <span class="alert-icon">\n      <cx-icon [type]="iconTypes.INFO"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class="close"\n      type="button"\n      (click)="clear(messageType.MSG_TYPE_INFO, i)"\n    >\n      <cx-icon [type]="iconTypes.CLOSE"></cx-icon>\n    </button>\n  </div>\n  <div\n    class="alert alert-warning"\n    *ngFor="\n      let infoMsg of messages[messageType.MSG_TYPE_WARNING];\n      let i = index\n    "\n  >\n    <span class="alert-icon">\n      <cx-icon [type]="iconTypes.WARNING"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class="close"\n      type="button"\n      (click)="clear(messageType.MSG_TYPE_WARNING, i)"\n    >\n      <cx-icon [type]="iconTypes.CLOSE"></cx-icon>\n    </button>\n  </div>\n  <div\n    class="alert alert-danger"\n    *ngFor="let errorMsg of messages[messageType.MSG_TYPE_ERROR]; let i = index"\n  >\n    <span class="alert-icon">\n      <cx-icon [type]="iconTypes.ERROR"></cx-icon>\n    </span>\n    <span>{{ errorMsg | cxTranslate }}</span>\n    <button\n      class="close"\n      type="button"\n      (click)="clear(messageType.MSG_TYPE_ERROR, i)"\n    >\n      <cx-icon [type]="iconTypes.CLOSE"></cx-icon>\n    </button>\n  </div>\n</div>\n'
    }]
  }], () => [{
    type: GlobalMessageService
  }], null);
})();
var _GlobalMessageComponentModule = class _GlobalMessageComponentModule {
};
_GlobalMessageComponentModule.\u0275fac = function GlobalMessageComponentModule_Factory(t) {
  return new (t || _GlobalMessageComponentModule)();
};
_GlobalMessageComponentModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _GlobalMessageComponentModule
});
_GlobalMessageComponentModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, IconModule, I18nModule]
});
var GlobalMessageComponentModule = _GlobalMessageComponentModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalMessageComponentModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, IconModule, I18nModule],
      declarations: [GlobalMessageComponent],
      exports: [GlobalMessageComponent]
    }]
  }], null, null);
})();
var _MessageComponent = class _MessageComponent {
  constructor() {
    this.showBody = false;
    this.isVisibleCloseButton = true;
    this.closeMessage = new EventEmitter();
    this.buttonAction = new EventEmitter();
    this.iconTypes = ICON_TYPE;
  }
  get getCssClassesForMessage() {
    return {
      "cx-message-success": this.type === GlobalMessageType.MSG_TYPE_CONFIRMATION,
      "cx-message-info": this.type === GlobalMessageType.MSG_TYPE_INFO,
      "cx-message-warning": this.type === GlobalMessageType.MSG_TYPE_WARNING,
      "cx-message-danger": this.type === GlobalMessageType.MSG_TYPE_ERROR
    };
  }
  get getIconType() {
    switch (this.type) {
      case GlobalMessageType.MSG_TYPE_WARNING:
        return ICON_TYPE.WARNING;
      case GlobalMessageType.MSG_TYPE_ERROR:
        return ICON_TYPE.ERROR;
      case GlobalMessageType.MSG_TYPE_INFO:
        return ICON_TYPE.INFO;
      default:
        return ICON_TYPE.SUCCESS;
    }
  }
};
_MessageComponent.\u0275fac = function MessageComponent_Factory(t) {
  return new (t || _MessageComponent)();
};
_MessageComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MessageComponent,
  selectors: [["cx-message"]],
  inputs: {
    text: "text",
    actionButtonText: "actionButtonText",
    actionButtonMessage: "actionButtonMessage",
    accordionText: "accordionText",
    showBody: "showBody",
    isVisibleCloseButton: "isVisibleCloseButton",
    type: "type"
  },
  outputs: {
    closeMessage: "closeMessage",
    buttonAction: "buttonAction"
  },
  ngContentSelectors: _c12,
  decls: 11,
  vars: 7,
  consts: [[1, "cx-message", 3, "ngClass"], [1, "cx-message-content"], [1, "cx-message-header"], [1, "cx-message-icon"], [3, "type"], [1, "cx-message-text"], ["aria-hidden", "true", "class", "cx-message-accordion-button link cx-action-link", "type", "button", 3, "click", 4, "ngIf"], ["aria-hidden", "true", "class", "btn btn-link cx-action-link", "type", "button", 3, "cxAtMessage", "click", 4, "ngIf"], ["aria-hidden", "true", "class", "close", "type", "button", 3, "cxAtMessage", "click", 4, "ngIf"], ["class", "cx-message-body", 4, "ngIf"], ["aria-hidden", "true", "type", "button", 1, "cx-message-accordion-button", "link", "cx-action-link", 3, "click"], [1, "cx-message-accordion-icon", 3, "type"], ["aria-hidden", "true", "type", "button", 1, "btn", "btn-link", "cx-action-link", 3, "click", "cxAtMessage"], ["aria-hidden", "true", "type", "button", 1, "close", 3, "click", "cxAtMessage"], [1, "cx-message-body"]],
  template: function MessageComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "span", 3);
      \u0275\u0275element(4, "cx-icon", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "span", 5);
      \u0275\u0275text(6);
      \u0275\u0275template(7, MessageComponent_button_7_Template, 3, 4, "button", 6)(8, MessageComponent_button_8_Template, 2, 2, "button", 7);
      \u0275\u0275elementEnd();
      \u0275\u0275template(9, MessageComponent_button_9_Template, 4, 7, "button", 8);
      \u0275\u0275elementEnd();
      \u0275\u0275template(10, MessageComponent_div_10_Template, 2, 0, "div", 9);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("ngClass", ctx.getCssClassesForMessage);
      \u0275\u0275advance(4);
      \u0275\u0275property("type", ctx.getIconType);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.text, " ");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.accordionText);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.actionButtonText);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isVisibleCloseButton);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showBody || !ctx.accordionText);
    }
  },
  dependencies: [AtMessageDirective, NgClass, NgIf, IconComponent, TranslatePipe],
  encapsulation: 2
});
var MessageComponent = _MessageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageComponent, [{
    type: Component,
    args: [{
      selector: "cx-message",
      template: `<div [ngClass]="getCssClassesForMessage" class="cx-message">
  <div class="cx-message-content">
    <div class="cx-message-header">
      <span class="cx-message-icon">
        <cx-icon [type]="getIconType"></cx-icon>
      </span>

      <span class="cx-message-text">
        {{ text }}
        <button
          *ngIf="accordionText"
          (click)="showBody = !showBody"
          [attr.aria-expanded]="showBody"
          [attr.aria-label]="accordionText"
          aria-hidden="true"
          class="cx-message-accordion-button link cx-action-link"
          type="button"
        >
          {{ accordionText }}
          <cx-icon
            [type]="showBody ? 'CARET_UP' : 'CARET_DOWN'"
            class="cx-message-accordion-icon"
          ></cx-icon>
        </button>

        <button
          *ngIf="actionButtonText"
          (click)="buttonAction.emit()"
          [cxAtMessage]="actionButtonMessage"
          aria-hidden="true"
          class="btn btn-link cx-action-link"
          type="button"
        >
          {{ actionButtonText }}
        </button>
      </span>

      <button
        *ngIf="isVisibleCloseButton"
        (click)="closeMessage.emit()"
        [attr.aria-label]="'common.close' | cxTranslate"
        [cxAtMessage]="'common.close' | cxTranslate"
        aria-hidden="true"
        class="close"
        type="button"
      >
        <cx-icon [type]="iconTypes.CLOSE"></cx-icon>
      </button>
    </div>

    <div *ngIf="showBody || !accordionText" class="cx-message-body">
      <ng-content></ng-content>
    </div>
  </div>
</div>
`
    }]
  }], () => [], {
    text: [{
      type: Input
    }],
    actionButtonText: [{
      type: Input
    }],
    actionButtonMessage: [{
      type: Input
    }],
    accordionText: [{
      type: Input
    }],
    showBody: [{
      type: Input
    }],
    isVisibleCloseButton: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    closeMessage: [{
      type: Output
    }],
    buttonAction: [{
      type: Output
    }]
  });
})();
var _MessageComponentModule = class _MessageComponentModule {
};
_MessageComponentModule.\u0275fac = function MessageComponentModule_Factory(t) {
  return new (t || _MessageComponentModule)();
};
_MessageComponentModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _MessageComponentModule
});
_MessageComponentModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [AtMessageModule, CommonModule, I18nModule, IconModule]
});
var MessageComponentModule = _MessageComponentModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageComponentModule, [{
    type: NgModule,
    args: [{
      imports: [AtMessageModule, CommonModule, I18nModule, IconModule],
      declarations: [MessageComponent],
      exports: [MessageComponent]
    }]
  }], null, null);
})();
var _PromotionsComponent = class _PromotionsComponent {
  constructor() {
  }
};
_PromotionsComponent.\u0275fac = function PromotionsComponent_Factory(t) {
  return new (t || _PromotionsComponent)();
};
_PromotionsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PromotionsComponent,
  selectors: [["cx-promotions"]],
  inputs: {
    promotions: "promotions"
  },
  decls: 1,
  vars: 1,
  consts: [["class", "cx-promotions", 4, "ngIf"], [1, "cx-promotions"], [4, "ngIf"], [4, "ngFor", "ngForOf"]],
  template: function PromotionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, PromotionsComponent_div_0_Template, 3, 2, "div", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.promotions);
    }
  },
  dependencies: [NgForOf, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var PromotionsComponent = _PromotionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PromotionsComponent, [{
    type: Component,
    args: [{
      selector: "cx-promotions",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div class="cx-promotions" *ngIf="promotions">\n  <ng-container *ngIf="promotions.length === 1">\n    <p>{{ promotions[0].description }}</p>\n  </ng-container>\n  <ng-container *ngIf="promotions.length > 1">\n    <ul>\n      <li *ngFor="let promotion of promotions">\n        {{ promotion.description }}\n      </li>\n    </ul>\n  </ng-container>\n</div>\n'
    }]
  }], () => [], {
    promotions: [{
      type: Input
    }]
  });
})();
var _PromotionsModule = class _PromotionsModule {
};
_PromotionsModule.\u0275fac = function PromotionsModule_Factory(t) {
  return new (t || _PromotionsModule)();
};
_PromotionsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PromotionsModule
});
_PromotionsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var PromotionsModule = _PromotionsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PromotionsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PromotionsComponent],
      exports: [PromotionsComponent]
    }]
  }], null, null);
})();
var SiteContextType;
(function(SiteContextType2) {
  SiteContextType2["LANGUAGE"] = "LANGUAGE";
  SiteContextType2["CURRENCY"] = "CURRENCY";
})(SiteContextType || (SiteContextType = {}));
var LABELS = {
  [LANGUAGE_CONTEXT_ID]: "Language",
  [CURRENCY_CONTEXT_ID]: "Currency"
};
var _SiteContextComponentService = class _SiteContextComponentService {
  constructor(componentData, contextServiceMap, injector) {
    this.componentData = componentData;
    this.contextServiceMap = contextServiceMap;
    this.injector = injector;
  }
  getItems(context) {
    return this.getService(context).pipe(switchMap((service) => service.getAll()), switchMap((items) => this.getContext(context).pipe(switchMap((ctx) => {
      const itemsCopy = [];
      for (const item of items) {
        itemsCopy.push(__spreadProps(__spreadValues({}, item), {
          label: this.getOptionLabel(item, ctx)
        }));
      }
      return of(itemsCopy);
    }))));
  }
  getActiveItem(context) {
    return this.getService(context).pipe(switchMap((service) => service.getActive()));
  }
  getLabel(context) {
    return this.getContext(context).pipe(map((ctx) => {
      if (ctx) {
        return LABELS[ctx];
      }
    }));
  }
  setActive(value, context) {
    this.getService(context).pipe(take(1)).subscribe((service) => {
      service.setActive(value);
    });
  }
  getService(context) {
    return this.getContext(context).pipe(map((ctx) => ctx ? this.getInjectedService(ctx) : void 0), filter(isNotUndefined));
  }
  getContext(context) {
    if (context) {
      if (context === SiteContextType.CURRENCY) {
        return of(CURRENCY_CONTEXT_ID);
      } else if (context === SiteContextType.LANGUAGE) {
        return of(LANGUAGE_CONTEXT_ID);
      } else {
        return of(context);
      }
    } else if (this.componentData) {
      return this.componentData.data$.pipe(map((data) => data.context), map((ctx) => {
        switch (ctx) {
          case "LANGUAGE":
            return LANGUAGE_CONTEXT_ID;
          case "CURRENCY":
            return CURRENCY_CONTEXT_ID;
          default:
            return ctx;
        }
      }));
    }
    return of(void 0);
  }
  getInjectedService(context) {
    return this.injector.get(this.contextServiceMap[context], void 0);
  }
  getOptionLabel(item, context) {
    switch (context) {
      case LANGUAGE_CONTEXT_ID:
        return item.nativeName;
      case CURRENCY_CONTEXT_ID:
        return item.symbol + " " + item.isocode;
      default:
        return item.isocode;
    }
  }
};
_SiteContextComponentService.\u0275fac = function SiteContextComponentService_Factory(t) {
  return new (t || _SiteContextComponentService)(\u0275\u0275inject(CmsComponentData, 8), \u0275\u0275inject(ContextServiceMap), \u0275\u0275inject(Injector));
};
_SiteContextComponentService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SiteContextComponentService,
  factory: _SiteContextComponentService.\u0275fac
});
var SiteContextComponentService = _SiteContextComponentService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SiteContextComponentService, [{
    type: Injectable
  }], () => [{
    type: CmsComponentData,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ContextServiceMap
  }, {
    type: Injector
  }], null);
})();
var _SiteContextSelectorComponent = class _SiteContextSelectorComponent {
  constructor(componentService) {
    this.componentService = componentService;
    this.iconTypes = ICON_TYPE;
  }
  get items$() {
    return this.componentService.getItems(this.context);
  }
  get activeItem$() {
    return this.componentService.getActiveItem(this.context);
  }
  set active(value) {
    this.componentService.setActive(value, this.context);
  }
  get label$() {
    return this.componentService.getLabel(this.context);
  }
};
_SiteContextSelectorComponent.\u0275fac = function SiteContextSelectorComponent_Factory(t) {
  return new (t || _SiteContextSelectorComponent)(\u0275\u0275directiveInject(SiteContextComponentService));
};
_SiteContextSelectorComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SiteContextSelectorComponent,
  selectors: [["cx-site-context-selector"]],
  inputs: {
    context: "context"
  },
  decls: 3,
  vars: 5,
  consts: [[4, "ngIf"], [3, "change"], [3, "value", "selected", 4, "ngFor", "ngForOf"], [1, "small", 3, "type"], [3, "value", "selected"]],
  template: function SiteContextSelectorComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, SiteContextSelectorComponent_label_0_Template, 7, 5, "label", 0);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275pipe(2, "async");
    }
    if (rf & 2) {
      let tmp_0_0;
      \u0275\u0275property("ngIf", ((tmp_0_0 = \u0275\u0275pipeBind1(1, 1, ctx.items$)) == null ? null : tmp_0_0.length) > 1 && \u0275\u0275pipeBind1(2, 3, ctx.items$));
    }
  },
  dependencies: [NgForOf, NgIf, IconComponent, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var SiteContextSelectorComponent = _SiteContextSelectorComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SiteContextSelectorComponent, [{
    type: Component,
    args: [{
      selector: "cx-site-context-selector",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<label *ngIf="(items$ | async)?.length > 1 && (items$ | async) as items">\n  <span>{{ label$ | async }}:</span>\n  <select (change)="active = $any($event).target.value">\n    <option\n      *ngFor="let item of items"\n      value="{{ item.isocode }}"\n      [selected]="(activeItem$ | async) === item.isocode"\n    >\n      {{ item.label }}\n    </option>\n  </select>\n  <cx-icon [type]="iconTypes.CARET_DOWN" class="small"></cx-icon>\n</label>\n'
    }]
  }], () => [{
    type: SiteContextComponentService
  }], {
    context: [{
      type: Input
    }]
  });
})();
var _LanguageCurrencyComponent = class _LanguageCurrencyComponent {
  constructor() {
    this.siteContextType = SiteContextType;
  }
};
_LanguageCurrencyComponent.\u0275fac = function LanguageCurrencyComponent_Factory(t) {
  return new (t || _LanguageCurrencyComponent)();
};
_LanguageCurrencyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LanguageCurrencyComponent,
  selectors: [["cx-language-currency-selector"]],
  decls: 2,
  vars: 2,
  consts: [[3, "context"]],
  template: function LanguageCurrencyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "cx-site-context-selector", 0)(1, "cx-site-context-selector", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("context", ctx.siteContextType.LANGUAGE);
      \u0275\u0275advance();
      \u0275\u0275property("context", ctx.siteContextType.CURRENCY);
    }
  },
  dependencies: [SiteContextSelectorComponent],
  encapsulation: 2,
  changeDetection: 0
});
var LanguageCurrencyComponent = _LanguageCurrencyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LanguageCurrencyComponent, [{
    type: Component,
    args: [{
      selector: "cx-language-currency-selector",
      template: `
    <cx-site-context-selector
      [context]="siteContextType.LANGUAGE"
    ></cx-site-context-selector>
    <cx-site-context-selector
      [context]="siteContextType.CURRENCY"
    ></cx-site-context-selector>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var _SiteContextSelectorModule = class _SiteContextSelectorModule {
};
_SiteContextSelectorModule.\u0275fac = function SiteContextSelectorModule_Factory(t) {
  return new (t || _SiteContextSelectorModule)();
};
_SiteContextSelectorModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SiteContextSelectorModule
});
_SiteContextSelectorModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      CMSSiteContextComponent: {
        component: SiteContextSelectorComponent,
        providers: [{
          provide: SiteContextComponentService,
          useClass: SiteContextComponentService,
          deps: [CmsComponentData, ContextServiceMap, Injector]
        }]
      },
      LanguageCurrencyComponent: {
        component: LanguageCurrencyComponent
      }
    }
  }), SiteContextComponentService],
  imports: [CommonModule, RouterModule, SiteContextModule, IconModule]
});
var SiteContextSelectorModule = _SiteContextSelectorModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SiteContextSelectorModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, SiteContextModule, IconModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          CMSSiteContextComponent: {
            component: SiteContextSelectorComponent,
            providers: [{
              provide: SiteContextComponentService,
              useClass: SiteContextComponentService,
              deps: [CmsComponentData, ContextServiceMap, Injector]
            }]
          },
          LanguageCurrencyComponent: {
            component: LanguageCurrencyComponent
          }
        }
      }), SiteContextComponentService],
      declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent],
      exports: [SiteContextSelectorComponent, LanguageCurrencyComponent]
    }]
  }], null, null);
})();
var _StarRatingComponent = class _StarRatingComponent {
  constructor() {
    this.initialRate = 0;
    this.icon = ICON_TYPE.STAR;
    this.disabled = true;
    this.rating = this.initialRate;
    this.change = new EventEmitter();
  }
  setRate(value) {
    if (this.disabled) {
      return;
    }
    this.rating = value;
  }
  reset() {
    if (this.disabled) {
      return;
    }
    this.rating = this.initialRate ?? 0;
  }
  saveRate(rating) {
    if (this.disabled) {
      return;
    }
    this.initialRate = rating;
    this.setRate(rating);
    this.change.emit(rating);
  }
};
_StarRatingComponent.\u0275fac = function StarRatingComponent_Factory(t) {
  return new (t || _StarRatingComponent)();
};
_StarRatingComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _StarRatingComponent,
  selectors: [["cx-star-rating"]],
  hostVars: 3,
  hostBindings: function StarRatingComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseout", function StarRatingComponent_mouseout_HostBindingHandler() {
        return ctx.reset();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("disabled", ctx.disabled);
      \u0275\u0275styleProp("--star-fill", ctx.rating);
    }
  },
  inputs: {
    disabled: "disabled",
    rating: "rating"
  },
  outputs: {
    change: "change"
  },
  decls: 1,
  vars: 2,
  consts: [["class", "star", "role", "button", 3, "type", "mouseover", "click", "keydown.space", 4, "ngFor", "ngForOf"], ["role", "button", 1, "star", 3, "mouseover", "click", "keydown.space", "type"]],
  template: function StarRatingComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, StarRatingComponent_cx_icon_0_Template, 2, 8, "cx-icon", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", \u0275\u0275pureFunction0(1, _c19));
    }
  },
  dependencies: [NgForOf, IconComponent, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var StarRatingComponent = _StarRatingComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StarRatingComponent, [{
    type: Component,
    args: [{
      selector: "cx-star-rating",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<cx-icon
  *ngFor="let i of [1, 2, 3, 4, 5]"
  [type]="icon"
  class="star"
  (mouseover)="setRate(i)"
  (click)="saveRate(i)"
  (keydown.space)="saveRate(i)"
  [attr.tabindex]="disabled ? null : 0"
  role="button"
  attr.aria-label="{{ 'productReview.addRate' | cxTranslate: { count: i } }}"
></cx-icon>
`
    }]
  }], null, {
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    rating: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.--star-fill"]
    }],
    change: [{
      type: Output
    }],
    reset: [{
      type: HostListener,
      args: ["mouseout"]
    }]
  });
})();
var _StarRatingModule = class _StarRatingModule {
};
_StarRatingModule.\u0275fac = function StarRatingModule_Factory(t) {
  return new (t || _StarRatingModule)();
};
_StarRatingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _StarRatingModule
});
_StarRatingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, IconModule, I18nModule]
});
var StarRatingModule = _StarRatingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StarRatingModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, IconModule, I18nModule],
      declarations: [StarRatingComponent],
      exports: [StarRatingComponent]
    }]
  }], null, null);
})();
var _TableDataCellComponent = class _TableDataCellComponent {
  constructor(outlet) {
    this.outlet = outlet;
  }
  get value() {
    return this.model[this.field];
  }
  get model() {
    return this.outlet?.context;
  }
  get field() {
    return this.outlet?.context?._field;
  }
};
_TableDataCellComponent.\u0275fac = function TableDataCellComponent_Factory(t) {
  return new (t || _TableDataCellComponent)(\u0275\u0275directiveInject(OutletContextData));
};
_TableDataCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TableDataCellComponent,
  selectors: [["cx-table-data-cell"]],
  hostVars: 1,
  hostBindings: function TableDataCellComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("title", ctx.value);
    }
  },
  decls: 1,
  vars: 1,
  template: function TableDataCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275text(0);
    }
    if (rf & 2) {
      \u0275\u0275textInterpolate(ctx.value);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var TableDataCellComponent = _TableDataCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableDataCellComponent, [{
    type: Component,
    args: [{
      selector: "cx-table-data-cell",
      template: `{{ value }}`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: OutletContextData
  }], {
    value: [{
      type: HostBinding,
      args: ["attr.title"]
    }]
  });
})();
var _TableHeaderCellComponent = class _TableHeaderCellComponent {
  constructor(outlet) {
    this.outlet = outlet;
  }
  /**
   * Returns the static label for the given field, if available.
   */
  get header() {
    if (typeof this.fieldOptions?.label === "string") {
      return this.fieldOptions.label;
    }
  }
  /**
   * Returns the localized label for the given field.
   *
   * The localized label is either driven by the configured `label.i18nKey`
   * or concatenated by the table `type` and field `key`:
   *
   * `[tableType].[fieldKey]`
   *
   * The localized header can be translated with the `cxTranslate` pipe or `TranslationService`.
   */
  get localizedHeader() {
    return this.fieldOptions?.label?.i18nKey || `${this.i18nRoot}.${this.field}`;
  }
  get fieldOptions() {
    return this.outlet?.context._options?.cells?.[this.field];
  }
  get field() {
    return this.outlet?.context?._field;
  }
  get type() {
    return this.outlet?.context?._type;
  }
  get i18nRoot() {
    return this.outlet?.context?._i18nRoot;
  }
};
_TableHeaderCellComponent.\u0275fac = function TableHeaderCellComponent_Factory(t) {
  return new (t || _TableHeaderCellComponent)(\u0275\u0275directiveInject(OutletContextData));
};
_TableHeaderCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TableHeaderCellComponent,
  selectors: [["cx-table-header-cell"]],
  decls: 2,
  vars: 3,
  template: function TableHeaderCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275text(0);
      \u0275\u0275pipe(1, "cxTranslate");
    }
    if (rf & 2) {
      \u0275\u0275textInterpolate(ctx.header || \u0275\u0275pipeBind1(1, 1, ctx.localizedHeader));
    }
  },
  dependencies: [TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var TableHeaderCellComponent = _TableHeaderCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeaderCellComponent, [{
    type: Component,
    args: [{
      selector: "cx-table-header-cell",
      template: `{{ header || (localizedHeader | cxTranslate) }}`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: OutletContextData
  }], null);
})();
var defaultTableConfig = {
  tableOptions: {
    headerComponent: TableHeaderCellComponent,
    dataComponent: TableDataCellComponent
  }
};
var _TableConfig = class _TableConfig {
};
_TableConfig.\u0275fac = function TableConfig_Factory(t) {
  return new (t || _TableConfig)();
};
_TableConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TableConfig,
  factory: function TableConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _TableConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var TableConfig = _TableConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var _TableDataCellModule = class _TableDataCellModule {
};
_TableDataCellModule.\u0275fac = function TableDataCellModule_Factory(t) {
  return new (t || _TableDataCellModule)();
};
_TableDataCellModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TableDataCellModule
});
_TableDataCellModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var TableDataCellModule = _TableDataCellModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableDataCellModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [TableDataCellComponent]
    }]
  }], null, null);
})();
var _TableHeaderCellModule = class _TableHeaderCellModule {
};
_TableHeaderCellModule.\u0275fac = function TableHeaderCellModule_Factory(t) {
  return new (t || _TableHeaderCellModule)();
};
_TableHeaderCellModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TableHeaderCellModule
});
_TableHeaderCellModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule]
});
var TableHeaderCellModule = _TableHeaderCellModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeaderCellModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule],
      declarations: [TableHeaderCellComponent]
    }]
  }], null, null);
})();
var _TableRendererService = class _TableRendererService {
  constructor(outletService, componentFactoryResolver, config) {
    this.outletService = outletService;
    this.componentFactoryResolver = componentFactoryResolver;
    this.config = config;
    this.outletRefs = /* @__PURE__ */ new Map();
  }
  /**
   * Adds the configured table component for the header and data.
   */
  add(structure) {
    structure?.cells?.forEach((field) => {
      const thRenderer = this.getHeaderRenderer(structure, field);
      if (thRenderer) {
        const ref = this.getHeaderOutletRef(structure.type, field);
        this.render(ref, thRenderer);
      }
      const tdRenderer = this.getDataRenderer(structure, field);
      if (tdRenderer) {
        const ref = this.getDataOutletRef(structure.type, field);
        this.render(ref, tdRenderer);
      }
    });
  }
  render(outletRef, renderer) {
    if (this.outletRefs.has(outletRef)) {
      return;
    }
    this.outletRefs.set(outletRef, true);
    const template = this.componentFactoryResolver.resolveComponentFactory(renderer);
    this.outletService.add(outletRef, template);
  }
  /**
   * Returns the header render component for the given field.
   */
  getHeaderRenderer(structure, field) {
    return structure.options?.cells?.[field]?.headerComponent || structure.options?.headerComponent || this.config.tableOptions?.headerComponent;
  }
  /**
   * Returns the data render component for the given field.
   */
  getDataRenderer(structure, field) {
    return structure.options?.cells?.[field]?.dataComponent || structure.options?.dataComponent || this.config.tableOptions?.dataComponent;
  }
  /**
   * Returns the header (th) outlet reference for the given field.
   *
   * The outlet reference is generated as:
   * `table.[tableType].header.[field]`
   */
  getHeaderOutletRef(type, field) {
    return `table.${type}.header.${field}`;
  }
  /**
   * Returns the header (th) outlet context for the given field.
   */
  getHeaderOutletContext(type, options, i18nRoot, field) {
    return {
      _type: type,
      _options: options,
      _field: field,
      _i18nRoot: i18nRoot
    };
  }
  /**
   * Returns the data (td) outlet reference for the given field.
   *
   * The field is generated as:
   * `table.[tableType].data.[tableField]`
   */
  getDataOutletRef(type, field) {
    return `table.${type}.data.${field}`;
  }
  /**
   * Returns the data (td) outlet context for the given field.
   */
  getDataOutletContext(type, options, i18nRoot, field, data) {
    return __spreadProps(__spreadValues({}, data), {
      _type: type,
      _options: options,
      _field: field,
      _i18nRoot: i18nRoot
    });
  }
};
_TableRendererService.\u0275fac = function TableRendererService_Factory(t) {
  return new (t || _TableRendererService)(\u0275\u0275inject(OutletService), \u0275\u0275inject(ComponentFactoryResolver$1), \u0275\u0275inject(TableConfig));
};
_TableRendererService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TableRendererService,
  factory: _TableRendererService.\u0275fac,
  providedIn: "root"
});
var TableRendererService = _TableRendererService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableRendererService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: OutletService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: TableConfig
  }], null);
})();
var TableLayout;
(function(TableLayout2) {
  TableLayout2[TableLayout2["VERTICAL"] = 1] = "VERTICAL";
  TableLayout2[TableLayout2["VERTICAL_STACKED"] = 2] = "VERTICAL_STACKED";
  TableLayout2[TableLayout2["HORIZONTAL"] = 3] = "HORIZONTAL";
})(TableLayout || (TableLayout = {}));
var _TableComponent = class _TableComponent {
  set structure(structure) {
    this._structure = structure;
    this.init();
  }
  get structure() {
    return this._structure;
  }
  constructor(rendererService) {
    this.rendererService = rendererService;
    this.launch = new EventEmitter();
  }
  init() {
    this.verticalLayout = !this.layout || this.layout === TableLayout.VERTICAL;
    this.verticalStackedLayout = this.layout === TableLayout.VERTICAL_STACKED;
    this.horizontalLayout = this.layout === TableLayout.HORIZONTAL;
    this.rendererService.add(this.structure);
    this.addTableDebugInfo();
  }
  launchItem(item) {
    this.launch.emit(item);
  }
  /**
   * Indicates whether the given item is the current item.
   *
   * The current item is driven by the `currentItem`, that holds a
   * property and value to compare.
   */
  isCurrentItem(item) {
    if (!this.currentItem || !this.currentItem.value) {
      return false;
    }
    return this.currentItem?.value === item?.[this.currentItem?.property];
  }
  /**
   * Returns the header (th) outlet reference for the given field.
   */
  getHeaderOutletRef(field) {
    return this.rendererService.getHeaderOutletRef(this.type, field);
  }
  /**
   * Returns the header (th) outlet context for the given field.
   */
  getHeaderOutletContext(field) {
    return this.rendererService.getHeaderOutletContext(this.type, this.options, this.i18nRoot, field);
  }
  /**
   * Returns the data (td) outlet reference for the given field.
   */
  getDataOutletRef(field) {
    return this.rendererService.getDataOutletRef(this.type, field);
  }
  /**
   * Returns the data (td) outlet context for the given field.
   */
  getDataOutletContext(field, data) {
    return this.rendererService.getDataOutletContext(this.type, this.options, this.i18nRoot, field, data);
  }
  trackData(_i, item) {
    return JSON.stringify(item);
  }
  /**
   * Generates the table type into the UI in devMode, so that developers
   * can easily get the notion of the table type.
   */
  addTableDebugInfo() {
    if (isDevMode() && this.type) {
      this.tableType = this.type;
    }
  }
  /**
   * Helper method to return the deeply nested orientation configuration.
   */
  get layout() {
    return this.structure?.options?.layout;
  }
  /**
   * Helper method to return the deeply nested type.
   */
  get type() {
    return this.structure?.type;
  }
  get options() {
    return this.structure?.options;
  }
};
_TableComponent.\u0275fac = function TableComponent_Factory(t) {
  return new (t || _TableComponent)(\u0275\u0275directiveInject(TableRendererService));
};
_TableComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TableComponent,
  selectors: [["cx-table"]],
  hostVars: 7,
  hostBindings: function TableComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("__cx-table-type", ctx.tableType);
      \u0275\u0275classProp("horizontal", ctx.horizontalLayout)("vertical", ctx.verticalLayout)("vertical-stacked", ctx.verticalStackedLayout);
    }
  },
  inputs: {
    structure: "structure",
    data: "data",
    i18nRoot: "i18nRoot",
    currentItem: "currentItem"
  },
  outputs: {
    launch: "launch"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [3, "is-current", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "click"], [3, "class", 4, "ngFor", "ngForOf"], [3, "cxOutlet", "cxOutletContext"], ["scope", "col", 3, "class", 4, "ngFor", "ngForOf"], ["scope", "col"]],
  template: function TableComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, TableComponent_table_0_Template, 4, 3, "table", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.structure);
    }
  },
  dependencies: [NgForOf, NgIf, OutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var TableComponent = _TableComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableComponent, [{
    type: Component,
    args: [{
      selector: "cx-table",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<table *ngIf="structure">\n  <ng-container *ngIf="verticalStackedLayout">\n    <tbody\n      *ngFor="let item of data; trackBy: trackData"\n      (click)="launchItem(item)"\n      [class.is-current]="isCurrentItem(item)"\n    >\n      <tr *ngFor="let cell of structure.cells" [class]="cell">\n        <th>\n          <ng-template\n            [cxOutlet]="getHeaderOutletRef(cell)"\n            [cxOutletContext]="getHeaderOutletContext(cell)"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n        <td>\n          <ng-template\n            [cxOutlet]="getDataOutletRef(cell)"\n            [cxOutletContext]="getDataOutletContext(cell, item)"\n          >\n            {{ $any(item)[cell] }}\n          </ng-template>\n        </td>\n      </tr>\n    </tbody>\n  </ng-container>\n\n  <!-- vertical tables render the item  -->\n  <ng-container *ngIf="verticalLayout">\n    <thead>\n      <tr>\n        <th scope="col" *ngFor="let cell of structure.cells" [class]="cell">\n          <ng-template\n            [cxOutlet]="getHeaderOutletRef(cell)"\n            [cxOutletContext]="getHeaderOutletContext(cell)"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n      </tr>\n    </thead>\n\n    <tr\n      *ngFor="let item of data; trackBy: trackData"\n      [class.is-current]="isCurrentItem(item)"\n      (click)="launchItem(item)"\n    >\n      <td *ngFor="let cell of structure.cells; let i = index" [class]="cell">\n        <ng-template\n          [cxOutlet]="getDataOutletRef(cell)"\n          [cxOutletContext]="getDataOutletContext(cell, item)"\n        >\n          {{ $any(item)[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n\n  <ng-container *ngIf="horizontalLayout">\n    <tr *ngFor="let cell of structure.cells" [class]="cell">\n      <th scope="col">\n        <ng-template\n          [cxOutlet]="getHeaderOutletRef(cell)"\n          [cxOutletContext]="getHeaderOutletContext(cell)"\n        >\n          {{ cell }}\n        </ng-template>\n      </th>\n      <td\n        *ngFor="let item of data; trackBy: trackData"\n        [class.is-current]="isCurrentItem(item)"\n        (click)="launchItem(item)"\n      >\n        <ng-template\n          [cxOutlet]="getDataOutletRef(cell)"\n          [cxOutletContext]="getDataOutletContext(cell, item)"\n        >\n          {{ $any(item)[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n</table>\n'
    }]
  }], () => [{
    type: TableRendererService
  }], {
    tableType: [{
      type: HostBinding,
      args: ["attr.__cx-table-type"]
    }],
    horizontalLayout: [{
      type: HostBinding,
      args: ["class.horizontal"]
    }],
    verticalLayout: [{
      type: HostBinding,
      args: ["class.vertical"]
    }],
    verticalStackedLayout: [{
      type: HostBinding,
      args: ["class.vertical-stacked"]
    }],
    structure: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    i18nRoot: [{
      type: Input
    }],
    currentItem: [{
      type: Input
    }],
    launch: [{
      type: Output
    }]
  });
})();
var _TableModule = class _TableModule {
};
_TableModule.\u0275fac = function TableModule_Factory(t) {
  return new (t || _TableModule)();
};
_TableModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TableModule
});
_TableModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultTableConfig)],
  imports: [CommonModule, OutletModule, TableHeaderCellModule, TableDataCellModule]
});
var TableModule = _TableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, OutletModule, TableHeaderCellModule, TableDataCellModule],
      declarations: [TableComponent],
      exports: [TableComponent],
      providers: [provideDefaultConfig(defaultTableConfig)]
    }]
  }], null, null);
})();
var _TableService = class _TableService {
  constructor(breakpointService, config) {
    this.breakpointService = breakpointService;
    this.config = config;
    this.logger = inject(LoggerService);
  }
  /**
   * Builds the table structure.
   *
   * @param tableType The table type is used  to find the specific table configuration.
   * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
   * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
   */
  buildStructure(tableType, defaultStructure) {
    if (this.hasTableConfig(tableType)) {
      return this.buildStructureFromConfig(tableType, defaultStructure);
    } else {
      return this.buildRandomStructure(tableType);
    }
  }
  /**
   * Returns the table structure by configuration. The configuration can be
   * breakpoint-driven, which means that an alternative header structure can
   * be created per screen size.
   *
   * The breakpoint is resolved by teh `BreakpointService`.
   */
  buildStructureFromConfig(type, defaultStructure) {
    return this.breakpointService.breakpoint$.pipe(map((breakpoint) => __spreadProps(__spreadValues({}, this.getTableConfig(type, breakpoint, defaultStructure)), {
      type
    })));
  }
  /**
   * Finds all applicable table configuration for the given type and breakpoint.
   * The default table configuration is merged with all relevant breakpoint
   * configurations.
   *
   * This allows to have some default configurations that apply to all screens, and
   * add configuration options for some screens.
   */
  getTableConfig(type, breakpoint, defaultStructure) {
    if (!this.config.table?.[type]) {
      return null;
    }
    const relevant = this.findRelevantBreakpoints(breakpoint);
    const closestBreakpoint = [...relevant].reverse().find((br) => !!this.config.table?.[type][br]?.cells);
    const cells = closestBreakpoint && this.config.table[type][closestBreakpoint]?.cells || this.config.table[type].cells || defaultStructure?.cells;
    let options = __spreadValues(__spreadValues({}, defaultStructure?.options), this.config.table[type].options);
    relevant.forEach((br) => {
      options = __spreadValues(__spreadValues(__spreadValues({}, options), defaultStructure?.[br]?.options), this.config.table?.[type]?.[br]?.options);
    });
    return {
      cells,
      options
    };
  }
  /**
   * Generates the table structure by the help of the first data row.
   */
  buildStructureFromData(type, data$) {
    this.logWarning(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
    return data$.pipe(map((data) => {
      const cells = Object.keys(data?.[0]).map((key) => key);
      return {
        type,
        cells
      };
    }));
  }
  /**
   * As a last resort, the table structure is randomly created. The random structure
   * contains 5 headers, so that some of the unknown data is visualized.
   */
  buildRandomStructure(type) {
    this.logWarning(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
    return of({
      type,
      cells: ["unknown", "unknown", "unknown", "unknown", "unknown"]
    });
  }
  /**
   * Finds all the breakpoints can contribute to the table configuration, from small
   * to current.
   *
   * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
   */
  findRelevantBreakpoints(breakpoint) {
    const current = this.breakpointService.breakpoints.indexOf(breakpoint);
    return this.breakpointService.breakpoints.slice(0, current + 1);
  }
  /**
   * Indicates if the there is a configuration for the table available.
   */
  hasTableConfig(tableType) {
    return !!this.config.table?.[tableType];
  }
  /**
   * Logs a message in the console to increase developer experience.
   *
   * The message is only logged in dev mode.
   */
  logWarning(message) {
    if (isDevMode()) {
      this.logger.warn(message);
    }
  }
};
_TableService.\u0275fac = function TableService_Factory(t) {
  return new (t || _TableService)(\u0275\u0275inject(BreakpointService), \u0275\u0275inject(TableConfig));
};
_TableService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TableService,
  factory: _TableService.\u0275fac,
  providedIn: "root"
});
var TableService = _TableService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: BreakpointService
  }, {
    type: TableConfig
  }], null);
})();
var _FilesFormValidators = class _FilesFormValidators {
  constructor() {
    this.CONVERT_TO_MB = 1e6;
    this.extenstionRegEx = /\.([0-9a-z]+)(?:[\?#]|$)/i;
  }
  /**
   * Checks max size of file
   *
   * @param {number} maxSize Max size [MB]
   * @returns Uses 'tooLarge' validator error with maxSize property
   * @memberOf FilesFormValidators
   */
  maxSize(maxSize) {
    return (control) => {
      const errors = {};
      if (maxSize && control.value) {
        const files = Array.from(control.value);
        files.forEach(({
          size,
          name
        }) => {
          if (size > maxSize * this.CONVERT_TO_MB) {
            const invalidFiles = errors.tooLarge?.invalidFiles ?? [];
            errors.tooLarge = {
              maxSize,
              invalidFiles: [...invalidFiles, name]
            };
          }
        });
      }
      return Object.keys(errors).length === 0 ? null : errors;
    };
  }
  /**
   * Checks maximum entries
   *
   * @param {number} maxEntries Max number of entries
   * @returns Uses 'tooManyEntries' validator error with maxEntries property
   * @memberOf FilesFormValidators
   */
  maxEntries(maxEntries) {
    return (control) => {
      const errors = {};
      if (maxEntries && control.value) {
        const files = Array.from(control.value);
        if (files.length > maxEntries) {
          errors.tooManyEntries = {
            maxEntries
          };
        }
      }
      return Object.keys(errors).length === 0 ? null : errors;
    };
  }
  /**
   * Checks allowed types
   *
   * @param {Array<string>} allowedTypes Allowed types of files
   * @returns Uses 'notParsable' validator error with allowedTypes property
   * @memberOf FilesFormValidators
   */
  allowedTypes(allowedTypes) {
    return (control) => {
      const errors = {};
      if (allowedTypes && control.value) {
        const files = Array.from(control.value);
        errors.fileNotAllowed = files.some(({
          name
        }) => !allowedTypes.includes(this.getExtension(name)));
      }
      return errors[Object.keys(errors)?.[0]] ? errors : null;
    };
  }
  getExtension(filename) {
    return (filename?.match(this.extenstionRegEx) || [])[0] || "";
  }
};
_FilesFormValidators.\u0275fac = function FilesFormValidators_Factory(t) {
  return new (t || _FilesFormValidators)();
};
_FilesFormValidators.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FilesFormValidators,
  factory: _FilesFormValidators.\u0275fac,
  providedIn: "root"
});
var FilesFormValidators = _FilesFormValidators;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilesFormValidators, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _AvatarComponent = class _AvatarComponent {
  constructor() {
    this.iconTypes = ICON_TYPE;
  }
  getInitials(author) {
    return author.split(" ").map((string) => string[0]).join("");
  }
};
_AvatarComponent.\u0275fac = function AvatarComponent_Factory(t) {
  return new (t || _AvatarComponent)();
};
_AvatarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AvatarComponent,
  selectors: [["cx-avatar"]],
  inputs: {
    message: "message"
  },
  decls: 1,
  vars: 1,
  consts: [["class", "cx-avatar", 3, "ngClass", 4, "ngIf"], [1, "cx-avatar", 3, "ngClass"], [4, "ngIf"], [3, "type", 4, "ngIf"], [3, "type"]],
  template: function AvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, AvatarComponent_div_0_Template, 4, 6, "div", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.message);
    }
  },
  dependencies: [NgClass, NgIf, IconComponent],
  encapsulation: 2
});
var AvatarComponent = _AvatarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AvatarComponent, [{
    type: Component,
    args: [{
      selector: "cx-avatar",
      template: `<div
  *ngIf="message"
  class="cx-avatar"
  [ngClass]="{ 'right-align': message.rightAlign }"
>
  <span *ngIf="!message.rightAlign && message?.author">
    {{ getInitials(message?.author || '') }}
  </span>

  <cx-icon
    *ngIf="!message.rightAlign && !message?.author"
    [type]="iconTypes.USER"
  ></cx-icon>

  <cx-icon *ngIf="message.rightAlign" [type]="iconTypes.HEADSET"></cx-icon>
</div>
`
    }]
  }], null, {
    message: [{
      type: Input
    }]
  });
})();
var _MessagingComponent = class _MessagingComponent {
  get inputCharacterLeft() {
    return (this.messagingConfigs?.charactersLimit || this.MAX_INPUT_CHARACTERS) - (this.form.get("message")?.value?.length || 0);
  }
  get maxSize() {
    return this.messagingConfigs?.attachmentRestrictions?.maxSize || this.MAX_SIZE;
  }
  get maxEntries() {
    return this.messagingConfigs?.attachmentRestrictions?.maxEntries || this.MAX_ENTRIES;
  }
  get allowedTypes() {
    return this.messagingConfigs?.attachmentRestrictions?.allowedTypes || [];
  }
  constructor(windowRef, filesFormValidators) {
    this.windowRef = windowRef;
    this.filesFormValidators = filesFormValidators;
    this.scrollToInput = true;
    this.send = new EventEmitter();
    this.downloadAttachment = new EventEmitter();
    this.iconTypes = ICON_TYPE;
    this.MAX_INPUT_CHARACTERS = 2e3;
    this.MAX_SIZE = 10;
    this.MAX_ENTRIES = 1;
    this.dateFormat = "MMMM d, YYYY h:mm aa";
    this.scrollOnceOnLoad = true;
  }
  ngOnInit() {
    this.buildForm();
  }
  ngAfterViewChecked() {
    if (this.scrollToInput) {
      this.observeScroll();
      if (this.scrollOnceOnLoad) {
        this.scrollOnLoad();
      }
    }
  }
  onSend() {
    if (this.form.valid) {
      this.send.emit({
        files: this.form.get("file")?.value,
        message: this.form.get("message")?.value
      });
    }
  }
  resetForm() {
    this.form.reset();
    this.fileUploadComponent.removeFile();
  }
  triggerDownload(messageCode, attachmentId, fileName) {
    this.downloadAttachment.emit({
      messageCode,
      attachmentId,
      fileName
    });
  }
  buildForm() {
    const form = new UntypedFormGroup({});
    form.setControl("message", new UntypedFormControl("", [Validators.required, Validators.maxLength(this.messagingConfigs?.charactersLimit || this.MAX_INPUT_CHARACTERS)]));
    form.setControl("file", new UntypedFormControl("", [this.filesFormValidators.maxSize(this.maxSize), this.filesFormValidators.maxEntries(this.maxEntries), this.filesFormValidators.allowedTypes(this.allowedTypes)]));
    this.form = form;
  }
  focusNextChild(event) {
    event.preventDefault();
    const [results, focusedIndex] = [this.getResultElements(), this.getFocusedIndex()];
    if (results.length) {
      if (focusedIndex >= results.length - 1) {
        results[0].focus();
      } else {
        results[focusedIndex + 1].focus();
      }
    }
  }
  focusPreviousChild(event) {
    if (!this.windowRef.isBrowser()) {
      return;
    }
    event.preventDefault();
    const [results, focusedIndex] = [this.getResultElements(), this.getFocusedIndex()];
    if (results.length) {
      if (focusedIndex < 1) {
        results[results.length - 1].focus();
      } else {
        results[focusedIndex - 1].focus();
      }
    }
  }
  observeScroll() {
    const element = this.windowRef.document.querySelector(".cx-messages");
    if (element) {
      const resizeObserver = new ResizeObserver((entries) => {
        this.scrollToBottom(element, entries[0].target.scrollHeight);
        this.updatedScrollHeight = entries[0].target.scrollHeight;
      });
      resizeObserver.observe(element);
    }
  }
  scrollToBottom(element, previousScrollHeight) {
    if (this.heightChanged(previousScrollHeight)) {
      element?.scroll({
        top: element?.scrollHeight,
        behavior: "auto"
      });
    }
  }
  heightChanged(previousScrollHeight) {
    return this.updatedScrollHeight !== previousScrollHeight;
  }
  scrollOnLoad() {
    const element = this.windowRef.document.getElementById("cx-message-footer");
    const resizeObserver = new ResizeObserver(() => {
      element?.scrollIntoView({
        behavior: "auto",
        block: "end"
      });
      this.scrollOnceOnLoad = false;
    });
    if (element) {
      resizeObserver.observe(element);
    }
  }
  getResultElements() {
    return Array.from(this.windowRef.document.querySelectorAll('[role="listitem"]'));
  }
  getFocusedIndex() {
    return this.getResultElements().indexOf(this.getFocusedElement());
  }
  getFocusedElement() {
    return this.windowRef.document.activeElement;
  }
};
_MessagingComponent.\u0275fac = function MessagingComponent_Factory(t) {
  return new (t || _MessagingComponent)(\u0275\u0275directiveInject(WindowRef), \u0275\u0275directiveInject(FilesFormValidators));
};
_MessagingComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MessagingComponent,
  selectors: [["cx-messaging"]],
  viewQuery: function MessagingComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(FileUploadComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.fileUploadComponent = _t.first);
    }
  },
  inputs: {
    messageEvents$: "messageEvents$",
    scrollToInput: "scrollToInput",
    messagingConfigs: "messagingConfigs"
  },
  outputs: {
    send: "send",
    downloadAttachment: "downloadAttachment"
  },
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [1, "container"], [1, "cx-avatar-line"], ["id", "cx-messages", 1, "cx-messages", 3, "keydown.arrowdown", "keydown.arrowup"], [4, "ngFor", "ngForOf"], ["class", "cx-message-footer", 3, "formGroup", 4, "ngIf"], [1, "cx-message-card", 3, "ngClass"], [3, "message"], ["role", "listitem", 3, "ngClass", "tabindex"], ["class", "cx-attachment", "target", "_blank", "rel", "noopener noreferrer", 3, "click", 4, "ngFor", "ngForOf"], ["target", "_blank", "rel", "noopener noreferrer", 1, "cx-attachment", 3, "click"], [3, "type"], [1, "cx-message-footer", 3, "formGroup"], [1, "cx-message-box"], [1, "cx-footer-label"], [1, "cx-message-input"], ["formControlName", "message", "type", "text", 1, "form-control", 3, "keydown.enter", "maxLength", "placeholder"], ["class", "cx-visually-hidden", "role", "alert", 4, "ngIf"], [1, "btn", "btn-block", "btn-primary", "cx-send", 3, "click"], ["id", "cx-message-footer", 1, "cx-message-footer-info"], [3, "formControl", "accept", 4, "ngIf"], [1, "cx-message-footer-info-text"], ["prefix", "formErrors.file", 3, "control"], ["role", "alert", 1, "cx-visually-hidden"], [3, "formControl", "accept"], [1, "cx-message-footer-text"]],
  template: function MessagingComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, MessagingComponent_ng_container_0_Template, 8, 7, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.messageEvents$));
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, IconComponent, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormControlDirective, FormGroupDirective, FormControlName, FileUploadComponent, FormErrorsComponent, AvatarComponent, AsyncPipe, TranslatePipe, CxDatePipe],
  encapsulation: 2
});
var MessagingComponent = _MessagingComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessagingComponent, [{
    type: Component,
    args: [{
      selector: "cx-messaging",
      template: `<ng-container *ngIf="messageEvents$ | async as messageEvents">
  <div class="container">
    <div class="cx-avatar-line"></div>
    <div
      class="cx-messages"
      id="cx-messages"
      (keydown.arrowdown)="focusNextChild($any($event))"
      (keydown.arrowup)="focusPreviousChild($any($event))"
      [attr.aria-label]="'chatMessaging.messages' | cxTranslate"
    >
      <ng-container *ngFor="let message of messageEvents; let i = index">
        <div
          class="cx-message-card"
          [ngClass]="{ 'cx-message-display': message?.rightAlign ?? false }"
        >
          <cx-avatar [message]="message!"> </cx-avatar>

          <div>
            <label>{{
              (message?.createdAt | cxDate: messagingConfigs?.dateFormat) ??
                dateFormat
            }}</label>
            <div
              [ngClass]="
                message?.rightAlign ?? false
                  ? 'cx-message-right-align-text'
                  : 'cx-message-left-align-text'
              "
              [tabindex]="i ? -1 : 0"
              role="listitem"
              [attr.aria-label]="
                'chatMessaging.informationLabel'
                  | cxTranslate
                    : {
                        author: message?.author!,
                        text: message?.text!,
                        date:
                          (message?.createdAt
                            | cxDate: messagingConfigs?.dateFormat) ??
                          dateFormat
                      }
              "
            >
              {{ message?.text! }}
            </div>
            <a
              *ngFor="let attachment of message?.attachments ?? []"
              class="cx-attachment"
              (click)="
                triggerDownload(
                  message?.code,
                  attachment?.id,
                  attachment?.filename
                )
              "
              target="_blank"
              rel="noopener noreferrer"
            >
              <cx-icon [type]="iconTypes.ATTACHMENT"></cx-icon>
              {{ attachment.filename }}
            </a>
          </div>
        </div>
      </ng-container>
    </div>
  </div>

  <div
    [formGroup]="form"
    class="cx-message-footer"
    *ngIf="messagingConfigs?.displayAddMessageSection | async"
  >
    <div class="cx-message-box">
      <label class="cx-footer-label">
        <span>
          {{ 'chatMessaging.addNewMessage' | cxTranslate }}
        </span>
        <div class="cx-message-input">
          <input
            formControlName="message"
            type="text"
            class="form-control"
            (keydown.enter)="onSend()"
            [maxLength]="
              messagingConfigs?.charactersLimit || MAX_INPUT_CHARACTERS
            "
            placeholder="{{
              messagingConfigs?.newMessagePlaceHolder ||
                ('chatMessaging.addMessagePlaceHolder' | cxTranslate)
            }}"
          />
          <span
            class="cx-visually-hidden"
            *ngIf="inputCharacterLeft === 0"
            role="alert"
          >
            {{ 'chatMessaging.characterLimitAlert' | cxTranslate }}
          </span>
          <button class="btn btn-block btn-primary cx-send" (click)="onSend()">
            {{ 'chatMessaging.send' | cxTranslate }}
          </button>
        </div>
      </label>
      <div class="cx-message-footer-info" id="cx-message-footer">
        <cx-file-upload
          [formControl]="$any(form.get('file'))"
          [accept]="allowedTypes"
          *ngIf="messagingConfigs?.enableFileUploadOption"
        >
          <ng-template>
            <cx-icon [type]="iconTypes.UPLOAD"></cx-icon>
            <span class="cx-message-footer-text"
              >{{ 'chatMessaging.uploadFile' | cxTranslate }}
            </span>
          </ng-template>
        </cx-file-upload>

        <p class="cx-message-footer-info-text">
          {{
            'chatMessaging.charactersLeft'
              | cxTranslate: { count: inputCharacterLeft }
          }}
        </p>
      </div>
      <cx-form-errors
        [control]="form.get('file')"
        prefix="formErrors.file"
      ></cx-form-errors>
    </div>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: WindowRef
  }, {
    type: FilesFormValidators
  }], {
    fileUploadComponent: [{
      type: ViewChild,
      args: [FileUploadComponent]
    }],
    messageEvents$: [{
      type: Input
    }],
    scrollToInput: [{
      type: Input
    }],
    messagingConfigs: [{
      type: Input
    }],
    send: [{
      type: Output
    }],
    downloadAttachment: [{
      type: Output
    }]
  });
})();
var _ChatMessagingModule = class _ChatMessagingModule {
};
_ChatMessagingModule.\u0275fac = function ChatMessagingModule_Factory(t) {
  return new (t || _ChatMessagingModule)();
};
_ChatMessagingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ChatMessagingModule
});
_ChatMessagingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule, IconModule, FormsModule, ReactiveFormsModule, FileUploadModule, FormErrorsModule]
});
var ChatMessagingModule = _ChatMessagingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatMessagingModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, IconModule, FormsModule, ReactiveFormsModule, FileUploadModule, FormErrorsModule],
      declarations: [AvatarComponent, MessagingComponent],
      exports: [AvatarComponent, MessagingComponent]
    }]
  }], null, null);
})();
var _BannerCarouselModule = class _BannerCarouselModule {
};
_BannerCarouselModule.\u0275fac = function BannerCarouselModule_Factory(t) {
  return new (t || _BannerCarouselModule)();
};
_BannerCarouselModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BannerCarouselModule
});
_BannerCarouselModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      RotatingImagesComponent: {
        component: BannerCarouselComponent
      }
    }
  })],
  imports: [CommonModule, PageComponentModule, CarouselModule, MediaModule]
});
var BannerCarouselModule = _BannerCarouselModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BannerCarouselModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PageComponentModule, CarouselModule, MediaModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          RotatingImagesComponent: {
            component: BannerCarouselComponent
          }
        }
      })],
      declarations: [BannerCarouselComponent],
      exports: [BannerCarouselComponent]
    }]
  }], null, null);
})();
var _BannerComponent = class _BannerComponent {
  constructor(component, urlService, cmsService) {
    this.component = component;
    this.urlService = urlService;
    this.cmsService = cmsService;
    this.data$ = this.component.data$.pipe(tap((data) => {
      this.setRouterLink(data);
      this.styleClasses = data.styleClasses;
    }));
  }
  /**
   * Returns `_blank` to force opening the link in a new window whenever the
   * `data.external` flag is set to true.
   */
  getTarget(data) {
    return data.external === "true" || data.external === true ? "_blank" : null;
  }
  setRouterLink(data) {
    if (data.urlLink) {
      this.routerLink = data.urlLink;
    } else if (data.contentPage) {
      this.cmsService.getPage({
        id: data.contentPage,
        type: PageType.CONTENT_PAGE
      }).pipe(take(1)).subscribe((page) => {
        this.routerLink = page?.label;
      });
    } else if (data.product) {
      this.routerLink = this.urlService.transform({
        cxRoute: "product",
        params: {
          code: data.product
        }
      });
    } else if (data.category) {
      this.routerLink = this.urlService.transform({
        cxRoute: "category",
        params: {
          code: data.category
        }
      });
    }
  }
  getImage(data) {
    if (data.media) {
      if ("url" in data.media) {
        return data.media;
      } else {
        return data.media;
      }
    }
  }
};
_BannerComponent.\u0275fac = function BannerComponent_Factory(t) {
  return new (t || _BannerComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(SemanticPathService), \u0275\u0275directiveInject(CmsService));
};
_BannerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BannerComponent,
  selectors: [["cx-banner"]],
  hostVars: 2,
  hostBindings: function BannerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.styleClasses);
    }
  },
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [3, "url", "target", 4, "ngIf"], [3, "url", "target"], ["class", "headline", 3, "innerHTML", 4, "ngIf"], [3, "container"], ["class", "content", 3, "innerHTML", 4, "ngIf"], [1, "headline", 3, "innerHTML"], [1, "content", 3, "innerHTML"], [1, "no-link"]],
  template: function BannerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, BannerComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.data$));
    }
  },
  dependencies: [NgIf, GenericLinkComponent, MediaComponent, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var BannerComponent = _BannerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BannerComponent, [{
    type: Component,
    args: [{
      selector: "cx-banner",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<ng-container *ngIf="data$ | async as data">\n  <cx-generic-link\n    *ngIf="routerLink"\n    [url]="routerLink"\n    [target]="getTarget(data)"\n  >\n    <p class="headline" *ngIf="data.headline" [innerHTML]="data.headline"></p>\n    <cx-media [container]="getImage(data)"></cx-media>\n    <p class="content" *ngIf="data.content" [innerHTML]="data.content"></p>\n  </cx-generic-link>\n  <ng-container *ngIf="!routerLink">\n    <div class="no-link">\n      <p class="headline" *ngIf="data.headline" [innerHTML]="data.headline"></p>\n      <cx-media [container]="getImage(data)"></cx-media>\n      <p class="content" *ngIf="data.content" [innerHTML]="data.content"></p>\n    </div>\n  </ng-container>\n</ng-container>\n'
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: SemanticPathService
  }, {
    type: CmsService
  }], {
    styleClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _BannerModule = class _BannerModule {
};
_BannerModule.\u0275fac = function BannerModule_Factory(t) {
  return new (t || _BannerModule)();
};
_BannerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BannerModule
});
_BannerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      SimpleResponsiveBannerComponent: {
        component: BannerComponent
      },
      BannerComponent: {
        component: BannerComponent
      },
      SimpleBannerComponent: {
        component: BannerComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule]
});
var BannerModule = _BannerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BannerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          SimpleResponsiveBannerComponent: {
            component: BannerComponent
          },
          BannerComponent: {
            component: BannerComponent
          },
          SimpleBannerComponent: {
            component: BannerComponent
          }
        }
      })],
      declarations: [BannerComponent],
      exports: [BannerComponent]
    }]
  }], null, null);
})();
var _LinkComponent = class _LinkComponent {
  constructor(component) {
    this.component = component;
    this.data$ = this.component.data$;
    this.subscriptions = new Subscription();
  }
  ngOnInit() {
    this.subscriptions.add(this.data$.subscribe((data) => {
      this.styleClasses = data?.styleClasses;
    }));
  }
  /**
   * Returns `_blank` to force opening the link in a new window whenever the
   * `data.target` flag is set to `true`.
   */
  getTarget(data) {
    return data.target === "true" || data.target === true ? "_blank" : null;
  }
  ngOnDestroy() {
    this.subscriptions?.unsubscribe();
  }
};
_LinkComponent.\u0275fac = function LinkComponent_Factory(t) {
  return new (t || _LinkComponent)(\u0275\u0275directiveInject(CmsComponentData));
};
_LinkComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LinkComponent,
  selectors: [["cx-link"]],
  hostVars: 2,
  hostBindings: function LinkComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.styleClasses);
    }
  },
  decls: 2,
  vars: 3,
  consts: [[3, "url", "style", "target", 4, "ngIf"], [3, "url", "target"]],
  template: function LinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, LinkComponent_cx_generic_link_0_Template, 2, 5, "cx-generic-link", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.data$));
    }
  },
  dependencies: [NgIf, GenericLinkComponent, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var LinkComponent = _LinkComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LinkComponent, [{
    type: Component,
    args: [{
      selector: "cx-link",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<cx-generic-link
  *ngIf="data$ | async as data"
  [url]="data.url ?? ''"
  [style]="data.styleAttributes"
  [target]="getTarget(data)"
  >{{ data.linkName }}</cx-generic-link
>
`
    }]
  }], () => [{
    type: CmsComponentData
  }], {
    styleClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _LinkModule = class _LinkModule {
};
_LinkModule.\u0275fac = function LinkModule_Factory(t) {
  return new (t || _LinkModule)();
};
_LinkModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LinkModule
});
_LinkModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      CMSLinkComponent: {
        component: LinkComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, GenericLinkModule]
});
var LinkModule = _LinkModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LinkModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, GenericLinkModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          CMSLinkComponent: {
            component: LinkComponent
          }
        }
      })],
      declarations: [LinkComponent],
      exports: [LinkComponent]
    }]
  }], null, null);
})();
var _SupplementHashAnchorsPipe = class _SupplementHashAnchorsPipe {
  constructor(renderer, winRef) {
    this.renderer = renderer;
    this.winRef = winRef;
  }
  getPath(anchorId) {
    const currentUrlWithoutFragment = this.winRef.location.href?.replace(/#.*$/, "");
    return `${currentUrlWithoutFragment}${anchorId}`;
  }
  transform(html = "") {
    const template = this.renderer.createElement("template");
    template.innerHTML = html.trim();
    const linkNodes = template.content.querySelectorAll("a");
    Array.from(linkNodes).forEach((link) => {
      const href = link.getAttribute("href");
      if (href?.indexOf("#") === 0) {
        this.renderer.setProperty(link, "href", this.getPath(href));
      }
    });
    return template.innerHTML;
  }
};
_SupplementHashAnchorsPipe.\u0275fac = function SupplementHashAnchorsPipe_Factory(t) {
  return new (t || _SupplementHashAnchorsPipe)(\u0275\u0275directiveInject(Renderer2, 16), \u0275\u0275directiveInject(WindowRef, 16));
};
_SupplementHashAnchorsPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "cxSupplementHashAnchors",
  type: _SupplementHashAnchorsPipe,
  pure: true
});
var SupplementHashAnchorsPipe = _SupplementHashAnchorsPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SupplementHashAnchorsPipe, [{
    type: Pipe,
    args: [{
      name: "cxSupplementHashAnchors"
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: WindowRef
  }], null);
})();
var _ParagraphComponent = class _ParagraphComponent {
  handleClick(event) {
    if (event.target instanceof HTMLAnchorElement) {
      const element = event.target;
      const href = element?.getAttribute("href");
      const documentHost = element.ownerDocument.URL.split("://")[1].split("/")[0];
      if (href && documentHost === element.host) {
        event.preventDefault();
        this.router.navigateByUrl(href);
      }
    }
  }
  constructor(component, router) {
    this.component = component;
    this.router = router;
    this.sanitizer = inject(DomSanitizer);
  }
  bypassSecurityTrustHtml(html = "") {
    return this.sanitizer.bypassSecurityTrustHtml(html);
  }
};
_ParagraphComponent.\u0275fac = function ParagraphComponent_Factory(t) {
  return new (t || _ParagraphComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(Router));
};
_ParagraphComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ParagraphComponent,
  selectors: [["cx-paragraph"]],
  hostBindings: function ParagraphComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function ParagraphComponent_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
  },
  decls: 2,
  vars: 3,
  consts: [[3, "innerHTML", 4, "ngIf"], [3, "innerHTML"]],
  template: function ParagraphComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ParagraphComponent_div_0_Template, 2, 3, "div", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.component.data$));
    }
  },
  dependencies: [NgIf, AsyncPipe, SupplementHashAnchorsPipe],
  encapsulation: 2,
  changeDetection: 0
});
var ParagraphComponent = _ParagraphComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ParagraphComponent, [{
    type: Component,
    args: [{
      selector: "cx-paragraph",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div\n  *ngIf="component.data$ | async as data"\n  [innerHTML]="bypassSecurityTrustHtml(data.content | cxSupplementHashAnchors)"\n></div>\n'
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: Router
  }], {
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _SupplementHashAnchorsModule = class _SupplementHashAnchorsModule {
};
_SupplementHashAnchorsModule.\u0275fac = function SupplementHashAnchorsModule_Factory(t) {
  return new (t || _SupplementHashAnchorsModule)();
};
_SupplementHashAnchorsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SupplementHashAnchorsModule
});
_SupplementHashAnchorsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var SupplementHashAnchorsModule = _SupplementHashAnchorsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SupplementHashAnchorsModule, [{
    type: NgModule,
    args: [{
      declarations: [SupplementHashAnchorsPipe],
      exports: [SupplementHashAnchorsPipe]
    }]
  }], null, null);
})();
var _CmsParagraphModule = class _CmsParagraphModule {
};
_CmsParagraphModule.\u0275fac = function CmsParagraphModule_Factory(t) {
  return new (t || _CmsParagraphModule)();
};
_CmsParagraphModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CmsParagraphModule
});
_CmsParagraphModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      CMSParagraphComponent: {
        component: ParagraphComponent
      },
      CMSTabParagraphComponent: {
        component: ParagraphComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, SupplementHashAnchorsModule]
});
var CmsParagraphModule = _CmsParagraphModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CmsParagraphModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, SupplementHashAnchorsModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          CMSParagraphComponent: {
            component: ParagraphComponent
          },
          CMSTabParagraphComponent: {
            component: ParagraphComponent
          }
        }
      })],
      declarations: [ParagraphComponent],
      exports: [ParagraphComponent]
    }]
  }], null, null);
})();
var _PDFComponent = class _PDFComponent {
  constructor(component, mediaService) {
    this.component = component;
    this.mediaService = mediaService;
    this.data$ = this.component.data$.pipe(tap((data) => {
      if (data?.pdfFile?.url) {
        this.url = this.mediaService.getMedia(data.pdfFile)?.src;
      }
    }));
  }
  addPdfExtension(title) {
    if (!title) {
      return "";
    }
    const trimTitle = title.trim();
    return trimTitle.endsWith(".pdf") ? trimTitle : `${trimTitle}.pdf`;
  }
};
_PDFComponent.\u0275fac = function PDFComponent_Factory(t) {
  return new (t || _PDFComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(MediaService));
};
_PDFComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PDFComponent,
  selectors: [["cx-pdf"]],
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [1, "pdf-container"], ["target", "_blank", "rel", "noopener noreferrer", 3, "href"], ["aria-hidden", "true"], [3, "type"]],
  template: function PDFComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, PDFComponent_ng_container_0_Template, 8, 5, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.data$));
    }
  },
  dependencies: [NgIf, IconComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var PDFComponent = _PDFComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFComponent, [{
    type: Component,
    args: [{
      selector: "cx-pdf",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="data$ | async as data">
  <div class="pdf-container">
    <a [href]="url" target="_blank" rel="noopener noreferrer">
      <span>{{
        addPdfExtension(
          data?.title ||
            data?.pdfFile?.altText ||
            ('pdf.defaultTitle' | cxTranslate)
        )
      }}</span>
      <span aria-hidden="true">
        <cx-icon [type]="'PDF_FILE'"></cx-icon>
      </span>
    </a>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: MediaService
  }], null);
})();
var _PDFModule = class _PDFModule {
};
_PDFModule.\u0275fac = function PDFModule_Factory(t) {
  return new (t || _PDFModule)();
};
_PDFModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PDFModule
});
_PDFModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      PDFDocumentComponent: {
        component: PDFComponent
      }
    }
  })],
  imports: [CommonModule, IconModule, I18nModule]
});
var PDFModule = _PDFModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, IconModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          PDFDocumentComponent: {
            component: PDFComponent
          }
        }
      })],
      declarations: [PDFComponent],
      exports: [PDFComponent]
    }]
  }], null, null);
})();
var _TabParagraphContainerComponent = class _TabParagraphContainerComponent {
  constructor(componentData, cmsService, winRef) {
    this.componentData = componentData;
    this.cmsService = cmsService;
    this.winRef = winRef;
    this.activeTabNum = 0;
    this.tabTitleParams = [];
    this.components$ = this.componentData.data$.pipe(distinctUntilChanged((x, y) => x?.components === y?.components), tap((data) => {
      this.ariaLabel = `${data?.uid}.tabPanelContainerRegion`;
    }), switchMap((data) => combineLatest((data?.components ?? "").split(" ").map((component) => this.cmsService.getComponentData(component).pipe(distinctUntilChanged(), map((tab) => {
      if (!tab) {
        return void 0;
      }
      if (!tab.flexType) {
        tab = __spreadProps(__spreadValues({}, tab), {
          flexType: tab.typeCode
        });
      }
      return __spreadProps(__spreadValues({}, tab), {
        title: `${data.uid}.tabs.${tab.uid}`
      });
    }))))));
  }
  select(tabNum, event) {
    this.activeTabNum = this.activeTabNum === tabNum ? -1 : tabNum;
    if (event && event?.target) {
      const target = event.target;
      const parentNode = target.parentNode;
      this.winRef?.nativeWindow?.scrollTo({
        left: 0,
        top: parentNode.offsetTop,
        behavior: "smooth"
      });
    }
  }
  ngOnInit() {
    this.activeTabNum = this.winRef?.nativeWindow?.history?.state?.activeTab ?? this.activeTabNum;
  }
  ngAfterViewInit() {
    if (this.children.length > 0) {
      this.getTitleParams(this.children);
    }
  }
  tabCompLoaded(componentRef) {
    this.tabTitleParams.push(componentRef.instance.tabTitleParam$);
  }
  getTitleParams(children) {
    children.forEach((comp) => {
      this.tabTitleParams.push(comp["cmpRef"]?.instance.tabTitleParam$ ?? null);
    });
  }
};
_TabParagraphContainerComponent.\u0275fac = function TabParagraphContainerComponent_Factory(t) {
  return new (t || _TabParagraphContainerComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(CmsService), \u0275\u0275directiveInject(WindowRef));
};
_TabParagraphContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TabParagraphContainerComponent,
  selectors: [["cx-tab-paragraph-container"]],
  viewQuery: function TabParagraphContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(ComponentWrapperDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.children = _t);
    }
  },
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], ["role", "region", "tabindex", "-1", 1, "container"], [4, "ngFor", "ngForOf"], [3, "click"], ["aria-hidden", "true", 1, "accordion-icon"], ["tabindex", "0", "role", "presentation", 1, "cx-tab-paragraph-content"], [3, "cxOutlet", "cxOutletContext"], [3, "cxComponentRef", "cxComponentWrapper"]],
  template: function TabParagraphContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, TabParagraphContainerComponent_ng_container_0_Template, 4, 4, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.components$));
    }
  },
  dependencies: [NgForOf, NgIf, ComponentWrapperDirective, OutletDirective, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var TabParagraphContainerComponent = _TabParagraphContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabParagraphContainerComponent, [{
    type: Component,
    args: [{
      selector: "cx-tab-paragraph-container",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<ng-container *ngIf="components$ | async as components">\n  <div\n    role="region"\n    tabindex="-1"\n    [attr.aria-label]="ariaLabel | cxTranslate"\n    class="container"\n  >\n    <ng-container *ngFor="let component of components; let i = index">\n      <ng-container *ngIf="component">\n        <button\n          [class.active]="i === activeTabNum"\n          (click)="select(i, $event)"\n          [attr.aria-expanded]="i === activeTabNum"\n        >\n          {{\n            component.title | cxTranslate: { param: tabTitleParams[i] | async }\n          }}\n\n          <span class="accordion-icon" aria-hidden="true"></span>\n        </button>\n\n        <div\n          [class.active]="i === activeTabNum"\n          class="cx-tab-paragraph-content"\n          tabindex="0"\n          role="presentation"\n        >\n          <ng-template [cxOutlet]="component.flexType" [cxOutletContext]="{}">\n            <ng-container\n              [cxComponentWrapper]="component"\n              (cxComponentRef)="tabCompLoaded($event)"\n            ></ng-container>\n          </ng-template>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n</ng-container>\n'
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: CmsService
  }, {
    type: WindowRef
  }], {
    children: [{
      type: ViewChildren,
      args: [ComponentWrapperDirective]
    }]
  });
})();
var _TabParagraphContainerModule = class _TabParagraphContainerModule {
};
_TabParagraphContainerModule.\u0275fac = function TabParagraphContainerModule_Factory(t) {
  return new (t || _TabParagraphContainerModule)();
};
_TabParagraphContainerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TabParagraphContainerModule
});
_TabParagraphContainerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      CMSTabParagraphContainer: {
        component: TabParagraphContainerComponent
      }
    }
  })],
  imports: [CommonModule, PageComponentModule, OutletModule, I18nModule]
});
var TabParagraphContainerModule = _TabParagraphContainerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabParagraphContainerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PageComponentModule, OutletModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          CMSTabParagraphContainer: {
            component: TabParagraphContainerComponent
          }
        }
      })],
      declarations: [TabParagraphContainerComponent],
      exports: [TabParagraphContainerComponent]
    }]
  }], null, null);
})();
var _VideoComponent = class _VideoComponent {
  constructor(component, mediaService, urlService, cmsService, cd) {
    this.component = component;
    this.mediaService = mediaService;
    this.urlService = urlService;
    this.cmsService = cmsService;
    this.cd = cd;
    this.data$ = this.component.data$.pipe(distinctUntilChanged(), tap((data) => {
      this.styleClasses = data.styleClasses;
      this.setMedia(data);
      this.setControls(data);
      this.setRouting(data);
    }));
  }
  setMedia(data) {
    if (data.video) {
      this.source = this.mediaService.getMedia(data.video)?.src;
    }
    if (data?.containerBackground === ContainerBackgroundOptions.UPLOAD_RESPONSIVE_IMAGE && data?.videoMedia) {
      this.thumbnail = this.mediaService.getMedia(data.videoMedia);
    } else if (data?.thumbnailSelector === ContainerBackgroundOptions.UPLOAD_THUMBNAIL && data?.thumbnail) {
      this.thumbnail = this.mediaService.getMedia(data.thumbnail);
    } else {
      this.thumbnail = void 0;
    }
  }
  setControls(data) {
    this.autoPlay = data.autoPlay === "true";
    this.loop = data.loop === "true";
    this.mute = data.mute === "true" ? "muted" : void 0;
  }
  setRouting(data) {
    if (data.url) {
      this.routerLink = data.url;
    } else if (data.contentPage) {
      this.cmsService.getPage({
        id: data.contentPage,
        type: PageType.CONTENT_PAGE
      }).pipe(take(1)).subscribe((page) => {
        this.routerLink = page?.label;
        this.cd.markForCheck();
      });
    } else if (data.product) {
      this.routerLink = this.urlService.transform({
        cxRoute: "product",
        params: {
          code: data.product
        }
      });
    } else if (data.category) {
      this.routerLink = this.urlService.transform({
        cxRoute: "category",
        params: {
          code: data.category
        }
      });
    }
  }
};
_VideoComponent.\u0275fac = function VideoComponent_Factory(t) {
  return new (t || _VideoComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(MediaService), \u0275\u0275directiveInject(SemanticPathService), \u0275\u0275directiveInject(CmsService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_VideoComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _VideoComponent,
  selectors: [["cx-video"]],
  hostVars: 2,
  hostBindings: function VideoComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.styleClasses);
    }
  },
  decls: 4,
  vars: 4,
  consts: [["loading", ""], ["class", "video-container", "tabindex", "-1", 4, "ngIf", "ngIfElse"], ["tabindex", "-1", 1, "video-container"], [3, "routerLink", 4, "ngIf"], ["controls", "", 3, "height", "poster", "loop", "autoplay", "muted", "src", 4, "ngIf"], [3, "routerLink"], ["controls", "", 3, "poster", "loop", "autoplay", "muted", "src"], [1, "cx-spinner"]],
  template: function VideoComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, VideoComponent_div_0_Template, 3, 2, "div", 1);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, VideoComponent_ng_template_2_Template, 2, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const loading_r3 = \u0275\u0275reference(3);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 2, ctx.data$))("ngIfElse", loading_r3);
    }
  },
  dependencies: [NgIf, RouterLink, SpinnerComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var VideoComponent = _VideoComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VideoComponent, [{
    type: Component,
    args: [{
      selector: "cx-video",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div
  *ngIf="data$ | async as data; else loading"
  class="video-container"
  tabindex="-1"
>
  <a *ngIf="data.overlayTitle" [routerLink]="routerLink">{{
    data.overlayTitle
  }}</a>
  <video
    *ngIf="source"
    [style.height.px]="data.videoContainerHeight"
    controls
    [poster]="thumbnail?.src"
    [loop]="loop"
    [autoplay]="autoPlay"
    [muted]="mute"
    [attr.aria-label]="'player.label' | cxTranslate"
    [src]="source"
  ></video>
</div>

<ng-template #loading>
  <div class="cx-spinner"><cx-spinner></cx-spinner></div>
</ng-template>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: MediaService
  }, {
    type: SemanticPathService
  }, {
    type: CmsService
  }, {
    type: ChangeDetectorRef
  }], {
    styleClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _VideoModule = class _VideoModule {
};
_VideoModule.\u0275fac = function VideoModule_Factory(t) {
  return new (t || _VideoModule)();
};
_VideoModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _VideoModule
});
_VideoModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      VideoComponent: {
        component: VideoComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule, I18nModule, SpinnerModule]
});
var VideoModule = _VideoModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VideoModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule, I18nModule, SpinnerModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          VideoComponent: {
            component: VideoComponent
          }
        }
      })],
      declarations: [VideoComponent],
      exports: [VideoComponent]
    }]
  }], null, null);
})();
var _MyCouponsComponentService = class _MyCouponsComponentService {
  constructor(routingService, translation) {
    this.routingService = routingService;
    this.translation = translation;
    this.RELEVANCE = ":relevance";
    this.CUSTOMER_COUPON_CODE = ":customerCouponCode:";
  }
  launchSearchPage(coupon) {
    this.routingService.go({
      cxRoute: "search",
      params: {
        query: this.buildSearchParam(coupon)
      }
    }, {
      queryParams: {
        couponcode: coupon.couponId
      }
    });
  }
  buildSearchParam(coupon) {
    return coupon.allProductsApplicable ? this.RELEVANCE : this.RELEVANCE + this.CUSTOMER_COUPON_CODE + coupon.couponId;
  }
  getSortLabels() {
    return combineLatest([this.translation.translate("myCoupons.startDateAsc"), this.translation.translate("myCoupons.startDateDesc"), this.translation.translate("myCoupons.endDateAsc"), this.translation.translate("myCoupons.endDateDesc")]).pipe(map(([textByStartDateAsc, textByStartDateDesc, textByEndDateAsc, textByEndDateDesc]) => {
      return {
        byStartDateAsc: textByStartDateAsc,
        byStartDateDesc: textByStartDateDesc,
        byEndDateAsc: textByEndDateAsc,
        byEndDateDesc: textByEndDateDesc
      };
    }));
  }
};
_MyCouponsComponentService.\u0275fac = function MyCouponsComponentService_Factory(t) {
  return new (t || _MyCouponsComponentService)(\u0275\u0275inject(RoutingService), \u0275\u0275inject(TranslationService));
};
_MyCouponsComponentService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _MyCouponsComponentService,
  factory: _MyCouponsComponentService.\u0275fac,
  providedIn: "root"
});
var MyCouponsComponentService = _MyCouponsComponentService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyCouponsComponentService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RoutingService
  }, {
    type: TranslationService
  }], null);
})();
var _SkipLinkConfig = class _SkipLinkConfig {
};
_SkipLinkConfig.\u0275fac = function SkipLinkConfig_Factory(t) {
  return new (t || _SkipLinkConfig)();
};
_SkipLinkConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SkipLinkConfig,
  factory: function SkipLinkConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _SkipLinkConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var SkipLinkConfig = _SkipLinkConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkipLinkConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var SkipLinkScrollPosition;
(function(SkipLinkScrollPosition2) {
  SkipLinkScrollPosition2["BEFORE"] = "BEFORE";
  SkipLinkScrollPosition2["AFTER"] = "AFTER";
})(SkipLinkScrollPosition || (SkipLinkScrollPosition = {}));
var _SkipLinkService = class _SkipLinkService {
  constructor(config, keyboardFocusService) {
    this.config = config;
    this.keyboardFocusService = keyboardFocusService;
    this.skipLinks$ = new BehaviorSubject([]);
  }
  getSkipLinks() {
    return this.skipLinks$;
  }
  add(key, target) {
    const found = this.config.skipLinks?.find((skipLink) => skipLink.key === key);
    if (found) {
      const existing = this.skipLinks$.value;
      existing.splice(this.getSkipLinkIndexInArray(key), 0, {
        target,
        i18nKey: found.i18nKey,
        position: found.position,
        key
      });
      this.skipLinks$.next(existing);
    }
  }
  remove(key) {
    const found = this.config.skipLinks?.find((skipLink) => skipLink.key === key);
    if (found) {
      let existing = this.skipLinks$.value;
      existing = existing.filter((skipLink) => skipLink.key !== key);
      this.skipLinks$.next(existing);
    }
  }
  scrollToTarget(skipLink) {
    const target = skipLink.target instanceof HTMLElement ? skipLink.target : skipLink.target?.parentElement;
    const firstFocusable = this.keyboardFocusService.findFirstFocusable(target) || target;
    const hasTabindex = firstFocusable?.hasAttribute("tabindex");
    if (!hasTabindex) {
      firstFocusable?.setAttribute("tabindex", "-1");
    }
    firstFocusable?.focus();
    if (!hasTabindex) {
      firstFocusable?.removeAttribute("tabindex");
    }
  }
  getSkipLinkIndexInArray(key) {
    let index = this.config.skipLinks?.findIndex((skipLink) => skipLink.key === key) ?? 0;
    while (index > 0) {
      index--;
      const previous = this.config.skipLinks?.[index];
      if (previous) {
        const existing = this.skipLinks$.value;
        const found = existing.findIndex((skipLink) => skipLink.key === previous.key);
        if (found > -1) {
          return found + 1;
        }
      }
    }
    return 0;
  }
};
_SkipLinkService.\u0275fac = function SkipLinkService_Factory(t) {
  return new (t || _SkipLinkService)(\u0275\u0275inject(SkipLinkConfig), \u0275\u0275inject(KeyboardFocusService));
};
_SkipLinkService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SkipLinkService,
  factory: _SkipLinkService.\u0275fac,
  providedIn: "root"
});
var SkipLinkService = _SkipLinkService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkipLinkService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: SkipLinkConfig
  }, {
    type: KeyboardFocusService
  }], null);
})();
var _SkipLinkComponent = class _SkipLinkComponent {
  constructor(skipLinkService) {
    this.skipLinkService = skipLinkService;
    this.skipLinks$ = this.skipLinkService.getSkipLinks();
  }
  scrollToTarget(skipLink) {
    this.skipLinkService.scrollToTarget(skipLink);
  }
};
_SkipLinkComponent.\u0275fac = function SkipLinkComponent_Factory(t) {
  return new (t || _SkipLinkComponent)(\u0275\u0275directiveInject(SkipLinkService));
};
_SkipLinkComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SkipLinkComponent,
  selectors: [["cx-skip-link"]],
  decls: 2,
  vars: 3,
  consts: [[3, "cxFocus", 4, "ngIf"], [3, "cxFocus"], [3, "click", 4, "ngFor", "ngForOf"], [3, "click"]],
  template: function SkipLinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, SkipLinkComponent_div_0_Template, 2, 3, "div", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.skipLinks$));
    }
  },
  dependencies: [NgForOf, NgIf, FocusDirective, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var SkipLinkComponent = _SkipLinkComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkipLinkComponent, [{
    type: Component,
    args: [{
      selector: "cx-skip-link",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div [cxFocus]="{ tab: true }" *ngIf="skipLinks$ | async as links">
  <button *ngFor="let link of links" (click)="scrollToTarget(link)">
    {{ 'skipLink.skipTo' | cxTranslate }}
    {{ link.i18nKey | cxTranslate }}
  </button>
</div>
`
    }]
  }], () => [{
    type: SkipLinkService
  }], null);
})();
var defaultSkipLinkConfig = {
  skipLinks: [{
    key: "cx-header",
    i18nKey: "skipLink.labels.header"
  }, {
    key: "cx-main",
    i18nKey: "skipLink.labels.main"
  }, {
    key: "cx-footer",
    i18nKey: "skipLink.labels.footer"
  }]
};
var _SkipLinkDirective = class _SkipLinkDirective {
  constructor(elementRef, skipLinkService) {
    this.elementRef = elementRef;
    this.skipLinkService = skipLinkService;
  }
  ngOnInit() {
    this.skipLinkService.add(this.cxSkipLink, this.elementRef.nativeElement);
  }
  ngOnDestroy() {
    this.skipLinkService.remove(this.cxSkipLink);
  }
};
_SkipLinkDirective.\u0275fac = function SkipLinkDirective_Factory(t) {
  return new (t || _SkipLinkDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(SkipLinkService));
};
_SkipLinkDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SkipLinkDirective,
  selectors: [["", "cxSkipLink", ""]],
  inputs: {
    cxSkipLink: "cxSkipLink"
  }
});
var SkipLinkDirective = _SkipLinkDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkipLinkDirective, [{
    type: Directive,
    args: [{
      selector: "[cxSkipLink]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: SkipLinkService
  }], {
    cxSkipLink: [{
      type: Input
    }]
  });
})();
var _SkipLinkModule = class _SkipLinkModule {
};
_SkipLinkModule.\u0275fac = function SkipLinkModule_Factory(t) {
  return new (t || _SkipLinkModule)();
};
_SkipLinkModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SkipLinkModule
});
_SkipLinkModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultSkipLinkConfig), {
    provide: APP_INITIALIZER,
    useFactory: skipLinkFactory,
    deps: [ComponentFactoryResolver$1, OutletService],
    multi: true
  }],
  imports: [CommonModule, I18nModule, ConfigModule.withConfig(defaultSkipLinkConfig), KeyboardFocusModule]
});
var SkipLinkModule = _SkipLinkModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkipLinkModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, ConfigModule.withConfig(defaultSkipLinkConfig), KeyboardFocusModule],
      declarations: [SkipLinkComponent, SkipLinkDirective],
      exports: [SkipLinkDirective],
      providers: [provideDefaultConfig(defaultSkipLinkConfig), {
        provide: APP_INITIALIZER,
        useFactory: skipLinkFactory,
        deps: [ComponentFactoryResolver$1, OutletService],
        multi: true
      }]
    }]
  }], null, null);
})();
function skipLinkFactory(componentFactoryResolver, outletService) {
  const isReady = () => {
    const factory = componentFactoryResolver.resolveComponentFactory(SkipLinkComponent);
    outletService.add("cx-storefront", factory, OutletPosition.BEFORE);
  };
  return isReady;
}
var defaultLayoutConfig = {
  breakpoints: {
    xs: 576,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: {
      min: 1200
    }
  }
};
var _DirectionConfig = class _DirectionConfig {
};
_DirectionConfig.\u0275fac = function DirectionConfig_Factory(t) {
  return new (t || _DirectionConfig)();
};
_DirectionConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DirectionConfig,
  factory: function DirectionConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _DirectionConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var DirectionConfig = _DirectionConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DirectionConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var defaultDirectionConfig = {
  direction: {
    detect: true,
    default: DirectionMode.LTR,
    // we're not polluting the system with all defaults for ltr, but add 2 common used
    // languages (hebrew and arabic) to easily demo directionality
    // see https://meta.wikimedia.org/wiki/Template:List_of_language_names_ordered_by_code
    rtlLanguages: ["he", "ar"]
  }
};
var _DirectionService = class _DirectionService {
  constructor(configInit, languageService, winRef) {
    this.configInit = configInit;
    this.languageService = languageService;
    this.winRef = winRef;
    this.startsDetecting = false;
    this.subscription = new Subscription();
  }
  /**
   * Initializes the layout direction for the storefront.
   */
  initialize() {
    return lastValueFrom(this.configInit.getStable("direction").pipe(tap((config) => {
      this.config = config?.direction;
      if (this.config?.detect) {
        this.detect();
      } else {
        this.setDirection(this.winRef.document.documentElement, this.config?.default);
      }
    })));
  }
  /**
   * Observes the _active_ language and set the required direction for the given language.
   * The method is guarded to ensure that the active language is observed only once.
   */
  detect() {
    if (this.startsDetecting) {
      return;
    }
    this.subscription.add(this.languageService.getActive().subscribe((isoCode) => this.setDirection(this.winRef.document.documentElement, this.getDirection(isoCode))));
    this.startsDetecting = true;
  }
  /**
   * Sets the direction attribute for the given element. If the direction is undefined, the `dir`
   * attribute is removed.
   */
  setDirection(el, direction) {
    if (direction) {
      el.setAttribute("dir", direction);
    } else {
      el.removeAttribute("dir");
    }
  }
  /**
   * Gets the `DirectionMode` for the given language isoCode. The language isoCode is compared
   * to the configured list of languages(`direction.rtlLanguages` vs `direction.ltrLanguages`).
   *
   * If no language is given, or no language mapping could be found, we fallback to the default
   * `direction.mode`.
   */
  getDirection(language) {
    if (language && this.config?.rtlLanguages?.includes(language)) {
      return DirectionMode.RTL;
    }
    if (language && this.config?.ltrLanguages?.includes(language)) {
      return DirectionMode.LTR;
    }
    return this.config?.default;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_DirectionService.\u0275fac = function DirectionService_Factory(t) {
  return new (t || _DirectionService)(\u0275\u0275inject(ConfigInitializerService), \u0275\u0275inject(LanguageService), \u0275\u0275inject(WindowRef));
};
_DirectionService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DirectionService,
  factory: _DirectionService.\u0275fac,
  providedIn: "root"
});
var DirectionService = _DirectionService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DirectionService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ConfigInitializerService
  }, {
    type: LanguageService
  }, {
    type: WindowRef
  }], null);
})();
function initHtmlDirAttribute(directionService) {
  const result = () => {
    return directionService.initialize();
  };
  return result;
}
var _DirectionModule = class _DirectionModule {
};
_DirectionModule.\u0275fac = function DirectionModule_Factory(t) {
  return new (t || _DirectionModule)();
};
_DirectionModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _DirectionModule
});
_DirectionModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: APP_INITIALIZER,
    multi: true,
    useFactory: initHtmlDirAttribute,
    deps: [DirectionService]
  }, provideDefaultConfig(defaultDirectionConfig)]
});
var DirectionModule = _DirectionModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DirectionModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: APP_INITIALIZER,
        multi: true,
        useFactory: initHtmlDirAttribute,
        deps: [DirectionService]
      }, provideDefaultConfig(defaultDirectionConfig)]
    }]
  }], null, null);
})();
var _HamburgerMenuService = class _HamburgerMenuService {
  constructor(router) {
    this.isExpanded = new BehaviorSubject(false);
    router.events.pipe(filter((event) => event instanceof NavigationStart)).subscribe(() => {
      this.toggle(true);
    });
  }
  /**
   * toggles the expand state of the hamburger menu
   */
  toggle(forceCollapse) {
    if (forceCollapse) {
      this.isExpanded.next(false);
    } else {
      this.isExpanded.next(!this.isExpanded.value);
    }
  }
};
_HamburgerMenuService.\u0275fac = function HamburgerMenuService_Factory(t) {
  return new (t || _HamburgerMenuService)(\u0275\u0275inject(Router));
};
_HamburgerMenuService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HamburgerMenuService,
  factory: _HamburgerMenuService.\u0275fac,
  providedIn: "root"
});
var HamburgerMenuService = _HamburgerMenuService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HamburgerMenuService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Router
  }], null);
})();
var _HamburgerMenuComponent = class _HamburgerMenuComponent {
  constructor(hamburgerMenuService) {
    this.hamburgerMenuService = hamburgerMenuService;
  }
  toggle() {
    this.hamburgerMenuService.toggle();
  }
  get isExpanded() {
    return this.hamburgerMenuService.isExpanded;
  }
};
_HamburgerMenuComponent.\u0275fac = function HamburgerMenuComponent_Factory(t) {
  return new (t || _HamburgerMenuComponent)(\u0275\u0275directiveInject(HamburgerMenuService));
};
_HamburgerMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _HamburgerMenuComponent,
  selectors: [["cx-hamburger-menu"]],
  decls: 6,
  vars: 10,
  consts: [["type", "button", "aria-controls", "cx-header", 1, "cx-hamburger", 3, "click"], [1, "hamburger-box"], [1, "hamburger-inner"]],
  template: function HamburgerMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275pipe(2, "async");
      \u0275\u0275pipe(3, "cxTranslate");
      \u0275\u0275listener("click", function HamburgerMenuComponent_Template_button_click_0_listener() {
        return ctx.toggle();
      });
      \u0275\u0275elementStart(4, "span", 1);
      \u0275\u0275element(5, "span", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275classProp("is-active", \u0275\u0275pipeBind1(1, 4, ctx.isExpanded));
      \u0275\u0275attribute("aria-expanded", \u0275\u0275pipeBind1(2, 6, ctx.isExpanded))("aria-label", \u0275\u0275pipeBind1(3, 8, "common.menu"));
    }
  },
  dependencies: [AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var HamburgerMenuComponent = _HamburgerMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HamburgerMenuComponent, [{
    type: Component,
    args: [{
      selector: "cx-hamburger-menu",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<button
  class="cx-hamburger"
  type="button"
  (click)="toggle()"
  [class.is-active]="isExpanded | async"
  [attr.aria-expanded]="isExpanded | async"
  [attr.aria-label]="'common.menu' | cxTranslate"
  aria-controls="cx-header"
>
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
`
    }]
  }], () => [{
    type: HamburgerMenuService
  }], null);
})();
var _HamburgerMenuModule = class _HamburgerMenuModule {
};
_HamburgerMenuModule.\u0275fac = function HamburgerMenuModule_Factory(t) {
  return new (t || _HamburgerMenuModule)();
};
_HamburgerMenuModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _HamburgerMenuModule
});
_HamburgerMenuModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      HamburgerMenuComponent: {
        component: HamburgerMenuComponent
      }
    }
  })],
  imports: [CommonModule, I18nModule]
});
var HamburgerMenuModule = _HamburgerMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HamburgerMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          HamburgerMenuComponent: {
            component: HamburgerMenuComponent
          }
        }
      })],
      declarations: [HamburgerMenuComponent],
      exports: [HamburgerMenuComponent]
    }]
  }], null, null);
})();
var _ThemeService = class _ThemeService {
  constructor(config, rendererFactory) {
    this.config = config;
    this.rendererFactory = rendererFactory;
  }
  /**
   * This function is to be called for the root component that is
   * bootstrapped.
   */
  init(rootComponent) {
    this.renderer = this.rendererFactory.createRenderer(null, null);
    this.rootComponent = rootComponent;
    this.setTheme(this.config.context?.[THEME_CONTEXT_ID]?.[0]);
  }
  setTheme(theme) {
    if (theme) {
      const element = this.rootComponent.location.nativeElement;
      this.renderer.removeClass(element, this.existingTheme);
      this.renderer.addClass(element, theme);
      this.existingTheme = theme;
    }
  }
};
_ThemeService.\u0275fac = function ThemeService_Factory(t) {
  return new (t || _ThemeService)(\u0275\u0275inject(SiteContextConfig), \u0275\u0275inject(RendererFactory2));
};
_ThemeService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ThemeService,
  factory: _ThemeService.\u0275fac,
  providedIn: "root"
});
var ThemeService = _ThemeService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemeService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: SiteContextConfig
  }, {
    type: RendererFactory2
  }], null);
})();
function initTheme(themeService) {
  const result = (component) => themeService.init(component);
  return result;
}
var _ThemeModule = class _ThemeModule {
};
_ThemeModule.\u0275fac = function ThemeModule_Factory(t) {
  return new (t || _ThemeModule)();
};
_ThemeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ThemeModule
});
_ThemeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: initTheme,
    deps: [ThemeService]
  }]
});
var ThemeModule = _ThemeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemeModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: APP_BOOTSTRAP_LISTENER,
        multi: true,
        useFactory: initTheme,
        deps: [ThemeService]
      }]
    }]
  }], null, null);
})();
var _LayoutModule = class _LayoutModule {
};
_LayoutModule.\u0275fac = function LayoutModule_Factory(t) {
  return new (t || _LayoutModule)();
};
_LayoutModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LayoutModule
});
_LayoutModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultLayoutConfig)],
  imports: [OutletRefModule, LaunchDialogModule.forRoot(), DirectionModule, ThemeModule, OutletRefModule]
});
var LayoutModule = _LayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{
      imports: [OutletRefModule, LaunchDialogModule.forRoot(), DirectionModule, ThemeModule],
      providers: [provideDefaultConfig(defaultLayoutConfig)],
      exports: [OutletRefModule]
    }]
  }], null, null);
})();
var StorefrontOutlets;
(function(StorefrontOutlets2) {
  StorefrontOutlets2["STOREFRONT"] = "cx-storefront";
})(StorefrontOutlets || (StorefrontOutlets = {}));
var _StorefrontComponent = class _StorefrontComponent {
  handleEscape(event) {
    this.keyboardFocusService.handleEscape(this.elementRef.nativeElement, this.keyboardFocusConfig, event);
  }
  constructor(hamburgerMenuService, routingService, elementRef, keyboardFocusService) {
    this.hamburgerMenuService = hamburgerMenuService;
    this.routingService = routingService;
    this.elementRef = elementRef;
    this.keyboardFocusService = keyboardFocusService;
    this.isExpanded$ = this.hamburgerMenuService.isExpanded;
    this.StorefrontOutlets = StorefrontOutlets;
    this.role = "presentation";
    this.tabindex = "0";
    this.keyboardFocusConfig = {
      focusOnEscape: true,
      focusOnDoubleEscape: true
    };
  }
  ngOnInit() {
    this.navigateSubscription = this.routingService.isNavigating().subscribe((val) => {
      this.startNavigating = val === true;
      this.stopNavigating = val === false;
    });
  }
  collapseMenuIfClickOutside(event) {
    const element = event.target;
    if (element.nodeName.toLowerCase() === "header" && element.className.includes("is-expanded")) {
      this.collapseMenu();
    }
  }
  collapseMenu() {
    this.hamburgerMenuService.toggle(true);
  }
  ngOnDestroy() {
    if (this.navigateSubscription) {
      this.navigateSubscription.unsubscribe();
    }
  }
};
_StorefrontComponent.\u0275fac = function StorefrontComponent_Factory(t) {
  return new (t || _StorefrontComponent)(\u0275\u0275directiveInject(HamburgerMenuService), \u0275\u0275directiveInject(RoutingService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyboardFocusService));
};
_StorefrontComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _StorefrontComponent,
  selectors: [["cx-storefront"]],
  viewQuery: function StorefrontComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(SkipLinkComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.child = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function StorefrontComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown.escape", function StorefrontComponent_keydown_escape_HostBindingHandler($event) {
        return ctx.handleEscape($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275hostProperty("tabindex", ctx.tabindex);
      \u0275\u0275attribute("role", ctx.role);
      \u0275\u0275classProp("start-navigating", ctx.startNavigating)("stop-navigating", ctx.stopNavigating);
    }
  },
  decls: 1,
  vars: 1,
  consts: [["cxPageTemplateStyle", "", 3, "cxOutlet"], ["cxOutlet", "cx-header"], ["cxSkipLink", "cx-main", 3, "cxFocus"], ["cxOutlet", "cx-footer"], ["id", "cx-header", "cxSkipLink", "cx-header", 3, "keydown.escape", "click", "cxFocus"], ["section", "header"], ["section", "navigation"], ["position", "BottomHeaderSlot"], ["aria-atomic", "true", "aria-live", "assertive"], ["cxSkipLink", "cx-footer", 3, "cxFocus"], ["section", "footer"]],
  template: function StorefrontComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, StorefrontComponent_ng_template_0_Template, 4, 2, "ng-template", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("cxOutlet", ctx.StorefrontOutlets.STOREFRONT);
    }
  },
  dependencies: [RouterOutlet, GlobalMessageComponent, OutletDirective, PageLayoutComponent, PageTemplateDirective, PageSlotComponent, FocusDirective, SkipLinkDirective, AsyncPipe],
  encapsulation: 2
});
var StorefrontComponent = _StorefrontComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StorefrontComponent, [{
    type: Component,
    args: [{
      selector: "cx-storefront",
      template: '<ng-template [cxOutlet]="StorefrontOutlets.STOREFRONT" cxPageTemplateStyle>\n  <ng-template cxOutlet="cx-header">\n    <header\n      id="cx-header"\n      cxSkipLink="cx-header"\n      [cxFocus]="{ disableMouseFocus: true }"\n      [class.is-expanded]="isExpanded$ | async"\n      (keydown.escape)="collapseMenu()"\n      (click)="collapseMenuIfClickOutside($event)"\n    >\n      <cx-page-layout section="header"></cx-page-layout>\n      <cx-page-layout section="navigation"></cx-page-layout>\n    </header>\n    <cx-page-slot position="BottomHeaderSlot"></cx-page-slot>\n    <cx-global-message\n      aria-atomic="true"\n      aria-live="assertive"\n    ></cx-global-message>\n  </ng-template>\n\n  <main cxSkipLink="cx-main" [cxFocus]="{ disableMouseFocus: true }">\n    <router-outlet></router-outlet>\n  </main>\n\n  <ng-template cxOutlet="cx-footer">\n    <footer cxSkipLink="cx-footer" [cxFocus]="{ disableMouseFocus: true }">\n      <cx-page-layout section="footer"></cx-page-layout>\n    </footer>\n  </ng-template>\n</ng-template>\n'
    }]
  }], () => [{
    type: HamburgerMenuService
  }, {
    type: RoutingService
  }, {
    type: ElementRef
  }, {
    type: KeyboardFocusService
  }], {
    startNavigating: [{
      type: HostBinding,
      args: ["class.start-navigating"]
    }],
    stopNavigating: [{
      type: HostBinding,
      args: ["class.stop-navigating"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["tabindex"]
    }],
    child: [{
      type: ViewChild,
      args: [SkipLinkComponent]
    }],
    handleEscape: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }]
  });
})();
var _StorefrontComponentModule = class _StorefrontComponentModule {
};
_StorefrontComponentModule.\u0275fac = function StorefrontComponentModule_Factory(t) {
  return new (t || _StorefrontComponentModule)();
};
_StorefrontComponentModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _StorefrontComponentModule
});
_StorefrontComponentModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule, GlobalMessageComponentModule, OutletModule, OutletRefModule, PageLayoutModule, PageSlotModule, KeyboardFocusModule, SkipLinkModule]
});
var StorefrontComponentModule = _StorefrontComponentModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StorefrontComponentModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, GlobalMessageComponentModule, OutletModule, OutletRefModule, PageLayoutModule, PageSlotModule, KeyboardFocusModule, SkipLinkModule],
      declarations: [StorefrontComponent],
      exports: [StorefrontComponent]
    }]
  }], null, null);
})();
var _CouponCardComponent = class _CouponCardComponent {
  constructor(myCouponsComponentService, launchDialogService, vcr) {
    this.myCouponsComponentService = myCouponsComponentService;
    this.launchDialogService = launchDialogService;
    this.vcr = vcr;
    this.notificationChanged = new EventEmitter();
  }
  onSubscriptionChange() {
    this.notificationChanged.emit({
      couponId: this.coupon.couponId ?? "",
      notification: !this.coupon.notificationOn
    });
  }
  readMore() {
    const dialog = this.launchDialogService.openDialog("COUPON", this.element, this.vcr, {
      coupon: this.coupon
    });
    if (dialog) {
      dialog.pipe(take(1)).subscribe();
    }
  }
  findProducts() {
    this.myCouponsComponentService.launchSearchPage(this.coupon);
  }
};
_CouponCardComponent.\u0275fac = function CouponCardComponent_Factory(t) {
  return new (t || _CouponCardComponent)(\u0275\u0275directiveInject(MyCouponsComponentService), \u0275\u0275directiveInject(LaunchDialogService), \u0275\u0275directiveInject(ViewContainerRef));
};
_CouponCardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CouponCardComponent,
  selectors: [["cx-coupon-card"]],
  viewQuery: function CouponCardComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c29, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.element = _t.first);
    }
  },
  inputs: {
    coupon: "coupon",
    couponSubscriptionLoading$: "couponSubscriptionLoading$"
  },
  outputs: {
    notificationChanged: "notificationChanged"
  },
  decls: 40,
  vars: 38,
  consts: [[1, "card"], [1, "card-body", "cx-card-body"], [1, "cx-coupon-data"], [1, "cx-coupon-card-row", "top"], [1, "cx-coupon-card-head"], [1, "card-label-bold", "cx-coupon-card-id"], [1, "cx-coupon-card-date"], [1, "cx-coupon-date"], [1, "cx-coupon-date-start"], [1, "cx-coupon-date-end"], [1, "cx-card-read-more", "link", "cx-action-link", 3, "click"], [1, "cx-coupon-card-row", "bottom"], [1, "cx-coupon-notification", "form-check"], ["type", "checkbox", 1, "form-check-input", 3, "change", "checked", "disabled"], [1, "form-check-label"], [1, "cx-coupon-find-product", "col-lg-6", "col-md-12", "col-sm-6"], [1, "btn", "btn-block", "btn-secondary", 3, "click"]],
  template: function CouponCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "span", 5);
      \u0275\u0275text(6);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "span");
      \u0275\u0275text(8);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(9, "div");
      \u0275\u0275pipe(10, "lowercase");
      \u0275\u0275text(11);
      \u0275\u0275pipe(12, "cxTranslate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(13, "div", 6)(14, "p");
      \u0275\u0275text(15);
      \u0275\u0275pipe(16, "cxTranslate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(17, "div", 7)(18, "div", 8);
      \u0275\u0275text(19);
      \u0275\u0275pipe(20, "cxDate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(21, "div", 9);
      \u0275\u0275text(22);
      \u0275\u0275pipe(23, "cxDate");
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(24, "button", 10);
      \u0275\u0275listener("click", function CouponCardComponent_Template_button_click_24_listener() {
        return ctx.readMore();
      });
      \u0275\u0275text(25);
      \u0275\u0275pipe(26, "cxTranslate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(27, "div", 11)(28, "div", 12)(29, "label")(30, "input", 13);
      \u0275\u0275pipe(31, "async");
      \u0275\u0275pipe(32, "async");
      \u0275\u0275listener("change", function CouponCardComponent_Template_input_change_30_listener() {
        return ctx.onSubscriptionChange();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(33, "span", 14);
      \u0275\u0275text(34);
      \u0275\u0275pipe(35, "cxTranslate");
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(36, "div", 15)(37, "button", 16);
      \u0275\u0275listener("click", function CouponCardComponent_Template_button_click_37_listener() {
        return ctx.findProducts();
      });
      \u0275\u0275text(38);
      \u0275\u0275pipe(39, "cxTranslate");
      \u0275\u0275elementEnd()()()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(6);
      \u0275\u0275textInterpolate(ctx.coupon == null ? null : ctx.coupon.couponId);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(": ", ctx.coupon == null ? null : ctx.coupon.name, "");
      \u0275\u0275advance();
      \u0275\u0275classMapInterpolate1("cx-coupon-status ", \u0275\u0275pipeBind1(10, 16, ctx.coupon == null ? null : ctx.coupon.status), "");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(12, 18, "myCoupons." + (ctx.coupon == null ? null : ctx.coupon.status)), " ");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(16, 20, "myCoupons.effectiveTitle"));
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(20, 22, ctx.coupon == null ? null : ctx.coupon.startDate, "medium"), " -\xA0 ");
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(23, 25, ctx.coupon == null ? null : ctx.coupon.endDate, "medium"), " ");
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(26, 28, "myCoupons.readMore"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275classProp("disabled", \u0275\u0275pipeBind1(31, 30, ctx.couponSubscriptionLoading$));
      \u0275\u0275property("checked", ctx.coupon == null ? null : ctx.coupon.notificationOn)("disabled", \u0275\u0275pipeBind1(32, 32, ctx.couponSubscriptionLoading$));
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(35, 34, "myCoupons.notification"), " ");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(39, 36, "myCoupons.findProducts"), " ");
    }
  },
  dependencies: [AsyncPipe, LowerCasePipe, TranslatePipe, CxDatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var CouponCardComponent = _CouponCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CouponCardComponent, [{
    type: Component,
    args: [{
      selector: "cx-coupon-card",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div class="card">
  <div class="card-body cx-card-body">
    <div class="cx-coupon-data">
      <div class="cx-coupon-card-row top">
        <div class="cx-coupon-card-head">
          <span class="card-label-bold cx-coupon-card-id">{{
            coupon?.couponId
          }}</span>
          <span>: {{ coupon?.name }}</span>
        </div>

        <div class="cx-coupon-status {{ coupon?.status | lowercase }}">
          {{ 'myCoupons.' + coupon?.status | cxTranslate }}
        </div>
      </div>

      <div class="cx-coupon-card-date">
        <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>
        <div class="cx-coupon-date">
          <div class="cx-coupon-date-start">
            {{ coupon?.startDate | cxDate: 'medium' }} -&nbsp;
          </div>
          <div class="cx-coupon-date-end">
            {{ coupon?.endDate | cxDate: 'medium' }}
          </div>
        </div>
      </div>
      <button
        class="cx-card-read-more link cx-action-link"
        (click)="readMore()"
      >
        {{ 'myCoupons.readMore' | cxTranslate }}
      </button>
      <div class="cx-coupon-card-row bottom">
        <div class="cx-coupon-notification form-check">
          <label>
            <input
              type="checkbox"
              class="form-check-input"
              [checked]="coupon?.notificationOn"
              [class.disabled]="couponSubscriptionLoading$ | async"
              [disabled]="couponSubscriptionLoading$ | async"
              (change)="onSubscriptionChange()"
            />
            <span class="form-check-label">
              {{ 'myCoupons.notification' | cxTranslate }}
            </span>
          </label>
        </div>

        <div class="cx-coupon-find-product col-lg-6 col-md-12 col-sm-6">
          <button class="btn btn-block btn-secondary" (click)="findProducts()">
            {{ 'myCoupons.findProducts' | cxTranslate }}
          </button>
        </div>
      </div>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: MyCouponsComponentService
  }, {
    type: LaunchDialogService
  }, {
    type: ViewContainerRef
  }], {
    coupon: [{
      type: Input
    }],
    couponSubscriptionLoading$: [{
      type: Input
    }],
    notificationChanged: [{
      type: Output
    }],
    element: [{
      type: ViewChild,
      args: ["element"]
    }]
  });
})();
var _MyCouponsComponent = class _MyCouponsComponent {
  constructor(couponService, myCouponsComponentService) {
    this.couponService = couponService;
    this.myCouponsComponentService = myCouponsComponentService;
    this.iconTypes = ICON_TYPE;
    this.subscriptions = new Subscription();
    this.PAGE_SIZE = 10;
    this.sortMapping = {
      byStartDateAsc: "startDate:asc",
      byStartDateDesc: "startDate:desc",
      byEndDateAsc: "endDate:asc",
      byEndDateDesc: "endDate:desc"
    };
    this.sort = "byStartDateAsc";
    this.sortOptions = [{
      code: "byStartDateAsc",
      selected: false
    }, {
      code: "byStartDateDesc",
      selected: false
    }, {
      code: "byEndDateAsc",
      selected: false
    }, {
      code: "byEndDateDesc",
      selected: false
    }];
  }
  ngOnInit() {
    this.couponResult$ = this.couponService.getCustomerCoupons(this.PAGE_SIZE).pipe(tap((coupons) => this.pagination = {
      currentPage: coupons.pagination?.page,
      pageSize: coupons.pagination?.count,
      totalPages: coupons.pagination?.totalPages,
      totalResults: coupons.pagination?.totalCount,
      sort: this.sort
    }));
    this.couponsLoading$ = this.couponService.getCustomerCouponsLoading();
    this.couponSubscriptionLoading$ = combineLatest([this.couponService.getSubscribeCustomerCouponResultLoading(), this.couponService.getUnsubscribeCustomerCouponResultLoading()]).pipe(map(([subscribing, unsubscribing]) => subscribing || unsubscribing));
    this.sortLabels = this.myCouponsComponentService.getSortLabels();
    this.subscriptions.add(this.couponService.getSubscribeCustomerCouponResultError().subscribe((error) => {
      this.subscriptionFail(error);
    }));
    this.subscriptions.add(this.couponService.getUnsubscribeCustomerCouponResultError().subscribe((error) => {
      this.subscriptionFail(error);
    }));
  }
  subscriptionFail(error) {
    if (error) {
      this.couponService.loadCustomerCoupons(this.PAGE_SIZE);
    }
  }
  sortChange(sort) {
    this.sort = sort;
    this.couponService.loadCustomerCoupons(this.PAGE_SIZE, this.pagination.currentPage, this.sortMapping[sort]);
  }
  pageChange(page) {
    this.couponService.loadCustomerCoupons(this.PAGE_SIZE, page, this.sortMapping[this.sort]);
  }
  notificationChange({
    couponId,
    notification
  }) {
    if (notification) {
      this.couponService.subscribeCustomerCoupon(couponId);
    } else {
      this.couponService.unsubscribeCustomerCoupon(couponId);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
};
_MyCouponsComponent.\u0275fac = function MyCouponsComponent_Factory(t) {
  return new (t || _MyCouponsComponent)(\u0275\u0275directiveInject(CustomerCouponService), \u0275\u0275directiveInject(MyCouponsComponentService));
};
_MyCouponsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MyCouponsComponent,
  selectors: [["cx-my-coupons"]],
  decls: 5,
  vars: 4,
  consts: [["loading", ""], ["noCoupons", ""], [1, "cx-section"], [4, "ngIf", "ngIfElse"], ["role", "status"], [4, "ngIf"], [1, "cx-my-coupons-header"], [1, "cx-my-coupons-sort", "top", "row"], [1, "cx-my-coupons-form-group", "form-group", "col-sm-12", "col-md-4", "col-lg-4"], ["ariaControls", "coupon-deck", 3, "sortListEvent", "sortOptions", "sortLabels", "selectedOption", "ariaLabel"], [1, "cx-my-coupons-pagination", "cx-mycoupon-thead-mobile"], [3, "viewPageEvent", "pagination"], ["id", "coupon-deck", 1, "row", "cx-coupon-deck"], ["class", "col-md-6 cx-coupon-card", 4, "ngFor", "ngForOf"], [1, "cx-my-coupons-sort", "bottom", "row"], [1, "cx-my-coupons-form-group", "form-group", "cx-mycoupon-thead-mobile", "col-sm-12", "col-md-4", "col-lg-4"], ["ariaControls", "coupon-deck", 3, "sortListEvent", "sortOptions", "sortLabels", "selectedOption", "placeholder", "ariaLabel"], [1, "cx-my-coupons-pagination"], [1, "cx-my-coupons-notes"], [3, "type"], [3, "routerLink"], [1, "col-md-6", "cx-coupon-card"], [3, "notificationChanged", "coupon", "couponSubscriptionLoading$"], [1, "cx-section-msg"], [1, "col-md-12", "cx-coupon-spinner"]],
  template: function MyCouponsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 2);
      \u0275\u0275template(1, MyCouponsComponent_ng_container_1_Template, 7, 6, "ng-container", 3);
      \u0275\u0275pipe(2, "async");
      \u0275\u0275template(3, MyCouponsComponent_ng_template_3_Template, 2, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const loading_r7 = \u0275\u0275reference(4);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !\u0275\u0275pipeBind1(2, 2, ctx.couponsLoading$))("ngIfElse", loading_r7);
    }
  },
  dependencies: [NgForOf, NgIf, SpinnerComponent, RouterLink, IconComponent, SortingComponent, PaginationComponent, CouponCardComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var MyCouponsComponent = _MyCouponsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyCouponsComponent, [{
    type: Component,
    args: [{
      selector: "cx-my-coupons",
      template: `<div class="cx-section">
  <ng-container *ngIf="!(couponsLoading$ | async); else loading">
    <div role="status" [attr.aria-label]="'common.loaded' | cxTranslate"></div>
    <ng-container *ngIf="couponResult$ | async as couponResult">
      <div class="cx-my-coupons-header">
        <h2>
          {{ 'myCoupons.myCoupons' | cxTranslate }}
        </h2>
      </div>
      <ng-container
        *ngIf="
          couponResult.pagination &&
            couponResult.pagination.totalCount &&
            couponResult.pagination.totalCount > 0;
          else noCoupons
        "
      >
        <div class="cx-my-coupons-sort top row">
          <label
            class="
              cx-my-coupons-form-group
              form-group
              col-sm-12 col-md-4 col-lg-4
            "
          >
            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>
            <cx-sorting
              [sortOptions]="sortOptions"
              [sortLabels]="sortLabels | async"
              (sortListEvent)="sortChange($event)"
              [selectedOption]="sort"
              [ariaLabel]="'myCoupons.sortCoupons' | cxTranslate"
              ariaControls="coupon-deck"
            >
            </cx-sorting>
          </label>
          <div class="cx-my-coupons-pagination cx-mycoupon-thead-mobile">
            <cx-pagination
              [pagination]="pagination"
              (viewPageEvent)="pageChange($event)"
            ></cx-pagination>
          </div>
        </div>

        <div id="coupon-deck" class="row cx-coupon-deck">
          <div
            *ngFor="let coupon of couponResult.coupons"
            class="col-md-6 cx-coupon-card"
          >
            <cx-coupon-card
              [coupon]="coupon"
              [couponSubscriptionLoading$]="couponSubscriptionLoading$"
              (notificationChanged)="notificationChange($event)"
            ></cx-coupon-card>
          </div>
        </div>

        <div class="cx-my-coupons-sort bottom row">
          <label
            class="
              cx-my-coupons-form-group
              form-group
              cx-mycoupon-thead-mobile
              col-sm-12 col-md-4 col-lg-4
            "
          >
            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>
            <cx-sorting
              [sortOptions]="sortOptions"
              [sortLabels]="sortLabels | async"
              (sortListEvent)="sortChange($event)"
              [selectedOption]="sort"
              placeholder="{{ 'myCoupons.sortBy' | cxTranslate }}"
              [ariaLabel]="'myCoupons.sortCoupons' | cxTranslate"
              ariaControls="coupon-deck"
            >
            </cx-sorting>
          </label>
          <div class="cx-my-coupons-pagination">
            <cx-pagination
              [pagination]="pagination"
              (viewPageEvent)="pageChange($event)"
            ></cx-pagination>
          </div>
        </div>
        <div class="cx-my-coupons-notes">
          <span>
            <cx-icon [type]="iconTypes.INFO"></cx-icon>
            {{ 'myCoupons.notesPreffix' | cxTranslate
            }}<a [routerLink]="['/my-account/notification-preference']">{{
              'myCoupons.notesLink' | cxTranslate
            }}</a
            >{{ 'myCoupons.notesSuffix' | cxTranslate }}</span
          >
        </div>
      </ng-container>
    </ng-container>

    <ng-template #noCoupons>
      <section>
        <p class="cx-section-msg">
          {{ 'myCoupons.noCouponsMessage' | cxTranslate }}
        </p>
      </section>
    </ng-template>
  </ng-container>

  <ng-template #loading>
    <div class="col-md-12 cx-coupon-spinner">
      <cx-spinner></cx-spinner>
    </div>
  </ng-template>
</div>
`
    }]
  }], () => [{
    type: CustomerCouponService
  }, {
    type: MyCouponsComponentService
  }], null);
})();
var _CouponDialogComponent = class _CouponDialogComponent {
  handleClick(event) {
    if (event.target.tagName === this.el.nativeElement.tagName) {
      this.close("Cross click");
    }
  }
  constructor(launchDialogService, el) {
    this.launchDialogService = launchDialogService;
    this.el = el;
    this.subscription = new Subscription();
    this.iconTypes = ICON_TYPE;
    this.focusConfig = {
      trap: true,
      block: true,
      autofocus: "button",
      focusOnEscape: true
    };
  }
  ngOnInit() {
    this.subscription.add(this.launchDialogService.data$.subscribe((data) => {
      if (data) {
        this.coupon = data.coupon;
      }
    }));
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  close(reason) {
    this.launchDialogService.closeDialog(reason);
  }
};
_CouponDialogComponent.\u0275fac = function CouponDialogComponent_Factory(t) {
  return new (t || _CouponDialogComponent)(\u0275\u0275directiveInject(LaunchDialogService), \u0275\u0275directiveInject(ElementRef));
};
_CouponDialogComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CouponDialogComponent,
  selectors: [["cx-coupon-dialog"]],
  hostBindings: function CouponDialogComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function CouponDialogComponent_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
  },
  decls: 36,
  vars: 33,
  consts: [[1, "cx-coupon-dialog", 3, "esc", "cxFocus"], [1, "cx-coupon-container"], [1, "cx-dialog-header", "modal-header"], [1, "cx-dialog-title", "modal-title"], ["type", "button", 1, "close", 3, "click"], ["aria-hidden", "true"], [3, "type"], [1, "cx-dialog-body", "modal-body"], [1, "cx-dialog-row"], [1, "cx-dialog-item", "col-sm-12", "col-md-12"], [1, "cx-coupon-card-head"], [1, "card-label-bold", "cx-coupon-card-id"], [1, "cx-coupon-description"], [1, "cx-coupon-dialog-date"], [1, "cx-coupon-date"], [1, "cx-coupon-dialog-status"]],
  template: function CouponDialogComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275listener("esc", function CouponDialogComponent_Template_div_esc_0_listener() {
        return ctx.close("Escape clicked");
      });
      \u0275\u0275elementStart(1, "div", 1)(2, "div", 2)(3, "div", 3);
      \u0275\u0275text(4);
      \u0275\u0275pipe(5, "cxTranslate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "button", 4);
      \u0275\u0275pipe(7, "cxTranslate");
      \u0275\u0275listener("click", function CouponDialogComponent_Template_button_click_6_listener() {
        return ctx.close("Cross click");
      });
      \u0275\u0275elementStart(8, "span", 5);
      \u0275\u0275element(9, "cx-icon", 6);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(10, "div", 7)(11, "div", 8)(12, "div", 9)(13, "div", 10)(14, "span", 11);
      \u0275\u0275text(15);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(16, "span");
      \u0275\u0275text(17);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(18, "div", 12);
      \u0275\u0275text(19);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(20, "div", 13)(21, "p");
      \u0275\u0275text(22);
      \u0275\u0275pipe(23, "cxTranslate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(24, "div", 14);
      \u0275\u0275text(25);
      \u0275\u0275pipe(26, "cxDate");
      \u0275\u0275pipe(27, "cxDate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(28, "div", 15)(29, "p");
      \u0275\u0275text(30);
      \u0275\u0275pipe(31, "cxTranslate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(32, "div");
      \u0275\u0275pipe(33, "lowercase");
      \u0275\u0275text(34);
      \u0275\u0275pipe(35, "cxTranslate");
      \u0275\u0275elementEnd()()()()()()();
    }
    if (rf & 2) {
      \u0275\u0275property("cxFocus", ctx.focusConfig);
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 15, "myCoupons.dialogTitle"), " ");
      \u0275\u0275advance(2);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(7, 17, "common.close"));
      \u0275\u0275advance(3);
      \u0275\u0275property("type", ctx.iconTypes.CLOSE);
      \u0275\u0275advance(6);
      \u0275\u0275textInterpolate(ctx.coupon == null ? null : ctx.coupon.couponId);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(": ", ctx.coupon == null ? null : ctx.coupon.name, "");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.coupon == null ? null : ctx.coupon.description);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(23, 19, "myCoupons.effectiveTitle"));
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate2(" ", \u0275\u0275pipeBind2(26, 21, ctx.coupon == null ? null : ctx.coupon.startDate, "medium"), " - ", \u0275\u0275pipeBind2(27, 24, ctx.coupon == null ? null : ctx.coupon.endDate, "medium"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(31, 27, "myCoupons.status"));
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("cx-coupon-status ", \u0275\u0275pipeBind1(33, 29, ctx.coupon == null ? null : ctx.coupon.status), "");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(35, 31, "myCoupons." + (ctx.coupon == null ? null : ctx.coupon.status)), " ");
    }
  },
  dependencies: [IconComponent, FocusDirective, LowerCasePipe, TranslatePipe, CxDatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var CouponDialogComponent = _CouponDialogComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CouponDialogComponent, [{
    type: Component,
    args: [{
      selector: "cx-coupon-dialog",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div
  class="cx-coupon-dialog"
  [cxFocus]="focusConfig"
  (esc)="close('Escape clicked')"
>
  <div class="cx-coupon-container">
    <!-- Modal Header -->

    <div class="cx-dialog-header modal-header">
      <div class="cx-dialog-title modal-title">
        {{ 'myCoupons.dialogTitle' | cxTranslate }}
      </div>
      <button
        type="button"
        class="close"
        [attr.aria-label]="'common.close' | cxTranslate"
        (click)="close('Cross click')"
      >
        <span aria-hidden="true">
          <cx-icon [type]="iconTypes.CLOSE"></cx-icon>
        </span>
      </button>
    </div>
    <!-- Modal Body -->
    <div class="cx-dialog-body modal-body">
      <div class="cx-dialog-row">
        <div class="cx-dialog-item col-sm-12 col-md-12">
          <div class="cx-coupon-card-head">
            <span class="card-label-bold cx-coupon-card-id">{{
              coupon?.couponId
            }}</span>
            <span>: {{ coupon?.name }}</span>
          </div>
          <div class="cx-coupon-description">{{ coupon?.description }}</div>

          <div class="cx-coupon-dialog-date">
            <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>
            <div class="cx-coupon-date">
              {{ coupon?.startDate | cxDate: 'medium' }} -
              {{ coupon?.endDate | cxDate: 'medium' }}
            </div>
          </div>

          <div class="cx-coupon-dialog-status">
            <p>{{ 'myCoupons.status' | cxTranslate }}</p>
            <div class="cx-coupon-status {{ coupon?.status | lowercase }}">
              {{ 'myCoupons.' + coupon?.status | cxTranslate }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: LaunchDialogService
  }, {
    type: ElementRef
  }], {
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _CouponClaimComponent = class _CouponClaimComponent {
  constructor(couponService, routingService, messageService) {
    this.couponService = couponService;
    this.routingService = routingService;
    this.messageService = messageService;
  }
  ngOnInit() {
    this.routingService.getRouterState().subscribe((k) => {
      const couponCode = k.state.params.couponCode;
      if (couponCode) {
        this.couponService.claimCustomerCoupon(couponCode);
        this.subscription = this.couponService.getClaimCustomerCouponResultSuccess().subscribe((success) => {
          if (success) {
            this.messageService.add({
              key: "myCoupons.claimCustomerCoupon"
            }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
          }
          this.routingService.go({
            cxRoute: "coupons"
          });
        });
      } else {
        this.routingService.go({
          cxRoute: "notFound"
        });
      }
    }).unsubscribe();
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
};
_CouponClaimComponent.\u0275fac = function CouponClaimComponent_Factory(t) {
  return new (t || _CouponClaimComponent)(\u0275\u0275directiveInject(CustomerCouponService), \u0275\u0275directiveInject(RoutingService), \u0275\u0275directiveInject(GlobalMessageService));
};
_CouponClaimComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CouponClaimComponent,
  selectors: [["cx-coupon-claim"]],
  decls: 0,
  vars: 0,
  template: function CouponClaimComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var CouponClaimComponent = _CouponClaimComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CouponClaimComponent, [{
    type: Component,
    args: [{
      template: "",
      selector: "cx-coupon-claim"
    }]
  }], () => [{
    type: CustomerCouponService
  }, {
    type: RoutingService
  }, {
    type: GlobalMessageService
  }], null);
})();
var defaultCouponLayoutConfig = {
  launch: {
    COUPON: {
      inlineRoot: true,
      component: CouponDialogComponent,
      dialogType: DIALOG_TYPE.DIALOG
    }
  }
};
var _MyCouponsModule = class _MyCouponsModule {
};
_MyCouponsModule.\u0275fac = function MyCouponsModule_Factory(t) {
  return new (t || _MyCouponsModule)();
};
_MyCouponsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _MyCouponsModule
});
_MyCouponsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      MyCouponsComponent: {
        component: MyCouponsComponent,
        guards: [AuthGuard]
      },
      CouponClaimComponent: {
        component: CouponClaimComponent,
        guards: [AuthGuard]
      }
    }
  }), provideDefaultConfig(defaultCouponLayoutConfig)],
  imports: [CommonModule, CardModule, SpinnerModule, I18nModule, RouterModule, UrlModule, IconModule, ListNavigationModule, RouterModule.forChild([{
    // @ts-ignore
    path: null,
    canActivate: [AuthGuard, CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "couponClaim"
    }
  }]), KeyboardFocusModule]
});
var MyCouponsModule = _MyCouponsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyCouponsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CardModule, SpinnerModule, I18nModule, RouterModule, UrlModule, IconModule, ListNavigationModule, RouterModule.forChild([{
        // @ts-ignore
        path: null,
        canActivate: [AuthGuard, CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "couponClaim"
        }
      }]), KeyboardFocusModule],
      declarations: [MyCouponsComponent, CouponCardComponent, CouponDialogComponent, CouponClaimComponent],
      providers: [provideDefaultConfig({
        cmsComponents: {
          MyCouponsComponent: {
            component: MyCouponsComponent,
            guards: [AuthGuard]
          },
          CouponClaimComponent: {
            component: CouponClaimComponent,
            guards: [AuthGuard]
          }
        }
      }), provideDefaultConfig(defaultCouponLayoutConfig)],
      exports: [MyCouponsComponent, CouponClaimComponent]
    }]
  }], null, null);
})();
var _MyInterestsComponent = class _MyInterestsComponent {
  constructor(productInterestService, translationService, productService, globalMessageService) {
    this.productInterestService = productInterestService;
    this.translationService = translationService;
    this.productService = productService;
    this.globalMessageService = globalMessageService;
    this.DEFAULT_PAGE_SIZE = 10;
    this.sortMapping = {
      byNameAsc: "name:asc",
      byNameDesc: "name:desc"
    };
    this.sortChanged = false;
    this.sort = "byNameAsc";
    this.sortOptions = [{
      code: "byNameAsc",
      selected: false
    }, {
      code: "byNameDesc",
      selected: false
    }];
  }
  ngOnInit() {
    this.interests$ = this.productInterestService.getAndLoadProductInterests(this.DEFAULT_PAGE_SIZE).pipe(tap((interests) => this.pagination = {
      currentPage: interests.pagination?.page,
      pageSize: interests.pagination?.count,
      totalPages: interests.pagination?.totalPages,
      totalResults: interests.pagination?.totalCount,
      sort: "byNameAsc"
    }), tap(() => {
      if (this.sortChanged) {
        this.sortChanged = false;
        this.globalMessageService?.add({
          key: "sorting.pageViewUpdated"
        }, GlobalMessageType.MSG_TYPE_ASSISTIVE, 500);
      }
    }), map((interest) => __spreadProps(__spreadValues({}, interest), {
      results: interest.results ? interest.results.map((result) => __spreadProps(__spreadValues({}, result), {
        product$: this.getProduct(result)
      })) : interest.results
    })));
    this.getInterestsloading$ = this.productInterestService.getProdutInterestsLoading();
    this.isRemoveDisabled$ = combineLatest([this.getInterestsloading$, this.productInterestService.getRemoveProdutInterestLoading()]).pipe(map(([getLoading, removeLoading]) => getLoading || removeLoading));
    this.sortLabels = this.getSortLabels();
  }
  getSortLabels() {
    return combineLatest([this.translationService.translate("myInterests.sorting.byNameAsc"), this.translationService.translate("myInterests.sorting.byNameDesc")]).pipe(map(([asc, desc]) => {
      return {
        byNameAsc: asc,
        byNameDesc: desc
      };
    }));
  }
  getProduct(interest) {
    return this.productService.get(
      interest.product?.code ?? "",
      "details"
      /* ProductScope.DETAILS */
    );
  }
  removeInterest(relation) {
    this.productInterestService.removeProdutInterest({
      product: relation.product,
      productInterestEntry: relation.productInterestEntry
    });
  }
  sortChange(sort) {
    this.sort = sort;
    this.sortChanged = true;
    this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, 0, this.sortMapping[sort]);
  }
  pageChange(page) {
    this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, page, this.sortMapping[this.sort]);
  }
  ngOnDestroy() {
    this.productInterestService.clearProductInterests();
    this.productInterestService.resetRemoveInterestState();
  }
};
_MyInterestsComponent.\u0275fac = function MyInterestsComponent_Factory(t) {
  return new (t || _MyInterestsComponent)(\u0275\u0275directiveInject(UserInterestsService), \u0275\u0275directiveInject(TranslationService), \u0275\u0275directiveInject(ProductService), \u0275\u0275directiveInject(GlobalMessageService));
};
_MyInterestsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MyInterestsComponent,
  selectors: [["cx-my-interests"]],
  decls: 6,
  vars: 3,
  consts: [["noInterest", ""], ["loading", ""], ["class", "container", 4, "ngIf"], [1, "container"], [1, "cx-product-interests-title"], ["class", "cx-product-interests-body", 4, "ngIf", "ngIfElse"], [1, "cx-product-interests-body"], ["role", "status"], [4, "ngIf", "ngIfElse"], [1, "cx-product-interests-sort", "top", "row"], [1, "cx-product-interests-form-group", "form-group", "col-sm-12", "col-md-4", "col-lg-4"], ["ariaControls", "product-interests-table", 3, "sortListEvent", "sortOptions", "sortLabels", "selectedOption", "placeholder", "ariaLabel"], [1, "cx-product-interests-pagination", "cx-product-interests-thead-mobile"], [3, "viewPageEvent", "pagination"], ["id", "product-interests-table", 1, "table", "cx-product-interests-table", "cx-product-interests-table-list"], [1, "cx-visually-hidden"], [1, "cx-product-interests-thead-mobile", "cx-product-interests-header"], ["role", "columnheader"], ["srole", "columnheader"], ["class", "cx-product-interests-product-item", "role", "row", 4, "ngFor", "ngForOf"], [1, "cx-product-interests-sort", "bottom", "row"], [1, "cx-product-interests-form-group", "cx-product-interests-thead-mobile", "form-group", "col-sm-12", "col-md-4", "col-lg-4"], [1, "cx-product-interests-pagination"], ["role", "row", 1, "cx-product-interests-product-item"], [4, "ngIf"], ["role", "cell"], [1, "cx-product-interests-cell-wrapper"], [1, "cx-product-interests-label"], ["tabindex", "-1", 1, "cx-product-interests-product-image-link", 3, "routerLink"], ["format", "thumbnail", 3, "container"], [1, "cx-info", "col-10"], [1, "cx-info-container", "row"], ["class", "cx-name", 4, "ngIf"], ["class", "cx-code", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["class", "cx-property", 4, "ngIf"], [1, "cx-product-interests-product-price"], [1, "d-md-none", "cx-product-interests-label"], [1, "cx-product-interests-subscriptions"], ["class", "cx-product-interests-notification", 4, "ngFor", "ngForOf"], [1, "cx-actions", "cx-product-interests-remove-button"], ["type", "button", 1, "cx-product-interests-remove-btn", "link", "cx-action-link", "cx-remove-btn", 3, "click", "cxAtMessage", "disabled"], [1, "cx-name"], [1, "cx-link", "cx-product-interests-product-code-link", 3, "routerLink"], [1, "cx-code"], ["class", "cx-property", 4, "ngFor", "ngForOf"], [1, "cx-property"], [1, "cx-label", "cx-product-interests-variant-name"], [1, "cx-value", "cx-product-interests-variant-value"], [1, "cx-label", "cx-product-interests-product-stock"], [1, "cx-product-interests-notification"], [1, "cx-product-interests-type"], [1, "cx-product-interests-expiration-date"], [1, "cx-product-interests-message"], [1, "cx-spinner"]],
  template: function MyInterestsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, MyInterestsComponent_div_0_Template, 7, 7, "div", 2);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, MyInterestsComponent_ng_template_2_Template, 3, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(4, MyInterestsComponent_ng_template_4_Template, 2, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.interests$));
    }
  },
  dependencies: [AtMessageDirective, NgForOf, NgIf, SortingComponent, PaginationComponent, MediaComponent, SpinnerComponent, RouterLink, AsyncPipe, TranslatePipe, CxDatePipe, UrlPipe],
  encapsulation: 2,
  changeDetection: 0
});
var MyInterestsComponent = _MyInterestsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyInterestsComponent, [{
    type: Component,
    args: [{
      selector: "cx-my-interests",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div *ngIf="interests$ | async as interests" class="container">
  <div class="cx-product-interests-title">
    <h2>{{ 'myInterests.header' | cxTranslate }}</h2>
  </div>
  <div
    class="cx-product-interests-body"
    *ngIf="!(getInterestsloading$ | async); else loading"
  >
    <div role="status" [attr.aria-label]="'common.loaded' | cxTranslate"></div>
    <ng-container
      *ngIf="
        interests.pagination &&
          interests.pagination.totalCount &&
          interests.pagination.totalCount > 0;
        else noInterest
      "
    >
      <div class="cx-product-interests-sort top row">
        <label
          class="
            cx-product-interests-form-group
            form-group
            col-sm-12 col-md-4 col-lg-4
          "
          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>
          <cx-sorting
            [sortOptions]="sortOptions"
            [sortLabels]="sortLabels | async"
            (sortListEvent)="sortChange($event)"
            [selectedOption]="sort"
            placeholder="{{ 'myInterests.sortBy' | cxTranslate }}"
            [ariaLabel]="'myInterests.sortInterests' | cxTranslate"
            ariaControls="product-interests-table"
          >
          </cx-sorting>
        </label>
        <div
          class="
            cx-product-interests-pagination cx-product-interests-thead-mobile
          "
        >
          <cx-pagination
            [pagination]="pagination"
            (viewPageEvent)="pageChange($event)"
          ></cx-pagination>
        </div>
      </div>

      <table
        id="product-interests-table"
        class="table cx-product-interests-table cx-product-interests-table-list"
      >
        <caption class="cx-visually-hidden">
          {{
            'myInterests.caption' | cxTranslate
          }}
        </caption>
        <thead
          class="cx-product-interests-thead-mobile cx-product-interests-header"
        >
          <th role="columnheader">
            {{ 'myInterests.item' | cxTranslate }}
          </th>
          <th role="columnheader">
            {{ 'myInterests.price' | cxTranslate }}
          </th>
          <th role="columnheader">
            {{ 'myInterests.notifications' | cxTranslate }}
          </th>
          <th srole="columnheader">
            {{ 'myInterests.actions' | cxTranslate }}
          </th>
        </thead>
        <tbody>
          <tr
            *ngFor="let interest of interests.results"
            class="cx-product-interests-product-item"
            role="row"
          >
            <ng-container *ngIf="interest.product$ | async as product">
              <td role="cell">
                <div class="cx-product-interests-cell-wrapper">
                  <div class="cx-product-interests-label">
                    <a
                      class="cx-product-interests-product-image-link"
                      tabindex="-1"
                      [routerLink]="
                        { cxRoute: 'product', params: product } | cxUrl
                      "
                    >
                      <cx-media
                        [container]="product.images?.PRIMARY"
                        format="thumbnail"
                      ></cx-media>
                    </a>
                  </div>

                  <div class="cx-info col-10">
                    <div class="cx-info-container row">
                      <div>
                        <div *ngIf="product.name" class="cx-name">
                          <a
                            class="
                              cx-link cx-product-interests-product-code-link
                            "
                            [routerLink]="
                              { cxRoute: 'product', params: product } | cxUrl
                            "
                          >
                            {{ product.name }}
                          </a>
                        </div>
                        <div *ngIf="product.code" class="cx-code">
                          <span>{{
                            'myInterests.productId'
                              | cxTranslate: { code: product.code }
                          }}</span>
                        </div>

                        <ng-container
                          *ngFor="let baseOptions of product.baseOptions"
                        >
                          <div
                            *ngFor="
                              let variant of baseOptions.selected
                                ?.variantOptionQualifiers
                            "
                            class="cx-property"
                          >
                            <div
                              class="cx-label cx-product-interests-variant-name"
                            >
                              {{ variant.name }}
                            </div>
                            <div
                              class="
                                cx-value cx-product-interests-variant-value
                              "
                            >
                              {{ variant.value }}
                            </div>
                          </div>
                        </ng-container>
                        <div
                          class="cx-property"
                          *ngIf="
                            product.stock?.stockLevelStatus === 'outOfStock'
                          "
                        >
                          <div
                            class="cx-label cx-product-interests-product-stock"
                          >
                            {{ 'myInterests.outOfStock' | cxTranslate }}
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </td>
              <td role="cell">
                <div class="cx-product-interests-product-price">
                  <div class="d-md-none cx-product-interests-label">
                    {{ 'myInterests.price' | cxTranslate }}
                  </div>
                  <span>{{ product.price?.formattedValue }}</span>
                </div>
              </td>
              <td role="cell">
                <div class="cx-product-interests-subscriptions">
                  <div class="d-md-none cx-product-interests-label">
                    {{ 'myInterests.notifications' | cxTranslate }}
                  </div>
                  <div
                    class="cx-product-interests-notification"
                    *ngFor="let interestEntry of interest.productInterestEntry"
                  >
                    <span class="cx-product-interests-type">
                      {{
                        'myInterests.' + interestEntry.interestType
                          | cxTranslate
                      }}
                    </span>
                    <span class="cx-product-interests-expiration-date">
                      {{
                        'myInterests.expirationDate'
                          | cxTranslate
                            : {
                                expirationDate:
                                  interestEntry.expirationDate | cxDate
                              }
                      }}
                    </span>
                  </div>
                </div>
              </td>
              <td role="cell">
                <div class="cx-actions cx-product-interests-remove-button">
                  <button
                    type="button"
                    class="
                      cx-product-interests-remove-btn
                      link
                      cx-action-link cx-remove-btn
                    "
                    [cxAtMessage]="'myInterests.itemRemoved' | cxTranslate"
                    [disabled]="isRemoveDisabled$ | async"
                    (click)="removeInterest(interest)"
                  >
                    {{ 'myInterests.remove' | cxTranslate }}
                  </button>
                </div>
              </td>
            </ng-container>
          </tr>
        </tbody>
      </table>

      <div class="cx-product-interests-sort bottom row">
        <label
          class="
            cx-product-interests-form-group cx-product-interests-thead-mobile
            form-group
            col-sm-12 col-md-4 col-lg-4
          "
          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>
          <cx-sorting
            [sortOptions]="sortOptions"
            [sortLabels]="sortLabels | async"
            (sortListEvent)="sortChange($event)"
            [selectedOption]="sort"
            placeholder="{{ 'myInterests.sortBy' | cxTranslate }}"
            [ariaLabel]="'myInterests.sortInterests' | cxTranslate"
            ariaControls="product-interests-table"
          >
          </cx-sorting>
        </label>
        <div class="cx-product-interests-pagination">
          <cx-pagination
            [pagination]="pagination"
            (viewPageEvent)="pageChange($event)"
          ></cx-pagination>
        </div>
      </div>
    </ng-container>
  </div>
</div>
<ng-template #noInterest>
  <div class="cx-product-interests-message">
    {{ 'myInterests.noInterests' | cxTranslate }}
  </div>
</ng-template>
<ng-template #loading>
  <div class="cx-spinner">
    <cx-spinner></cx-spinner>
  </div>
</ng-template>
`
    }]
  }], () => [{
    type: UserInterestsService
  }, {
    type: TranslationService
  }, {
    type: ProductService
  }, {
    type: GlobalMessageService
  }], null);
})();
var _MyInterestsModule = class _MyInterestsModule {
};
_MyInterestsModule.\u0275fac = function MyInterestsModule_Factory(t) {
  return new (t || _MyInterestsModule)();
};
_MyInterestsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _MyInterestsModule
});
_MyInterestsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      MyInterestsComponent: {
        component: MyInterestsComponent,
        guards: [AuthGuard]
      }
    }
  })],
  imports: [AtMessageModule, CommonModule, I18nModule, ListNavigationModule, I18nModule, UrlModule, MediaModule, SpinnerModule, RouterModule.forChild([{
    // @ts-ignore
    path: null,
    canActivate: [AuthGuard, CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "myInterests"
    }
  }])]
});
var MyInterestsModule = _MyInterestsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyInterestsModule, [{
    type: NgModule,
    args: [{
      declarations: [MyInterestsComponent],
      imports: [AtMessageModule, CommonModule, I18nModule, ListNavigationModule, I18nModule, UrlModule, MediaModule, SpinnerModule, RouterModule.forChild([{
        // @ts-ignore
        path: null,
        canActivate: [AuthGuard, CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "myInterests"
        }
      }])],
      providers: [provideDefaultConfig({
        cmsComponents: {
          MyInterestsComponent: {
            component: MyInterestsComponent,
            guards: [AuthGuard]
          }
        }
      })],
      exports: [MyInterestsComponent]
    }]
  }], null, null);
})();
var _NotificationPreferenceComponent = class _NotificationPreferenceComponent {
  constructor(notificationPreferenceService) {
    this.notificationPreferenceService = notificationPreferenceService;
    this.preferences = [];
  }
  ngOnInit() {
    this.notificationPreferenceService.resetNotificationPreferences();
    this.preferences$ = this.notificationPreferenceService.getPreferences().pipe(tap((preferences) => this.preferences = preferences));
    this.notificationPreferenceService.loadPreferences();
    this.isLoading$ = combineLatest([this.notificationPreferenceService.getPreferencesLoading(), this.notificationPreferenceService.getUpdatePreferencesResultLoading()]).pipe(map(([prefsLoading, updateLoading]) => prefsLoading || updateLoading));
  }
  updatePreference(preference) {
    const updatedPreferences = [];
    this.preferences.forEach((p) => {
      if (p.channel === preference.channel) {
        updatedPreferences.push(__spreadProps(__spreadValues({}, p), {
          enabled: !p.enabled
        }));
      } else {
        updatedPreferences.push(p);
      }
    });
    this.notificationPreferenceService.updatePreferences(updatedPreferences);
  }
};
_NotificationPreferenceComponent.\u0275fac = function NotificationPreferenceComponent_Factory(t) {
  return new (t || _NotificationPreferenceComponent)(\u0275\u0275directiveInject(UserNotificationPreferenceService));
};
_NotificationPreferenceComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NotificationPreferenceComponent,
  selectors: [["cx-notification-preference"]],
  decls: 2,
  vars: 3,
  consts: [["loading", ""], [4, "ngIf"], [4, "ngIf", "ngIfElse"], ["role", "status"], [1, "row", "d-flex", "justify-content-center"], [1, "col-md-8"], [1, "pref-header"], [1, "form-check", "cx-notification-channels"], [4, "ngFor", "ngForOf"], [1, "pref-note"], ["class", "pref-channel", 4, "ngIf"], [1, "pref-channel"], ["role", "checkbox", "type", "checkbox", 1, "form-check-input", "cx-np-checkbox", 3, "change", "checked", "disabled"], [1, "form-check-label"], [1, "cx-spinner"]],
  template: function NotificationPreferenceComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NotificationPreferenceComponent_ng_container_0_Template, 4, 2, "ng-container", 1);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.preferences$));
    }
  },
  dependencies: [NgForOf, NgIf, SpinnerComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NotificationPreferenceComponent = _NotificationPreferenceComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotificationPreferenceComponent, [{
    type: Component,
    args: [{
      selector: "cx-notification-preference",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="preferences$ | async as preferences">
  <div *ngIf="preferences.length > 0; else loading">
    <div role="status" [attr.aria-label]="'common.loaded' | cxTranslate"></div>
    <div class="row d-flex justify-content-center">
      <div class="col-md-8">
        <div class="pref-header">
          {{ 'notificationPreference.message' | cxTranslate }}
        </div>
        <div class="form-check cx-notification-channels">
          <ng-container *ngFor="let preference of preferences">
            <label *ngIf="preference.visible" class="pref-channel">
              <input
                class="form-check-input cx-np-checkbox"
                role="checkbox"
                type="checkbox"
                [checked]="preference.enabled"
                (change)="updatePreference(preference)"
                [disabled]="isLoading$ | async"
              />
              <span class="form-check-label">
                {{
                  'notificationPreference.' + preference.channel | cxTranslate
                }}
                {{ preference.value }}
              </span>
            </label>
          </ng-container>
        </div>
        <label class="pref-note"
          ><strong>{{ 'notificationPreference.note' | cxTranslate }}</strong
          >{{ 'notificationPreference.noteMessage' | cxTranslate }}
        </label>
      </div>
    </div>
  </div>

  <ng-template #loading>
    <div class="cx-spinner">
      <cx-spinner></cx-spinner>
    </div>
  </ng-template>
</ng-container>
`
    }]
  }], () => [{
    type: UserNotificationPreferenceService
  }], null);
})();
var _NotificationPreferenceModule = class _NotificationPreferenceModule {
};
_NotificationPreferenceModule.\u0275fac = function NotificationPreferenceModule_Factory(t) {
  return new (t || _NotificationPreferenceModule)();
};
_NotificationPreferenceModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NotificationPreferenceModule
});
_NotificationPreferenceModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      NotificationPreferenceComponent: {
        component: NotificationPreferenceComponent,
        guards: [AuthGuard]
      }
    }
  })],
  imports: [CommonModule, SpinnerModule, I18nModule, RouterModule.forChild([{
    // @ts-ignore
    path: null,
    canActivate: [AuthGuard, CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "notificationPreference"
    }
  }])]
});
var NotificationPreferenceModule = _NotificationPreferenceModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotificationPreferenceModule, [{
    type: NgModule,
    args: [{
      declarations: [NotificationPreferenceComponent],
      imports: [CommonModule, SpinnerModule, I18nModule, RouterModule.forChild([{
        // @ts-ignore
        path: null,
        canActivate: [AuthGuard, CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "notificationPreference"
        }
      }])],
      providers: [provideDefaultConfig({
        cmsComponents: {
          NotificationPreferenceComponent: {
            component: NotificationPreferenceComponent,
            guards: [AuthGuard]
          }
        }
      })],
      exports: [NotificationPreferenceComponent]
    }]
  }], null, null);
})();
var _PaymentMethodsComponent = class _PaymentMethodsComponent {
  constructor(userPaymentService, translation, globalMessageService) {
    this.userPaymentService = userPaymentService;
    this.translation = translation;
    this.globalMessageService = globalMessageService;
    this.iconTypes = ICON_TYPE;
  }
  ngOnInit() {
    this.paymentMethods$ = this.userPaymentService.getPaymentMethods().pipe(tap((paymentDetails) => {
      if (paymentDetails.length > 0 && !paymentDetails.find((paymentDetail) => paymentDetail.defaultPayment)) {
        this.setDefaultPaymentMethod(paymentDetails[0]);
      }
    }));
    this.editCard = void 0;
    this.loading$ = this.userPaymentService.getPaymentMethodsLoading();
    this.userPaymentService.loadPaymentMethods();
  }
  getCardContent({
    defaultPayment,
    accountHolderName,
    expiryMonth,
    expiryYear,
    cardNumber,
    cardType
  }) {
    return combineLatest([this.translation.translate("paymentCard.setAsDefault"), this.translation.translate("common.delete"), this.translation.translate("paymentCard.deleteConfirmation"), this.translation.translate("paymentCard.expires", {
      month: expiryMonth,
      year: expiryYear
    }), this.translation.translate("paymentCard.defaultPaymentMethod")]).pipe(map(([textSetAsDefault, textDelete, textDeleteConfirmation, textExpires, textDefaultPaymentMethod]) => {
      const actions = [];
      if (!defaultPayment) {
        actions.push({
          name: textSetAsDefault,
          event: "default"
        });
      }
      actions.push({
        name: textDelete,
        event: "edit"
      });
      const card = {
        role: "region",
        header: defaultPayment ? textDefaultPaymentMethod : void 0,
        textBold: accountHolderName,
        text: [cardNumber ?? "", textExpires],
        actions,
        deleteMsg: textDeleteConfirmation,
        img: this.getCardIcon(cardType?.code ?? ""),
        label: defaultPayment ? "paymentCard.defaultPaymentLabel" : "paymentCard.additionalPaymentLabel"
      };
      return card;
    }));
  }
  deletePaymentMethod(paymentMethod) {
    if (paymentMethod.id) {
      this.userPaymentService.deletePaymentMethod(paymentMethod.id);
      this.editCard = void 0;
    }
  }
  setEdit(paymentMethod) {
    this.editCard = paymentMethod.id;
  }
  cancelCard() {
    this.editCard = void 0;
  }
  setDefaultPaymentMethod(paymentMethod) {
    this.userPaymentService.setPaymentMethodAsDefault(paymentMethod.id ?? "");
    this.globalMessageService?.add({
      key: "paymentMessages.setAsDefaultSuccessfully"
    }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
  }
  getCardIcon(code) {
    let ccIcon;
    if (code === "visa") {
      ccIcon = this.iconTypes.VISA;
    } else if (code === "master" || code === "mastercard_eurocard") {
      ccIcon = this.iconTypes.MASTER_CARD;
    } else if (code === "diners") {
      ccIcon = this.iconTypes.DINERS_CLUB;
    } else if (code === "amex") {
      ccIcon = this.iconTypes.AMEX;
    } else {
      ccIcon = this.iconTypes.CREDIT_CARD;
    }
    return ccIcon;
  }
};
_PaymentMethodsComponent.\u0275fac = function PaymentMethodsComponent_Factory(t) {
  return new (t || _PaymentMethodsComponent)(\u0275\u0275directiveInject(UserPaymentService), \u0275\u0275directiveInject(TranslationService), \u0275\u0275directiveInject(GlobalMessageService));
};
_PaymentMethodsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PaymentMethodsComponent,
  selectors: [["cx-payment-methods"]],
  decls: 2,
  vars: 3,
  consts: [["cards", ""], [4, "ngIf"], [1, "cx-payment", "container"], [1, "cx-header"], [1, "cx-body"], [1, "cx-msg"], [4, "ngIf", "ngIfElse"], ["role", "status"], [1, "cx-existing", "row"], ["class", "cx-payment-card col-sm-12 col-md-12 col-lg-6", 4, "ngFor", "ngForOf"], [1, "cx-payment-card", "col-sm-12", "col-md-12", "col-lg-6"], [1, "cx-payment-inner"], [3, "deleteCard", "setDefaultCard", "editCard", "cancelCard", "index", "border", "fitToContainer", "content", "editMode"]],
  template: function PaymentMethodsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, PaymentMethodsComponent_ng_container_0_Template, 14, 10, "ng-container", 1);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.paymentMethods$));
    }
  },
  dependencies: [NgForOf, NgIf, CardComponent, SpinnerComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var PaymentMethodsComponent = _PaymentMethodsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaymentMethodsComponent, [{
    type: Component,
    args: [{
      selector: "cx-payment-methods",
      template: `<ng-container *ngIf="paymentMethods$ | async as paymentMethods">
  <div class="cx-payment container">
    <div class="cx-header">
      <h2>
        {{ 'paymentMethods.paymentMethods' | cxTranslate }}
      </h2>
    </div>

    <div class="cx-body">
      <div class="cx-msg">
        {{
          'paymentMethods.newPaymentMethodsAreAddedDuringCheckout' | cxTranslate
        }}
      </div>
      <div *ngIf="loading$ | async; else cards"><cx-spinner></cx-spinner></div>
      <ng-template #cards>
        <div
          role="status"
          [attr.aria-label]="'common.loaded' | cxTranslate"
        ></div>
        <div class="cx-existing row">
          <div
            class="cx-payment-card col-sm-12 col-md-12 col-lg-6"
            *ngFor="let paymentMethod of paymentMethods; let i = index"
          >
            <div class="cx-payment-inner">
              <cx-card
                [index]="i"
                [border]="true"
                [fitToContainer]="true"
                [content]="getCardContent(paymentMethod) | async"
                (deleteCard)="deletePaymentMethod(paymentMethod)"
                (setDefaultCard)="setDefaultPaymentMethod(paymentMethod)"
                (editCard)="setEdit(paymentMethod)"
                [editMode]="editCard === paymentMethod.id"
                (cancelCard)="cancelCard()"
              ></cx-card>
            </div>
          </div>
        </div>
      </ng-template>
    </div>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: UserPaymentService
  }, {
    type: TranslationService
  }, {
    type: GlobalMessageService
  }], null);
})();
var _PaymentMethodsModule = class _PaymentMethodsModule {
};
_PaymentMethodsModule.\u0275fac = function PaymentMethodsModule_Factory(t) {
  return new (t || _PaymentMethodsModule)();
};
_PaymentMethodsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PaymentMethodsModule
});
_PaymentMethodsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      AccountPaymentDetailsComponent: {
        component: PaymentMethodsComponent,
        guards: [AuthGuard]
      }
    }
  })],
  imports: [CommonModule, CardModule, SpinnerModule, I18nModule]
});
var PaymentMethodsModule = _PaymentMethodsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaymentMethodsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CardModule, SpinnerModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          AccountPaymentDetailsComponent: {
            component: PaymentMethodsComponent,
            guards: [AuthGuard]
          }
        }
      })],
      declarations: [PaymentMethodsComponent],
      exports: [PaymentMethodsComponent]
    }]
  }], null, null);
})();
var _PageTitleComponent = class _PageTitleComponent {
  constructor(component, pageMetaService) {
    this.component = component;
    this.pageMetaService = pageMetaService;
  }
  ngOnInit() {
    this.setTitle();
  }
  ngAfterViewInit() {
    this.lastestTitle$ = this.title$;
  }
  setTitle() {
    this.title$ = this.pageMetaService.getMeta().pipe(filter(isNotNullable), map((meta) => (meta.heading || meta.title) ?? ""));
  }
};
_PageTitleComponent.\u0275fac = function PageTitleComponent_Factory(t) {
  return new (t || _PageTitleComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(PageMetaService));
};
_PageTitleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PageTitleComponent,
  selectors: [["cx-page-title"]],
  decls: 3,
  vars: 3,
  consts: [[1, "cx-visually-hidden"]],
  template: function PageTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "h1", 0);
      \u0275\u0275text(1);
      \u0275\u0275pipe(2, "async");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(2, 1, ctx.title$));
    }
  },
  dependencies: [AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var PageTitleComponent = _PageTitleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageTitleComponent, [{
    type: Component,
    args: [{
      selector: "cx-page-title",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<h1 class="cx-visually-hidden">{{ title$ | async }}</h1>\n'
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: PageMetaService
  }], null);
})();
var _BreadcrumbComponent = class _BreadcrumbComponent extends PageTitleComponent {
  constructor(component, pageMetaService, translation) {
    super(component, pageMetaService);
    this.component = component;
    this.pageMetaService = pageMetaService;
    this.translation = translation;
  }
  ngOnInit() {
    super.ngOnInit();
    this.setCrumbs();
  }
  setCrumbs() {
    this.crumbs$ = combineLatest([this.pageMetaService.getMeta(), this.translation.translate("common.home")]).pipe(map(([meta, textHome]) => meta?.breadcrumbs ? meta.breadcrumbs : [{
      label: textHome,
      link: "/"
    }]));
  }
};
_BreadcrumbComponent.\u0275fac = function BreadcrumbComponent_Factory(t) {
  return new (t || _BreadcrumbComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(PageMetaService), \u0275\u0275directiveInject(TranslationService));
};
_BreadcrumbComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BreadcrumbComponent,
  selectors: [["cx-breadcrumb"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 12,
  vars: 15,
  consts: [["tabindex", "-1"], [4, "ngFor", "ngForOf"], ["aria-live", "polite", "aria-atomic", "true", 1, "cx-visually-hidden"], [3, "routerLink", "innerHTML"]],
  template: function BreadcrumbComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nav", 0);
      \u0275\u0275pipe(1, "cxTranslate");
      \u0275\u0275elementStart(2, "ol");
      \u0275\u0275pipe(3, "cxTranslate");
      \u0275\u0275template(4, BreadcrumbComponent_li_4_Template, 3, 8, "li", 1);
      \u0275\u0275pipe(5, "async");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(6, "span", 2);
      \u0275\u0275text(7);
      \u0275\u0275pipe(8, "async");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(9, "h1");
      \u0275\u0275text(10);
      \u0275\u0275pipe(11, "async");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 5, "common.breadcrumbs"));
      \u0275\u0275advance(2);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(3, 7, "common.breadcrumbs"));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", \u0275\u0275pipeBind1(5, 9, ctx.crumbs$));
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(8, 11, ctx.lastestTitle$), "\n");
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(11, 13, ctx.title$));
    }
  },
  dependencies: [NgForOf, RouterLink, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var BreadcrumbComponent = _BreadcrumbComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadcrumbComponent, [{
    type: Component,
    args: [{
      selector: "cx-breadcrumb",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<nav [attr.aria-label]="'common.breadcrumbs' | cxTranslate" tabindex="-1">
  <ol [attr.aria-label]="'common.breadcrumbs' | cxTranslate">
    <li *ngFor="let crumb of crumbs$ | async">
      <a
        [attr.aria-label]="
          'navigation.navigateTo' | cxTranslate: { nav: crumb.label }
        "
        [routerLink]="crumb.link"
        [innerHTML]="crumb.label"
      ></a>
    </li>
  </ol>
</nav>
<!-- Hidden page title for Screen Reader initialized after view to avoid old values -->
<span class="cx-visually-hidden" aria-live="polite" aria-atomic="true">
  {{ lastestTitle$ | async }}
</span>
<h1>{{ title$ | async }}</h1>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: PageMetaService
  }, {
    type: TranslationService
  }], null);
})();
var _BreadcrumbModule = class _BreadcrumbModule {
};
_BreadcrumbModule.\u0275fac = function BreadcrumbModule_Factory(t) {
  return new (t || _BreadcrumbModule)();
};
_BreadcrumbModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BreadcrumbModule
});
_BreadcrumbModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      BreadcrumbComponent: {
        component: BreadcrumbComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, PageMetaModule, I18nModule]
});
var BreadcrumbModule = _BreadcrumbModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadcrumbModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PageMetaModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          BreadcrumbComponent: {
            component: BreadcrumbComponent
          }
        }
      })],
      declarations: [BreadcrumbComponent],
      exports: [BreadcrumbComponent]
    }]
  }], null, null);
})();
var _NavigationService = class _NavigationService {
  constructor(cmsService, semanticPathService) {
    this.cmsService = cmsService;
    this.semanticPathService = semanticPathService;
  }
  createNavigation(data$) {
    return combineLatest([data$, this.getNavigationNode(data$)]).pipe(map(([data, nav]) => {
      return {
        title: data.name,
        children: [nav]
      };
    }));
  }
  /**
   * returns an observable with the `NavigationNode` for the given `CmsNavigationComponent`.
   * This function will load the navigation underlying entries and children if they haven't been
   * loaded so far.
   */
  getNavigationNode(data$) {
    if (!data$) {
      return EMPTY;
    }
    return data$.pipe(filter((data) => !!data), switchMap((data) => {
      const navigation = data.navigationNode ? data.navigationNode : data;
      return this.cmsService.getNavigationEntryItems(navigation.uid ?? "").pipe(tap((items) => {
        if (items === void 0) {
          this.loadNavigationEntryItems(navigation, true);
          return;
        }
        const expectedItems = [];
        this.loadNavigationEntryItems(navigation, false, expectedItems);
        const existingItems = Object.keys(items).map((key) => items[key].uid ?? "");
        const missingItems = expectedItems.filter((it) => it.id && !existingItems.includes(it.id));
        if (missingItems.length > 0) {
          this.cmsService.loadNavigationItems(navigation.uid ?? "", missingItems);
        }
      }), filter(Boolean), map((items) => this.populateNavigationNode(navigation, items) ?? {}));
    }));
  }
  /**
   * Loads all navigation entry items' type and id. Dispatch action to load all these items
   * @param nodeData
   * @param root
   * @param itemsList
   */
  loadNavigationEntryItems(nodeData, root, itemsList = []) {
    if (nodeData.entries && nodeData.entries.length > 0) {
      nodeData.entries.forEach((entry) => {
        itemsList.push({
          superType: entry.itemSuperType,
          id: entry.itemId
        });
      });
    }
    if (nodeData.children && nodeData.children.length > 0) {
      nodeData.children.forEach((child) => this.loadNavigationEntryItems(child, false, itemsList));
    }
    if (root && nodeData.uid) {
      this.cmsService.loadNavigationItems(nodeData.uid, itemsList);
    }
  }
  /**
   * Create a new node tree for the view
   * @param nodeData
   * @param items
   */
  populateNavigationNode(nodeData, items) {
    const node = {};
    if (nodeData.title) {
      node.title = nodeData.title;
    }
    if (nodeData.styleClasses) {
      node.styleClasses = nodeData.styleClasses;
    }
    if (nodeData.styleAttributes) {
      node.styleAttributes = nodeData.styleAttributes;
    }
    if (nodeData.entries && nodeData.entries.length > 0) {
      this.populateLink(node, nodeData.entries[0], items);
    }
    if (nodeData.children?.length > 0) {
      const children = nodeData.children.map((child) => this.populateNavigationNode(child, items)).filter(Boolean);
      if (children.length > 0) {
        node.children = children;
      }
    }
    return Object.keys(node).length === 0 ? null : node;
  }
  /**
   * The node link is driven by the first entry.
   */
  populateLink(node, entry, items) {
    const item = items[`${entry.itemId}_${entry.itemSuperType}`];
    if (item && entry.itemType === "CMSLinkComponent") {
      if (!node.title) {
        node.title = item.linkName;
      }
      const url = this.getLink(item);
      if (node.title && url) {
        node.url = url;
        if (item.target === "true" || item.target === true) {
          node.target = "_blank";
        }
      }
      if (item.styleClasses) {
        node.styleClasses = item.styleClasses;
      }
      if (item.styleAttributes) {
        node.styleAttributes = item.styleAttributes;
      }
    }
  }
  /**
   *
   * Gets the URL or link to a related item (category),
   * also taking into account content pages (contentPageLabelOrId)
   * and product pages (productCode)
   */
  getLink(item) {
    if (item.url) {
      return item.url;
    } else if (item.contentPageLabelOrId) {
      return item.contentPageLabelOrId;
    } else if (item.categoryCode) {
      return this.semanticPathService.transform({
        cxRoute: "category",
        params: {
          code: item.categoryCode,
          name: item.name
        }
      });
    } else if (item.productCode) {
      return this.semanticPathService.transform({
        cxRoute: "product",
        params: {
          code: item.productCode,
          name: item.name
        }
      });
    }
  }
};
_NavigationService.\u0275fac = function NavigationService_Factory(t) {
  return new (t || _NavigationService)(\u0275\u0275inject(CmsService), \u0275\u0275inject(SemanticPathService));
};
_NavigationService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NavigationService,
  factory: _NavigationService.\u0275fac,
  providedIn: "root"
});
var NavigationService = _NavigationService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: CmsService
  }, {
    type: SemanticPathService
  }], null);
})();
var _NavigationUIComponent = class _NavigationUIComponent {
  onResize() {
    this.resize.next(void 0);
  }
  constructor(router, renderer, elemRef, hamburgerMenuService, winRef) {
    this.router = router;
    this.renderer = renderer;
    this.elemRef = elemRef;
    this.hamburgerMenuService = hamburgerMenuService;
    this.winRef = winRef;
    this.iconType = ICON_TYPE;
    this.flyout = true;
    this.isOpen = false;
    this.openNodes = [];
    this.subscriptions = new Subscription();
    this.resize = new EventEmitter();
    this.subscriptions.add(this.router.events.pipe(filter((event) => event instanceof NavigationEnd)).subscribe(() => this.clear()));
    this.subscriptions.add(this.resize.pipe(debounceTime(50)).subscribe(() => {
      this.alignWrappersToRightIfStickOut();
    }));
  }
  /**
   * During initialization of this component, we will check the resetMenuOnClose flag and attach a menu reset listener if needed.
   */
  ngOnInit() {
    if (this.resetMenuOnClose) {
      this.resetOnMenuCollapse();
    }
  }
  /**
   * This method performs the action of resetting the menu (close all sub menus and return to main options)
   * when the menu is closed.
   */
  resetOnMenuCollapse() {
    this.subscriptions.add(this.hamburgerMenuService?.isExpanded.pipe(distinctUntilChanged(), filter(Boolean)).subscribe(() => {
      this.reinitializeMenu();
    }));
  }
  closeIfClickedTheSameLink(navNode) {
    if (typeof navNode.url === "string" && this.winRef.nativeWindow?.location.href.includes(navNode.url)) {
      this.elemRef.nativeElement.querySelectorAll("li.is-open:not(.back), li.is-opened").forEach((el) => {
        this.renderer.removeClass(el, "is-open");
        this.renderer.removeClass(el, "is-opened");
      });
      this.reinitializeMenu();
      this.hamburgerMenuService.toggle();
    }
  }
  /**
   * This method performs the actions required to reset the state of the menu and reset any visual components.
   */
  reinitializeMenu() {
    if (this.openNodes?.length > 0) {
      this.clear();
      this.renderer.removeClass(this.elemRef.nativeElement, "is-open");
    }
  }
  ariaCollapseNodes() {
    this.openNodes.forEach((parentNode) => {
      Array.from(parentNode.children).filter((childNode) => childNode?.tagName === "BUTTON").forEach((childNode) => {
        this.renderer.setAttribute(childNode, "aria-expanded", "false");
      });
    });
  }
  toggleOpen(event) {
    if (event.type === "keydown") {
      event.preventDefault();
    }
    this.ariaCollapseNodes();
    const node = event.currentTarget;
    const parentNode = node.parentNode;
    if (this.openNodes.includes(parentNode)) {
      if (event.type === "keydown") {
        this.back();
      } else {
        this.openNodes = this.openNodes.filter((n) => n !== parentNode);
        this.renderer.removeClass(parentNode, "is-open");
      }
    } else {
      this.openNodes.push(parentNode);
      this.renderer.setAttribute(node, "aria-expanded", "true");
    }
    this.updateClasses();
    event.stopImmediatePropagation();
    event.stopPropagation();
  }
  back() {
    if (this.openNodes[this.openNodes.length - 1]) {
      this.renderer.removeClass(this.openNodes[this.openNodes.length - 1], "is-open");
      this.openNodes.pop();
      this.updateClasses();
    }
  }
  clear() {
    this.openNodes = [];
    this.updateClasses();
  }
  onMouseEnter(event) {
    this.alignWrapperToRightIfStickOut(event.currentTarget);
    this.focusAfterPreviousClicked(event);
  }
  getTotalDepth(node, depth = 0) {
    if (node.children && node.children.length > 0) {
      return Math.max(...node.children.map((n) => this.getTotalDepth(n, depth + 1)));
    } else {
      return depth;
    }
  }
  getColumnCount(length) {
    return Math.round(length / (this.wrapAfter || length));
  }
  focusAfterPreviousClicked(event) {
    const target = event.target || event.relatedTarget;
    if (target.ownerDocument.activeElement?.matches("nav[tabindex]") && target.parentElement?.matches(".flyout")) {
      target.focus();
    }
    return target.ownerDocument;
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  alignWrapperToRightIfStickOut(node) {
    const wrapper = node.querySelector(".wrapper");
    const body = node.closest("body");
    if (wrapper) {
      this.renderer.removeStyle(wrapper, "margin-left");
      if (wrapper.offsetLeft + wrapper.offsetWidth > body.offsetLeft + body.offsetWidth) {
        this.renderer.setStyle(wrapper, "margin-left", `${node.offsetWidth - wrapper.offsetWidth}px`);
      }
    }
  }
  alignWrappersToRightIfStickOut() {
    const navs = this.elemRef.nativeElement.childNodes;
    Array.from(navs).filter((node) => node.tagName === "LI").forEach((nav) => this.alignWrapperToRightIfStickOut(nav));
  }
  updateClasses() {
    this.openNodes.forEach((node, i) => {
      if (i + 1 < this.openNodes.length) {
        this.renderer.addClass(node, "is-opened");
        this.renderer.removeClass(node, "is-open");
      } else {
        this.renderer.removeClass(node, "is-opened");
        this.renderer.addClass(node, "is-open");
      }
    });
    this.isOpen = this.openNodes.length > 0;
  }
};
_NavigationUIComponent.\u0275fac = function NavigationUIComponent_Factory(t) {
  return new (t || _NavigationUIComponent)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(HamburgerMenuService), \u0275\u0275directiveInject(WindowRef));
};
_NavigationUIComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NavigationUIComponent,
  selectors: [["cx-navigation-ui"]],
  hostVars: 4,
  hostBindings: function NavigationUIComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("resize", function NavigationUIComponent_resize_HostBindingHandler() {
        return ctx.onResize();
      }, false, \u0275\u0275resolveWindow);
    }
    if (rf & 2) {
      \u0275\u0275classProp("flyout", ctx.flyout)("is-open", ctx.isOpen);
    }
  },
  inputs: {
    node: "node",
    wrapAfter: "wrapAfter",
    resetMenuOnClose: "resetMenuOnClose",
    navAriaLabel: "navAriaLabel",
    flyout: "flyout",
    isOpen: "isOpen"
  },
  decls: 6,
  vars: 3,
  consts: [["nav", ""], ["heading", ""], ["title", ""], ["class", "back is-open", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "back", "is-open"], [3, "click"], [3, "type"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "url", "target", "style", "class", "click", 4, "ngIf", "ngIfElse"], ["class", "wrapper", 4, "ngIf"], [3, "click", "url", "target"], [4, "ngIf", "ngIfElse"], [3, "url", "target", "click", 4, "ngIf"], [3, "click", "mouseenter", "keydown.space", "keydown.esc"], [4, "ngIf"], [1, "wrapper"], [1, "childs"]],
  template: function NavigationUIComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nav")(1, "ul");
      \u0275\u0275template(2, NavigationUIComponent_li_2_Template, 5, 4, "li", 3)(3, NavigationUIComponent_ng_container_3_Template, 2, 4, "ng-container", 4);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(4, NavigationUIComponent_ng_template_4_Template, 5, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      let tmp_2_0;
      \u0275\u0275attribute("aria-label", ctx.navAriaLabel);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.flyout && ((tmp_2_0 = ctx.node == null ? null : ctx.node.children == null ? null : ctx.node.children.length) !== null && tmp_2_0 !== void 0 ? tmp_2_0 : 0) > 1);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.node == null ? null : ctx.node.children);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, IconComponent, GenericLinkComponent, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NavigationUIComponent = _NavigationUIComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationUIComponent, [{
    type: Component,
    args: [{
      selector: "cx-navigation-ui",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<nav [attr.aria-label]="navAriaLabel">
  <ul>
    <li
      *ngIf="flyout && (node?.children?.length ?? 0) > 1"
      class="back is-open"
    >
      <button (click)="back()">
        <cx-icon [type]="iconType.CARET_LEFT"></cx-icon>
        {{ 'common.back' | cxTranslate }}
      </button>
    </li>

    <ng-container *ngFor="let child of node?.children">
      <ng-container *ngTemplateOutlet="nav; context: { node: child, depth: 0 }">
      </ng-container>
    </ng-container>
  </ul>
</nav>
<!-- we generate links in a recursive manner -->

<ng-template #nav let-node="node" let-depth="depth">
  <li>
    <cx-generic-link
      *ngIf="
        node.url && (!node.children || node.children?.length === 0);
        else heading
      "
      [url]="node.url"
      [target]="node.target"
      [style]="node.styleAttributes"
      [class]="node.styleClasses"
      (click)="closeIfClickedTheSameLink(node)"
    >
      {{ node.title }}
    </cx-generic-link>

    <ng-template #heading>
      <ng-container *ngIf="flyout && node.children?.length > 0; else title">
        <cx-generic-link
          *ngIf="node.url"
          [url]="node.url"
          [target]="node.target"
          (click)="closeIfClickedTheSameLink(node)"
        >
          {{ node.title }}
        </cx-generic-link>
        <button
          [attr.tabindex]="depth < 1 ? 0 : -1"
          [attr.aria-haspopup]="true"
          [attr.aria-expanded]="false"
          [attr.aria-label]="node.title"
          (click)="toggleOpen($any($event))"
          (mouseenter)="onMouseEnter($event)"
          (keydown.space)="toggleOpen($any($event))"
          (keydown.esc)="back()"
        >
          <ng-container *ngIf="!node.url">
            {{ node.title }}
          </ng-container>
          <cx-icon [type]="iconType.CARET_DOWN"></cx-icon>
        </button>
      </ng-container>
      <ng-template #title>
        <span *ngIf="node.title" [attr.tabindex]="-1">
          {{ node.title }}
        </span>
      </ng-template>
    </ng-template>

    <!-- we add a wrapper to allow for better layout handling in CSS -->
    <div class="wrapper" *ngIf="node.children && node.children.length > 0">
      <ul
        class="childs"
        [attr.depth]="getTotalDepth(node)"
        [attr.wrap-after]="node.children.length > wrapAfter ? wrapAfter : null"
        [attr.columns]="getColumnCount(node.children.length)"
      >
        <ng-container *ngFor="let child of node.children">
          <ng-container
            *ngTemplateOutlet="nav; context: { node: child, depth: depth + 1 }"
          >
          </ng-container>
        </ng-container>
      </ul>
    </div>
  </li>
</ng-template>
`
    }]
  }], () => [{
    type: Router
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: HamburgerMenuService
  }, {
    type: WindowRef
  }], {
    node: [{
      type: Input
    }],
    wrapAfter: [{
      type: Input
    }],
    resetMenuOnClose: [{
      type: Input
    }],
    navAriaLabel: [{
      type: Input
    }],
    flyout: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.flyout"]
    }],
    isOpen: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.is-open"]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize"]
    }]
  });
})();
var _CategoryNavigationComponent = class _CategoryNavigationComponent {
  constructor(componentData, service) {
    this.componentData = componentData;
    this.service = service;
    this.node$ = this.service.getNavigationNode(this.componentData.data$);
    this.data$ = this.componentData.data$;
  }
};
_CategoryNavigationComponent.\u0275fac = function CategoryNavigationComponent_Factory(t) {
  return new (t || _CategoryNavigationComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(NavigationService));
};
_CategoryNavigationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CategoryNavigationComponent,
  selectors: [["cx-category-navigation"]],
  decls: 2,
  vars: 3,
  consts: [[3, "node", "ngClass", "wrapAfter", "resetMenuOnClose", "navAriaLabel", 4, "ngIf"], [3, "node", "ngClass", "wrapAfter", "resetMenuOnClose", "navAriaLabel"]],
  template: function CategoryNavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, CategoryNavigationComponent_cx_navigation_ui_0_Template, 3, 9, "cx-navigation-ui", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.data$));
    }
  },
  dependencies: [NgClass, NgIf, NavigationUIComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var CategoryNavigationComponent = _CategoryNavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryNavigationComponent, [{
    type: Component,
    args: [{
      selector: "cx-category-navigation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<cx-navigation-ui
  *ngIf="data$ | async as data"
  [node]="node$ | async"
  [ngClass]="data.styleClass ?? ''"
  [wrapAfter]="+(data.wrapAfter ?? '')"
  [resetMenuOnClose]="data.resetMenuOnClose"
  [navAriaLabel]="'navigation.categoryNavLabel' | cxTranslate"
></cx-navigation-ui>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: NavigationService
  }], null);
})();
var _NavigationComponent = class _NavigationComponent {
  constructor(componentData, service) {
    this.componentData = componentData;
    this.service = service;
    this.node$ = this.service.createNavigation(this.componentData.data$);
    this.name$ = this.componentData.data$.pipe(map((d) => d?.navigationNode?.title));
    this.styleClass$ = this.componentData.data$.pipe(map((d) => d?.styleClass));
  }
};
_NavigationComponent.\u0275fac = function NavigationComponent_Factory(t) {
  return new (t || _NavigationComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(NavigationService));
};
_NavigationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NavigationComponent,
  selectors: [["cx-navigation"]],
  decls: 4,
  vars: 9,
  consts: [[3, "node", "ngClass", "navAriaLabel"]],
  template: function NavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "cx-navigation-ui", 0);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275pipe(2, "async");
      \u0275\u0275pipe(3, "async");
    }
    if (rf & 2) {
      let tmp_1_0;
      \u0275\u0275property("node", \u0275\u0275pipeBind1(1, 3, ctx.node$))("ngClass", (tmp_1_0 = \u0275\u0275pipeBind1(2, 5, ctx.styleClass$)) !== null && tmp_1_0 !== void 0 ? tmp_1_0 : "")("navAriaLabel", \u0275\u0275pipeBind1(3, 7, ctx.name$));
    }
  },
  dependencies: [NgClass, NavigationUIComponent, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var NavigationComponent = _NavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationComponent, [{
    type: Component,
    args: [{
      selector: "cx-navigation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<cx-navigation-ui
  [node]="node$ | async"
  [ngClass]="(styleClass$ | async) ?? ''"
  [navAriaLabel]="name$ | async"
>
</cx-navigation-ui>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: NavigationService
  }], null);
})();
var _NavigationModule = class _NavigationModule {
};
_NavigationModule.\u0275fac = function NavigationModule_Factory(t) {
  return new (t || _NavigationModule)();
};
_NavigationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NavigationModule
});
_NavigationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      NavigationComponent: {
        component: NavigationComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, IconModule, GenericLinkModule, I18nModule]
});
var NavigationModule = _NavigationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, IconModule, GenericLinkModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          NavigationComponent: {
            component: NavigationComponent
          }
        }
      })],
      declarations: [NavigationComponent, NavigationUIComponent],
      exports: [NavigationComponent, NavigationUIComponent]
    }]
  }], null, null);
})();
var _CategoryNavigationModule = class _CategoryNavigationModule {
};
_CategoryNavigationModule.\u0275fac = function CategoryNavigationModule_Factory(t) {
  return new (t || _CategoryNavigationModule)();
};
_CategoryNavigationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CategoryNavigationModule
});
_CategoryNavigationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      CategoryNavigationComponent: {
        component: CategoryNavigationComponent,
        data: {
          resetMenuOnClose: true
        }
      }
    }
  })],
  imports: [CommonModule, NavigationModule, I18nModule]
});
var CategoryNavigationModule = _CategoryNavigationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NavigationModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          CategoryNavigationComponent: {
            component: CategoryNavigationComponent,
            data: {
              resetMenuOnClose: true
            }
          }
        }
      })],
      declarations: [CategoryNavigationComponent],
      exports: [CategoryNavigationComponent]
    }]
  }], null, null);
})();
var _FooterNavigationComponent = class _FooterNavigationComponent {
  constructor(componentData, service) {
    this.componentData = componentData;
    this.service = service;
    this.node$ = this.service.getNavigationNode(this.componentData.data$);
    this.styleClass$ = this.componentData.data$.pipe(map((d) => d?.styleClass));
  }
};
_FooterNavigationComponent.\u0275fac = function FooterNavigationComponent_Factory(t) {
  return new (t || _FooterNavigationComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(NavigationService));
};
_FooterNavigationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FooterNavigationComponent,
  selectors: [["cx-footer-navigation"]],
  decls: 2,
  vars: 3,
  consts: [[3, "node", "flyout", "ngClass", "navAriaLabel", 4, "ngIf"], [3, "node", "flyout", "ngClass", "navAriaLabel"]],
  template: function FooterNavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, FooterNavigationComponent_cx_navigation_ui_0_Template, 3, 8, "cx-navigation-ui", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.node$));
    }
  },
  dependencies: [NgClass, NgIf, NavigationUIComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var FooterNavigationComponent = _FooterNavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterNavigationComponent, [{
    type: Component,
    args: [{
      selector: "cx-footer-navigation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<cx-navigation-ui
  *ngIf="node$ | async as node"
  [node]="node"
  [flyout]="false"
  [ngClass]="(styleClass$ | async) ?? ''"
  [navAriaLabel]="'navigation.footerNavLabel' | cxTranslate"
></cx-navigation-ui>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: NavigationService
  }], null);
})();
var _FooterNavigationModule = class _FooterNavigationModule {
};
_FooterNavigationModule.\u0275fac = function FooterNavigationModule_Factory(t) {
  return new (t || _FooterNavigationModule)();
};
_FooterNavigationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FooterNavigationModule
});
_FooterNavigationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      FooterNavigationComponent: {
        component: FooterNavigationComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, NavigationModule, GenericLinkModule, I18nModule]
});
var FooterNavigationModule = _FooterNavigationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, NavigationModule, GenericLinkModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          FooterNavigationComponent: {
            component: FooterNavigationComponent
          }
        }
      })],
      declarations: [FooterNavigationComponent],
      exports: [FooterNavigationComponent]
    }]
  }], null, null);
})();
var _PageTitleModule = class _PageTitleModule {
};
_PageTitleModule.\u0275fac = function PageTitleModule_Factory(t) {
  return new (t || _PageTitleModule)();
};
_PageTitleModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PageTitleModule
});
_PageTitleModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      PageTitleComponent: {
        component: PageTitleComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, PageMetaModule]
});
var PageTitleModule = _PageTitleModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageTitleModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PageMetaModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          PageTitleComponent: {
            component: PageTitleComponent
          }
        }
      })],
      declarations: [PageTitleComponent],
      exports: [PageTitleComponent]
    }]
  }], null, null);
})();
var _HighlightPipe = class _HighlightPipe {
  transform(text, match) {
    if (!match) {
      return text;
    }
    return text.replace(match.trim(), `<span class="highlight">${match.trim()}</span>`);
  }
};
_HighlightPipe.\u0275fac = function HighlightPipe_Factory(t) {
  return new (t || _HighlightPipe)();
};
_HighlightPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "cxHighlight",
  type: _HighlightPipe,
  pure: true
});
var HighlightPipe = _HighlightPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighlightPipe, [{
    type: Pipe,
    args: [{
      name: "cxHighlight"
    }]
  }], null, null);
})();
var _SearchBoxSuggestionSelectedEvent = class _SearchBoxSuggestionSelectedEvent extends CxEvent {
};
_SearchBoxSuggestionSelectedEvent.type = "SearchBoxSuggestionSelectedEvent";
var SearchBoxSuggestionSelectedEvent = _SearchBoxSuggestionSelectedEvent;
var _SearchBoxProductSelectedEvent = class _SearchBoxProductSelectedEvent extends CxEvent {
};
_SearchBoxProductSelectedEvent.type = "SearchBoxProductSelectedEvent";
var SearchBoxProductSelectedEvent = _SearchBoxProductSelectedEvent;
var HAS_SEARCH_RESULT_CLASS = "has-searchbox-results";
var _SearchBoxComponentService = class _SearchBoxComponentService {
  constructor(searchService, routingService, translationService, winRef, eventService) {
    this.searchService = searchService;
    this.routingService = routingService;
    this.translationService = translationService;
    this.winRef = winRef;
    this.eventService = eventService;
  }
  /**
   * Executes the search for products and suggestions,
   * unless the configuration is setup to not search for
   * products or suggestions.
   */
  search(query, config) {
    if (!query || query === "") {
      this.clearResults();
      return;
    }
    if (config.minCharactersBeforeRequest && query.length < config.minCharactersBeforeRequest) {
      return;
    }
    if (config.displayProducts) {
      this.searchService.search(query, {
        pageSize: config.maxProducts
      });
    }
    if (config.displaySuggestions) {
      this.searchService.searchSuggestions(query, {
        pageSize: config.maxSuggestions
      });
    }
  }
  /**
   * Returns an observable with the SearchResults. When there's any
   * result, the body tag will get a classname, so that specific style
   * rules can be applied.
   */
  getResults(config) {
    return combineLatest([this.getProductResults(config), this.getProductSuggestions(config), this.getSearchMessage(config)]).pipe(map(([productResults, suggestions, message]) => {
      return {
        products: productResults ? productResults.products : void 0,
        suggestions,
        message
      };
    }), tap((results) => this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, this.hasResults(results))));
  }
  /**
   * Clears the searchbox results, so that old values are
   * no longer emited upon next search.
   */
  clearResults() {
    this.searchService.clearResults();
    this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, false);
  }
  hasBodyClass(className) {
    return this.winRef.document.body.classList.contains(className);
  }
  toggleBodyClass(className, add) {
    if (add === void 0) {
      this.winRef.document.body.classList.toggle(className);
    } else {
      add ? this.winRef.document.body.classList.add(className) : this.winRef.document.body.classList.remove(className);
    }
  }
  /**
   * Dispatches a searchbox event for product selected
   *
   * @param eventData data for the "SearchBoxProductSelectedEvent"
   */
  dispatchProductSelectedEvent(eventData) {
    this.eventService.dispatch({
      freeText: eventData.freeText,
      productCode: eventData.productCode
    }, SearchBoxProductSelectedEvent);
  }
  /**
   * Dispatches a searchbox event for suggestion selected
   *
   * @param eventData data for the "SearchBoxSuggestionSelectedEvent"
   */
  dispatchSuggestionSelectedEvent(eventData) {
    this.eventService.dispatch({
      freeText: eventData.freeText,
      selectedSuggestion: eventData.selectedSuggestion,
      searchSuggestions: eventData.searchSuggestions
    }, SearchBoxSuggestionSelectedEvent);
  }
  /**
   * For search results model, it returns true when:
   * * there is any product OR
   * * the is any search suggestion OR
   * * there is a message.
   *
   * Otherwise it returns false.
   */
  hasResults(results) {
    return !!results.products && results.products.length > 0 || !!results.suggestions && results.suggestions.length > 0 || !!results.message;
  }
  /**
   * Emits product search results in case when the config property `displayProducts` is true.
   * Otherwise it emits an empty object.
   */
  getProductResults(config) {
    if (config.displayProducts) {
      return this.searchService.getResults();
    } else {
      return of({});
    }
  }
  /**
   * Loads suggestions from the backend. In case there's no suggestion
   * available, we try to get an exact match suggestion.
   */
  getProductSuggestions(config) {
    if (!config.displaySuggestions) {
      return of([]);
    } else {
      return this.searchService.getSuggestionResults().pipe(map((res) => res.map((suggestion) => suggestion.value).filter(isNotUndefined)), switchMap((suggestions) => {
        if (suggestions.length === 0) {
          return this.getExactSuggestion(config).pipe(map((match) => match ? [match] : []));
        } else {
          return of(suggestions);
        }
      }));
    }
  }
  /**
   * Whenever there is at least 1 product, we simulate
   * a suggestion to provide easy access to the search result page
   */
  getExactSuggestion(config) {
    return this.getProductResults(config).pipe(switchMap((productResult) => {
      return productResult.products && productResult.products.length > 0 ? this.fetchTranslation("searchBox.help.exactMatch", {
        term: productResult.freeTextSearch
      }) : of(void 0);
    }));
  }
  /**
   * Emits a 'no match' message, in case the product search results and search suggestions are empty.
   * Otherwise it emits null.
   */
  getSearchMessage(config) {
    return combineLatest([this.getProductResults(config), this.getProductSuggestions(config)]).pipe(switchMap(([productResult, suggestions]) => {
      if (productResult && productResult.products && productResult.products.length === 0 && suggestions && suggestions.length === 0) {
        return this.fetchTranslation("searchBox.help.noMatch");
      } else {
        return of(void 0);
      }
    }));
  }
  /**
   * Navigates to the search result page with a given query
   */
  launchSearchPage(query) {
    this.routingService.go({
      cxRoute: "search",
      params: {
        query
      }
    });
  }
  fetchTranslation(translationKey, options) {
    return this.translationService.translate(translationKey, options);
  }
};
_SearchBoxComponentService.\u0275fac = function SearchBoxComponentService_Factory(t) {
  return new (t || _SearchBoxComponentService)(\u0275\u0275inject(SearchboxService), \u0275\u0275inject(RoutingService), \u0275\u0275inject(TranslationService), \u0275\u0275inject(WindowRef), \u0275\u0275inject(EventService));
};
_SearchBoxComponentService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SearchBoxComponentService,
  factory: _SearchBoxComponentService.\u0275fac,
  providedIn: "root"
});
var SearchBoxComponentService = _SearchBoxComponentService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchBoxComponentService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: SearchboxService
  }, {
    type: RoutingService
  }, {
    type: TranslationService
  }, {
    type: WindowRef
  }, {
    type: EventService
  }], null);
})();
var DEFAULT_SEARCH_BOX_CONFIG = {
  minCharactersBeforeRequest: 1,
  displayProducts: true,
  displaySuggestions: true,
  maxProducts: 5,
  maxSuggestions: 5,
  displayProductImages: true
};
var SEARCHBOX_IS_ACTIVE = "searchbox-is-active";
var _SearchBoxComponent = class _SearchBoxComponent {
  /**
   * Sets the search box input field
   */
  set queryText(value) {
    if (value) {
      this.search(value);
    }
  }
  constructor(searchBoxComponentService, componentData, winRef, routingService) {
    this.searchBoxComponentService = searchBoxComponentService;
    this.componentData = componentData;
    this.winRef = winRef;
    this.routingService = routingService;
    this.iconTypes = ICON_TYPE;
    this.ignoreCloseEvent = false;
    this.chosenWord = "";
    this.config$ = (this.componentData?.data$ || of({})).pipe(map((config) => {
      const isBool = (obj, prop) => obj[prop] !== "false" && obj[prop] !== false;
      return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, DEFAULT_SEARCH_BOX_CONFIG), config), {
        displayProducts: isBool(config, "displayProducts"),
        displayProductImages: isBool(config, "displayProductImages"),
        displaySuggestions: isBool(config, "displaySuggestions")
      }), this.config);
    }), tap((config) => this.config = config));
    this.results$ = this.config$.pipe(switchMap((config) => this.searchBoxComponentService.getResults(config)));
  }
  ngOnInit() {
    this.subscription = this.routingService.getRouterState().pipe(filter((data) => !data.nextState)).subscribe((data) => {
      if (!(data.state.context?.id === "search" && data.state.context?.type === PageType.CONTENT_PAGE)) {
        this.chosenWord = "";
      }
    });
  }
  /**
   * Closes the searchBox and opens the search result page.
   */
  search(query) {
    this.searchBoxComponentService.search(query, this.config);
    this.open();
  }
  /**
   * Opens the type-ahead searchBox
   */
  open() {
    this.searchBoxComponentService.toggleBodyClass(SEARCHBOX_IS_ACTIVE, true);
  }
  /**
   * Dispatch UI events for Suggestion selected
   *
   * @param eventData the data for the event
   */
  dispatchSuggestionEvent(eventData) {
    this.searchBoxComponentService.dispatchSuggestionSelectedEvent(eventData);
  }
  /**
   * Dispatch UI events for Product selected
   *
   * @param eventData the data for the event
   */
  dispatchProductEvent(eventData) {
    this.searchBoxComponentService.dispatchProductSelectedEvent(eventData);
  }
  /**
   * Closes the type-ahead searchBox.
   */
  close(event, force) {
    setTimeout(() => {
      if (!this.ignoreCloseEvent && !this.isSearchBoxFocused() || force) {
        this.blurSearchBox(event);
      }
    });
  }
  blurSearchBox(event) {
    this.searchBoxComponentService.toggleBodyClass(SEARCHBOX_IS_ACTIVE, false);
    if (event && event.target) {
      event.target.blur();
    }
  }
  // Check if focus is on searchbox or result list elements
  isSearchBoxFocused() {
    return this.getResultElements().includes(this.getFocusedElement()) || this.winRef.document.querySelector('input[aria-label="Search"]') === this.getFocusedElement();
  }
  /**
   * Especially in mobile we do not want the search icon
   * to focus the input again when it's already open.
   * */
  avoidReopen(event) {
    if (this.searchBoxComponentService.hasBodyClass(SEARCHBOX_IS_ACTIVE)) {
      this.close(event);
      event.preventDefault();
    }
  }
  // Return result list as HTMLElement array
  getResultElements() {
    return Array.from(this.winRef.document.querySelectorAll(".products > li a, .suggestions > li a"));
  }
  // Return focused element as HTMLElement
  getFocusedElement() {
    return this.winRef.document.activeElement;
  }
  updateChosenWord(chosenWord) {
    this.chosenWord = chosenWord;
  }
  getFocusedIndex() {
    return this.getResultElements().indexOf(this.getFocusedElement());
  }
  // Focus on previous item in results list
  focusPreviousChild(event) {
    event.preventDefault();
    const [results, focusedIndex] = [this.getResultElements(), this.getFocusedIndex()];
    if (results.length) {
      if (focusedIndex < 1) {
        results[results.length - 1].focus();
      } else {
        results[focusedIndex - 1].focus();
      }
    }
  }
  // Focus on next item in results list
  focusNextChild(event) {
    this.open();
    event.preventDefault();
    const [results, focusedIndex] = [this.getResultElements(), this.getFocusedIndex()];
    if (results.length) {
      if (focusedIndex >= results.length - 1) {
        results[0].focus();
      } else {
        results[focusedIndex + 1].focus();
      }
    }
  }
  /**
   * Opens the PLP with the given query.
   *
   * TODO: if there's a single product match, we could open the PDP.
   */
  launchSearchResult(event, query) {
    if (!query || query.trim().length === 0) {
      return;
    }
    this.close(event);
    this.searchBoxComponentService.launchSearchPage(query);
  }
  /**
   * Disables closing the search result list.
   */
  disableClose() {
    this.ignoreCloseEvent = true;
  }
  preventDefault(ev) {
    ev.preventDefault();
  }
  /**
   * Clears the search box input field
   */
  clear(el) {
    this.disableClose();
    el.value = "";
    this.searchBoxComponentService.clearResults();
    setTimeout(() => {
      el.focus();
      this.ignoreCloseEvent = false;
    });
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
};
_SearchBoxComponent.\u0275fac = function SearchBoxComponent_Factory(t) {
  return new (t || _SearchBoxComponent)(\u0275\u0275directiveInject(SearchBoxComponentService), \u0275\u0275directiveInject(CmsComponentData, 8), \u0275\u0275directiveInject(WindowRef), \u0275\u0275directiveInject(RoutingService));
};
_SearchBoxComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SearchBoxComponent,
  selectors: [["cx-searchbox"]],
  inputs: {
    config: "config",
    queryText: "queryText"
  },
  decls: 17,
  vars: 24,
  consts: [["searchInput", ""], ["role", "search"], [1, "searchbox"], ["autocomplete", "off", "aria-describedby", "initialDescription", "aria-controls", "results", 3, "focus", "click", "input", "blur", "keydown.escape", "keydown.enter", "keydown.arrowup", "keydown.arrowdown", "placeholder", "value"], [1, "reset", 3, "mousedown", "keydown.enter"], [3, "type"], ["role", "presentation", 1, "search-icon"], [1, "search", 3, "click"], ["class", "results", "id", "results", "role", "dialog", 3, "click", 4, "ngIf"], ["id", "results", "role", "dialog", 1, "results", 3, "click"], ["class", "message", 3, "innerHTML", 4, "ngIf"], ["role", "listbox", 1, "suggestions"], [4, "ngFor", "ngForOf"], ["class", "products", "role", "listbox", 4, "ngIf"], ["id", "initialDescription", 1, "cx-visually-hidden"], ["aria-live", "assertive", "class", "cx-visually-hidden", 4, "ngIf"], [1, "message", 3, "innerHTML"], ["role", "option", 3, "keydown.arrowup", "keydown.arrowdown", "keydown.enter", "keydown.escape", "blur", "mousedown", "click", "innerHTML", "routerLink"], ["role", "listbox", 1, "products"], ["role", "option", 3, "keydown.arrowup", "keydown.arrowdown", "keydown.enter", "keydown.escape", "blur", "mousedown", "click", "routerLink"], ["format", "thumbnail", "role", "presentation", 3, "container", 4, "ngIf"], [1, "name", 3, "innerHTML"], [1, "price"], ["format", "thumbnail", "role", "presentation", 3, "container"], ["aria-live", "assertive", 1, "cx-visually-hidden"]],
  template: function SearchBoxComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 1);
      \u0275\u0275pipe(1, "cxTranslate");
      \u0275\u0275elementStart(2, "label", 2)(3, "input", 3, 0);
      \u0275\u0275pipe(5, "cxTranslate");
      \u0275\u0275pipe(6, "cxTranslate");
      \u0275\u0275listener("focus", function SearchBoxComponent_Template_input_focus_3_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.open());
      })("click", function SearchBoxComponent_Template_input_click_3_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.open());
      })("input", function SearchBoxComponent_Template_input_input_3_listener() {
        \u0275\u0275restoreView(_r1);
        const searchInput_r2 = \u0275\u0275reference(4);
        return \u0275\u0275resetView(ctx.search(searchInput_r2.value));
      })("blur", function SearchBoxComponent_Template_input_blur_3_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.close($event));
      })("keydown.escape", function SearchBoxComponent_Template_input_keydown_escape_3_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.close($event));
      })("keydown.enter", function SearchBoxComponent_Template_input_keydown_enter_3_listener($event) {
        \u0275\u0275restoreView(_r1);
        const searchInput_r2 = \u0275\u0275reference(4);
        ctx.close($event, true);
        ctx.launchSearchResult($event, searchInput_r2.value);
        return \u0275\u0275resetView(ctx.updateChosenWord(searchInput_r2.value));
      })("keydown.arrowup", function SearchBoxComponent_Template_input_keydown_arrowup_3_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.focusPreviousChild($event));
      })("keydown.arrowdown", function SearchBoxComponent_Template_input_keydown_arrowdown_3_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.focusNextChild($event));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "button", 4);
      \u0275\u0275pipe(8, "cxTranslate");
      \u0275\u0275listener("mousedown", function SearchBoxComponent_Template_button_mousedown_7_listener() {
        \u0275\u0275restoreView(_r1);
        const searchInput_r2 = \u0275\u0275reference(4);
        return \u0275\u0275resetView(ctx.clear(searchInput_r2));
      })("keydown.enter", function SearchBoxComponent_Template_button_keydown_enter_7_listener() {
        \u0275\u0275restoreView(_r1);
        const searchInput_r2 = \u0275\u0275reference(4);
        return \u0275\u0275resetView(ctx.clear(searchInput_r2));
      });
      \u0275\u0275element(9, "cx-icon", 5);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(10, "div", 6);
      \u0275\u0275element(11, "cx-icon", 5);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(12, "button", 7);
      \u0275\u0275pipe(13, "cxTranslate");
      \u0275\u0275listener("click", function SearchBoxComponent_Template_button_click_12_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.open());
      });
      \u0275\u0275element(14, "cx-icon", 5);
      \u0275\u0275elementEnd()()();
      \u0275\u0275template(15, SearchBoxComponent_div_15_Template, 10, 10, "div", 8);
      \u0275\u0275pipe(16, "async");
    }
    if (rf & 2) {
      const searchInput_r2 = \u0275\u0275reference(4);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 12, "searchBox.productSearch"));
      \u0275\u0275advance(2);
      \u0275\u0275classProp("dirty", !!searchInput_r2.value);
      \u0275\u0275advance();
      \u0275\u0275propertyInterpolate("value", ctx.chosenWord);
      \u0275\u0275property("placeholder", \u0275\u0275pipeBind1(5, 14, "searchBox.placeholder"));
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(6, 16, "searchBox.placeholder"));
      \u0275\u0275advance(4);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(8, 18, "common.reset"));
      \u0275\u0275advance(2);
      \u0275\u0275property("type", ctx.iconTypes.RESET);
      \u0275\u0275advance(2);
      \u0275\u0275property("type", ctx.iconTypes.SEARCH);
      \u0275\u0275advance();
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(13, 20, "common.search"));
      \u0275\u0275advance(2);
      \u0275\u0275property("type", ctx.iconTypes.SEARCH);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(16, 22, ctx.results$));
    }
  },
  dependencies: [NgForOf, NgIf, RouterLink, MediaComponent, IconComponent, AsyncPipe, UrlPipe, TranslatePipe, HighlightPipe],
  encapsulation: 2,
  changeDetection: 0
});
var SearchBoxComponent = _SearchBoxComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchBoxComponent, [{
    type: Component,
    args: [{
      selector: "cx-searchbox",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div [attr.aria-label]="'searchBox.productSearch' | cxTranslate" role="search">
  <label class="searchbox" [class.dirty]="!!searchInput.value">
    <input
      #searchInput
      [placeholder]="'searchBox.placeholder' | cxTranslate"
      autocomplete="off"
      aria-describedby="initialDescription"
      aria-controls="results"
      [attr.aria-label]="'searchBox.placeholder' | cxTranslate"
      (focus)="open()"
      (click)="open()"
      (input)="search(searchInput.value)"
      (blur)="close($any($event))"
      (keydown.escape)="close($any($event))"
      (keydown.enter)="
        close($any($event), true);
        launchSearchResult($any($event), searchInput.value);
        updateChosenWord(searchInput.value)
      "
      (keydown.arrowup)="focusPreviousChild($any($event))"
      (keydown.arrowdown)="focusNextChild($any($event))"
      value="{{ chosenWord }}"
    />

    <button
      [attr.aria-label]="'common.reset' | cxTranslate"
      (mousedown)="clear(searchInput)"
      (keydown.enter)="clear(searchInput)"
      class="reset"
    >
      <cx-icon [type]="iconTypes.RESET"></cx-icon>
    </button>

    <div role="presentation" class="search-icon">
      <cx-icon [type]="iconTypes.SEARCH"></cx-icon>
    </div>

    <button
      [attr.aria-label]="'common.search' | cxTranslate"
      class="search"
      (click)="open()"
    >
      <cx-icon [type]="iconTypes.SEARCH"></cx-icon>
    </button>
  </label>
</div>

<div
  *ngIf="results$ | async as result"
  class="results"
  id="results"
  (click)="close($any($event), true)"
  role="dialog"
>
  <div
    *ngIf="result.message"
    class="message"
    [innerHTML]="result.message"
  ></div>

  <ul
    class="suggestions"
    attr.aria-label="{{ 'searchBox.ariaLabelSuggestions' | cxTranslate }}"
    role="listbox"
  >
    <li *ngFor="let suggestion of result.suggestions">
      <a
        role="option"
        [innerHTML]="suggestion | cxHighlight: searchInput.value"
        [routerLink]="
          {
            cxRoute: 'search',
            params: { query: suggestion }
          } | cxUrl
        "
        (keydown.arrowup)="focusPreviousChild($any($event))"
        (keydown.arrowdown)="focusNextChild($any($event))"
        (keydown.enter)="close($any($event), true)"
        (keydown.escape)="close($any($event), true)"
        (blur)="close($event)"
        (mousedown)="preventDefault($event)"
        (click)="
          dispatchSuggestionEvent({
            freeText: searchInput.value,
            selectedSuggestion: suggestion,
            searchSuggestions: result.suggestions ?? []
          });
          updateChosenWord(suggestion)
        "
      >
      </a>
    </li>
  </ul>

  <ul
    class="products"
    *ngIf="result.products"
    attr.aria-label="{{ 'searchBox.ariaLabelProducts' | cxTranslate }}"
    role="listbox"
  >
    <li *ngFor="let product of result.products">
      <a
        role="option"
        [routerLink]="
          {
            cxRoute: 'product',
            params: product
          } | cxUrl
        "
        [class.has-media]="config.displayProductImages"
        (keydown.arrowup)="focusPreviousChild($any($event))"
        (keydown.arrowdown)="focusNextChild($any($event))"
        (keydown.enter)="close($any($event), true)"
        (keydown.escape)="close($any($event), true)"
        (blur)="close($any($event))"
        (mousedown)="preventDefault($event)"
        (click)="
          dispatchProductEvent({
            freeText: searchInput.value,
            productCode: product.code
          })
        "
      >
        <cx-media
          *ngIf="config.displayProductImages"
          [container]="product.images?.PRIMARY"
          format="thumbnail"
          role="presentation"
        ></cx-media>
        <div class="name" [innerHTML]="product.nameHtml"></div>
        <span class="price">{{ product.price?.formattedValue }}</span>
      </a>
    </li>
  </ul>
  <span id="initialDescription" class="cx-visually-hidden">
    {{ 'searchBox.initialDescription' | cxTranslate }}
  </span>
  <div
    *ngIf="result.suggestions?.length || result.products?.length"
    aria-live="assertive"
    class="cx-visually-hidden"
  >
    {{
      'searchBox.suggestionsResult'
        | cxTranslate: { count: result.suggestions?.length }
    }}
    {{
      'searchBox.productsResult'
        | cxTranslate: { count: result.products?.length }
    }}
    {{ 'searchBox.initialDescription' | cxTranslate }}
  </div>
</div>
`
    }]
  }], () => [{
    type: SearchBoxComponentService
  }, {
    type: CmsComponentData,
    decorators: [{
      type: Optional
    }]
  }, {
    type: WindowRef
  }, {
    type: RoutingService
  }], {
    config: [{
      type: Input
    }],
    queryText: [{
      type: Input,
      args: ["queryText"]
    }]
  });
})();
var _SearchBoxModule = class _SearchBoxModule {
};
_SearchBoxModule.\u0275fac = function SearchBoxModule_Factory(t) {
  return new (t || _SearchBoxModule)();
};
_SearchBoxModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SearchBoxModule
});
_SearchBoxModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      SearchBoxComponent: {
        component: SearchBoxComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, MediaModule, IconModule, UrlModule, I18nModule]
});
var SearchBoxModule = _SearchBoxModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchBoxModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, MediaModule, IconModule, UrlModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          SearchBoxComponent: {
            component: SearchBoxComponent
          }
        }
      })],
      declarations: [SearchBoxComponent, HighlightPipe],
      exports: [SearchBoxComponent, HighlightPipe]
    }]
  }], null, null);
})();
var _ScrollToTopComponent = class _ScrollToTopComponent {
  onScroll() {
    if (this.window) {
      this.display = this.window.scrollY > this.displayThreshold;
    }
  }
  constructor(winRef, componentData, selectFocusUtility) {
    this.winRef = winRef;
    this.componentData = componentData;
    this.selectFocusUtility = selectFocusUtility;
    this.iconTypes = ICON_TYPE;
    this.window = this.winRef.nativeWindow;
    this.scrollBehavior = ScrollBehavior.SMOOTH;
    this.displayThreshold = (this.window?.innerHeight ?? 400) / 2;
  }
  ngOnInit() {
    this.setConfig();
  }
  setConfig() {
    this.componentData.data$.pipe(take(1)).subscribe((data) => {
      this.scrollBehavior = data.scrollBehavior ?? this.scrollBehavior;
      this.displayThreshold = data.displayThreshold ?? this.displayThreshold;
    });
  }
  /**
   * Scroll back to the top of the page and set focus on top most focusable element.
   */
  scrollToTop() {
    this.selectFocusUtility.findFirstFocusable(this.winRef.document.body, {
      autofocus: ""
    })?.focus();
    this.window?.scrollTo({
      top: 0,
      behavior: this.scrollBehavior
    });
  }
};
_ScrollToTopComponent.\u0275fac = function ScrollToTopComponent_Factory(t) {
  return new (t || _ScrollToTopComponent)(\u0275\u0275directiveInject(WindowRef), \u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(SelectFocusUtility));
};
_ScrollToTopComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ScrollToTopComponent,
  selectors: [["cx-scroll-to-top"]],
  hostVars: 2,
  hostBindings: function ScrollToTopComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("scroll", function ScrollToTopComponent_scroll_HostBindingHandler($event) {
        return ctx.onScroll($event);
      }, false, \u0275\u0275resolveWindow);
    }
    if (rf & 2) {
      \u0275\u0275classProp("display", ctx.display);
    }
  },
  decls: 4,
  vars: 4,
  consts: [[1, "cx-scroll-to-top-btn", 3, "click"], ["aria-hidden", "true"], [1, "caret-up-icon", 3, "type"]],
  template: function ScrollToTopComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275pipe(1, "cxTranslate");
      \u0275\u0275listener("click", function ScrollToTopComponent_Template_button_click_0_listener() {
        return ctx.scrollToTop();
      });
      \u0275\u0275elementStart(2, "span", 1);
      \u0275\u0275element(3, "cx-icon", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(1, 2, "navigation.scrollToTop"));
      \u0275\u0275advance(3);
      \u0275\u0275property("type", ctx.iconTypes.CARET_UP);
    }
  },
  dependencies: [IconComponent, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ScrollToTopComponent = _ScrollToTopComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollToTopComponent, [{
    type: Component,
    args: [{
      selector: "cx-scroll-to-top",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<button
  [attr.aria-label]="'navigation.scrollToTop' | cxTranslate"
  class="cx-scroll-to-top-btn"
  (click)="scrollToTop()"
>
  <span aria-hidden="true">
    <cx-icon class="caret-up-icon" [type]="iconTypes.CARET_UP"></cx-icon>
  </span>
</button>
`
    }]
  }], () => [{
    type: WindowRef
  }, {
    type: CmsComponentData
  }, {
    type: SelectFocusUtility
  }], {
    display: [{
      type: HostBinding,
      args: ["class.display"]
    }],
    onScroll: [{
      type: HostListener,
      args: ["window:scroll", ["$event"]]
    }]
  });
})();
var _ScrollToTopModule = class _ScrollToTopModule {
};
_ScrollToTopModule.\u0275fac = function ScrollToTopModule_Factory(t) {
  return new (t || _ScrollToTopModule)();
};
_ScrollToTopModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ScrollToTopModule
});
_ScrollToTopModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ScrollToTopComponent: {
        component: ScrollToTopComponent
      }
    }
  })],
  imports: [CommonModule, IconModule, I18nModule]
});
var ScrollToTopModule = _ScrollToTopModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollToTopModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, IconModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ScrollToTopComponent: {
            component: ScrollToTopComponent
          }
        }
      })],
      declarations: [ScrollToTopComponent],
      exports: [ScrollToTopComponent]
    }]
  }], null, null);
})();
var _MyAccountV2NavigationComponent = class _MyAccountV2NavigationComponent extends NavigationComponent {
};
_MyAccountV2NavigationComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MyAccountV2NavigationComponent_BaseFactory;
  return function MyAccountV2NavigationComponent_Factory(t) {
    return (\u0275MyAccountV2NavigationComponent_BaseFactory || (\u0275MyAccountV2NavigationComponent_BaseFactory = \u0275\u0275getInheritedFactory(_MyAccountV2NavigationComponent)))(t || _MyAccountV2NavigationComponent);
  };
})();
_MyAccountV2NavigationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MyAccountV2NavigationComponent,
  selectors: [["cx-my-account-v2-navigation"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 3,
  consts: [[3, "node", "flyout", "ngClass", "navAriaLabel", 4, "ngIf"], [3, "node", "flyout", "ngClass", "navAriaLabel"]],
  template: function MyAccountV2NavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, MyAccountV2NavigationComponent_cx_navigation_ui_0_Template, 3, 8, "cx-navigation-ui", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.node$));
    }
  },
  dependencies: [NgClass, NgIf, NavigationUIComponent, AsyncPipe],
  encapsulation: 2
});
var MyAccountV2NavigationComponent = _MyAccountV2NavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyAccountV2NavigationComponent, [{
    type: Component,
    args: [{
      selector: "cx-my-account-v2-navigation",
      template: `<cx-navigation-ui
  *ngIf="node$ | async as node"
  [node]="node"
  [flyout]="false"
  [ngClass]="(styleClass$ | async) ?? ''"
  [navAriaLabel]="name$ | async"
></cx-navigation-ui>
`
    }]
  }], null, null);
})();
var _MyAccountV2NavigationModule = class _MyAccountV2NavigationModule {
};
_MyAccountV2NavigationModule.\u0275fac = function MyAccountV2NavigationModule_Factory(t) {
  return new (t || _MyAccountV2NavigationModule)();
};
_MyAccountV2NavigationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _MyAccountV2NavigationModule
});
_MyAccountV2NavigationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      MyAccountSideNavigationComponent: {
        component: MyAccountV2NavigationComponent,
        guards: [AuthGuard]
      }
    }
  })],
  imports: [CommonModule, NavigationModule, I18nModule]
});
var MyAccountV2NavigationModule = _MyAccountV2NavigationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyAccountV2NavigationModule, [{
    type: NgModule,
    args: [{
      providers: [provideDefaultConfig({
        cmsComponents: {
          MyAccountSideNavigationComponent: {
            component: MyAccountV2NavigationComponent,
            guards: [AuthGuard]
          }
        }
      })],
      declarations: [MyAccountV2NavigationComponent],
      exports: [MyAccountV2NavigationComponent],
      imports: [CommonModule, NavigationModule, I18nModule]
    }]
  }], null, null);
})();
var _MyAccountV2Module = class _MyAccountV2Module {
};
_MyAccountV2Module.\u0275fac = function MyAccountV2Module_Factory(t) {
  return new (t || _MyAccountV2Module)();
};
_MyAccountV2Module.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _MyAccountV2Module
});
_MyAccountV2Module.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [MyAccountV2NavigationModule]
});
var MyAccountV2Module = _MyAccountV2Module;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MyAccountV2Module, [{
    type: NgModule,
    args: [{
      imports: [MyAccountV2NavigationModule]
    }]
  }], null, null);
})();
var _ProductCarouselService = class _ProductCarouselService {
  constructor(productService, semanticPathService) {
    this.productService = productService;
    this.semanticPathService = semanticPathService;
  }
  /**
   * Loads the product data and converts it `CarouselItem`.
   */
  loadProduct(code) {
    return this.productService.get(code).pipe(filter(isNotUndefined), map((product) => this.convertProduct(product)));
  }
  /**
   * Converts the product to a generic CarouselItem
   */
  convertProduct(source, displayTitle = true, displayProductPrices = true) {
    const item = {};
    if (displayTitle) {
      item.title = source.name;
    }
    if (displayProductPrices && source.price && source.price.formattedValue) {
      item.price = source.price.formattedValue;
    }
    if (source.images && source.images.PRIMARY) {
      item.media = {
        container: source.images.PRIMARY,
        format: "product"
      };
    }
    item.route = this.semanticPathService.transform({
      cxRoute: "product",
      params: source
    });
    return item;
  }
};
_ProductCarouselService.\u0275fac = function ProductCarouselService_Factory(t) {
  return new (t || _ProductCarouselService)(\u0275\u0275inject(ProductService), \u0275\u0275inject(SemanticPathService));
};
_ProductCarouselService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ProductCarouselService,
  factory: _ProductCarouselService.\u0275fac,
  providedIn: "root"
});
var ProductCarouselService = _ProductCarouselService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductCarouselService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ProductService
  }, {
    type: SemanticPathService
  }], null);
})();
var _ViewConfig = class _ViewConfig {
};
_ViewConfig.\u0275fac = function ViewConfig_Factory(t) {
  return new (t || _ViewConfig)();
};
_ViewConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ViewConfig,
  factory: function ViewConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _ViewConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var ViewConfig = _ViewConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var _ProductListComponentService = class _ProductListComponentService {
  constructor(productSearchService, routing, activatedRoute, currencyService, languageService, router, config) {
    this.productSearchService = productSearchService;
    this.routing = routing;
    this.activatedRoute = activatedRoute;
    this.currencyService = currencyService;
    this.languageService = languageService;
    this.router = router;
    this.config = config;
    this.RELEVANCE_ALLCATEGORIES = ":relevance:allCategories:";
    this.searchResults$ = this.productSearchService.getResults().pipe(filter((searchResult) => Object.keys(searchResult).length > 0));
    this.searchByRouting$ = combineLatest([this.routing.getRouterState().pipe(distinctUntilChanged((x, y) => {
      return x.state.url === y.state.url;
    })), ...this.siteContext]).pipe(debounceTime(0), map(([routerState, ..._context]) => routerState.state), tap((state) => {
      const criteria = this.getCriteriaFromRoute(state.params, state.queryParams);
      this.searchIfCriteriaHasChanged(criteria);
    }));
    this.model$ = using(() => this.searchByRouting$.subscribe(), () => this.searchResults$).pipe(shareReplay({
      bufferSize: 1,
      refCount: true
    }));
  }
  /**
   * Search only if the previous search criteria does NOT match the new one.
   * This prevents repeating product search calls for queries that already have loaded data.
   */
  searchIfCriteriaHasChanged(criteria) {
    this.productSearchService.getResults().pipe(take(1)).subscribe((results) => {
      const previous = {
        query: results?.currentQuery?.query?.value,
        currentPage: results?.pagination?.currentPage,
        pageSize: results?.pagination?.pageSize,
        sortCode: results?.pagination?.sort
      };
      if (checkQueriesDiffer() || checkCurrentPagesDiffer() || checkPageSizesDiffer() || checkSortCodesDiffer()) {
        this.search(criteria);
      }
      function checkQueriesDiffer() {
        const previousQuery = sanitizeQuery(previous.query, previous.sortCode);
        const currentQuery = sanitizeQuery(criteria.query, criteria.sortCode);
        return previousQuery !== currentQuery;
        function sanitizeQuery(query, sortCode) {
          const DEFAULT_SORT_CODE = "relevance";
          query = query?.replace(":" + DEFAULT_SORT_CODE, "").replace(DEFAULT_SORT_CODE, "");
          if (sortCode) {
            query = query?.replace(":" + sortCode, "").replace(sortCode, "");
          }
          return query;
        }
      }
      function checkCurrentPagesDiffer() {
        const previousPage = previous.currentPage && previous.currentPage > 0 ? previous.currentPage : void 0;
        return previousPage?.toString() !== criteria.currentPage?.toString();
      }
      function checkPageSizesDiffer() {
        return previous.pageSize?.toString() !== criteria.pageSize?.toString();
      }
      function checkSortCodesDiffer() {
        const previousCode = criteria.sortCode ? previous?.sortCode : void 0;
        return previousCode?.toString() !== criteria.sortCode?.toString();
      }
    });
  }
  /**
   * Expose the `SearchCriteria`. The search criteria are driven by the route parameters.
   *
   * This search route configuration is not yet configurable
   * (see https://github.com/SAP/spartacus/issues/7191).
   */
  getCriteriaFromRoute(routeParams, queryParams) {
    return {
      query: queryParams.query || this.getQueryFromRouteParams(routeParams),
      pageSize: queryParams.pageSize || this.config.view?.defaultPageSize,
      currentPage: queryParams.currentPage,
      sortCode: queryParams.sortCode
    };
  }
  /**
   * Resolves the search query from the given `ProductListRouteParams`.
   */
  getQueryFromRouteParams({
    query,
    categoryCode,
    brandCode
  }) {
    if (query) {
      return query;
    }
    if (categoryCode) {
      return this.RELEVANCE_ALLCATEGORIES + categoryCode;
    }
    if (brandCode) {
      return this.RELEVANCE_ALLCATEGORIES + brandCode;
    }
  }
  /**
   * Performs a search based on the given search criteria.
   *
   * The search is delegated to the `ProductSearchService`.
   */
  search(criteria) {
    const currentPage = criteria.currentPage;
    const pageSize = criteria.pageSize;
    const sort = criteria.sortCode;
    this.productSearchService.search(
      criteria.query,
      // TODO: consider dropping this complex passing of cleaned object
      Object.assign({}, currentPage && {
        currentPage
      }, pageSize && {
        pageSize
      }, sort && {
        sort
      })
    );
  }
  /**
   * Get items from a given page without using navigation
   */
  getPageItems(pageNumber) {
    this.routing.getRouterState().subscribe((route) => {
      const routeCriteria = this.getCriteriaFromRoute(route.state.params, route.state.queryParams);
      const criteria = __spreadProps(__spreadValues({}, routeCriteria), {
        currentPage: pageNumber
      });
      this.search(criteria);
    }).unsubscribe();
  }
  /**
   * Sort the search results by the given sort code.
   */
  sort(sortCode) {
    this.route({
      sortCode
    });
  }
  /**
   * Routes to the next product listing page, using the given `queryParams`. The
   * `queryParams` support sorting, pagination and querying.
   *
   * The `queryParams` are delegated to the Angular router `NavigationExtras`.
   */
  route(queryParams) {
    this.router.navigate([], {
      queryParams,
      queryParamsHandling: "merge",
      relativeTo: this.activatedRoute
    });
  }
  /**
   * The site context is used to update the search query in case of a
   * changing context. The context will typically influence the search data.
   *
   * We keep this private for now, as we're likely refactoring this in the next
   * major version.
   */
  get siteContext() {
    return [this.languageService.getActive(), this.currencyService.getActive()];
  }
};
_ProductListComponentService.\u0275fac = function ProductListComponentService_Factory(t) {
  return new (t || _ProductListComponentService)(\u0275\u0275inject(ProductSearchService), \u0275\u0275inject(RoutingService), \u0275\u0275inject(ActivatedRoute), \u0275\u0275inject(CurrencyService), \u0275\u0275inject(LanguageService), \u0275\u0275inject(Router), \u0275\u0275inject(ViewConfig));
};
_ProductListComponentService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ProductListComponentService,
  factory: _ProductListComponentService.\u0275fac,
  providedIn: "root"
});
var ProductListComponentService = _ProductListComponentService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductListComponentService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ProductSearchService
  }, {
    type: RoutingService
  }, {
    type: ActivatedRoute
  }, {
    type: CurrencyService
  }, {
    type: LanguageService
  }, {
    type: Router
  }, {
    type: ViewConfig
  }], null);
})();
var ViewModes;
(function(ViewModes2) {
  ViewModes2["Grid"] = "grid";
  ViewModes2["List"] = "list";
})(ViewModes || (ViewModes = {}));
var _ProductViewComponent = class _ProductViewComponent {
  constructor() {
    this.iconTypes = ICON_TYPE;
    this.modeChange = new EventEmitter();
  }
  get buttonClass() {
    const viewName = this.viewMode?.toLowerCase();
    return `cx-product-${viewName}`;
  }
  /**
   *   Display icons inversely to allow users
   *   to see the view they will navigate to
   */
  get viewMode() {
    if (this.mode === "list") {
      return this.iconTypes.GRID;
    }
    return this.iconTypes.LIST;
  }
  changeMode() {
    const newMode = this.mode === ViewModes.Grid ? ViewModes.List : ViewModes.Grid;
    this.modeChange.emit(newMode);
  }
};
_ProductViewComponent.\u0275fac = function ProductViewComponent_Factory(t) {
  return new (t || _ProductViewComponent)();
};
_ProductViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductViewComponent,
  selectors: [["cx-product-view"]],
  inputs: {
    mode: "mode"
  },
  outputs: {
    modeChange: "modeChange"
  },
  decls: 5,
  vars: 8,
  consts: [["tabindex", "0", 1, "btn", "cx-product-layout", 3, "click", "ngClass"], [3, "type", 4, "ngIf"], [3, "type"]],
  template: function ProductViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275pipe(1, "cxTranslate");
      \u0275\u0275pipe(2, "cxTranslate");
      \u0275\u0275listener("click", function ProductViewComponent_Template_button_click_0_listener() {
        return ctx.changeMode();
      });
      \u0275\u0275template(3, ProductViewComponent_cx_icon_3_Template, 1, 1, "cx-icon", 1)(4, ProductViewComponent_cx_icon_4_Template, 1, 1, "cx-icon", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngClass", ctx.buttonClass);
      \u0275\u0275attribute("aria-label", ctx.viewMode === ctx.iconTypes.GRID ? \u0275\u0275pipeBind1(1, 4, "productView.gridView") : ctx.viewMode === ctx.iconTypes.LIST ? \u0275\u0275pipeBind1(2, 6, "productView.listView") : null);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.viewMode === ctx.iconTypes.GRID);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.viewMode === ctx.iconTypes.LIST);
    }
  },
  dependencies: [NgClass, NgIf, IconComponent, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductViewComponent = _ProductViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductViewComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-view",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<button
  class="btn cx-product-layout"
  [ngClass]="buttonClass"
  (click)="changeMode()"
  tabindex="0"
  attr.aria-label="{{
    viewMode === iconTypes.GRID
      ? ('productView.gridView' | cxTranslate)
      : viewMode === iconTypes.LIST
      ? ('productView.listView' | cxTranslate)
      : null
  }}"
>
  <cx-icon
    *ngIf="viewMode === iconTypes.GRID"
    [type]="iconTypes.GRID"
  ></cx-icon>
  <cx-icon
    *ngIf="viewMode === iconTypes.LIST"
    [type]="iconTypes.LIST"
  ></cx-icon>
</button>
`
    }]
  }], null, {
    mode: [{
      type: Input
    }],
    modeChange: [{
      type: Output
    }]
  });
})();
var ProductDetailOutlets;
(function(ProductDetailOutlets2) {
  ProductDetailOutlets2["INTRO"] = "PDP.INTRO";
  ProductDetailOutlets2["PRICE"] = "PDP.PRICE";
  ProductDetailOutlets2["SHARE"] = "PDP.SHARE";
  ProductDetailOutlets2["SUMMARY"] = "PDP.SUMMARY";
})(ProductDetailOutlets || (ProductDetailOutlets = {}));
var ProductListOutlets;
(function(ProductListOutlets2) {
  ProductListOutlets2["ITEM_ACTIONS"] = "cx-product-list-item.actions";
  ProductListOutlets2["ITEM_DETAILS"] = "cx-product-list-item.details";
})(ProductListOutlets || (ProductListOutlets = {}));
var _ProductListItemContext = class _ProductListItemContext {
};
_ProductListItemContext.\u0275fac = function ProductListItemContext_Factory(t) {
  return new (t || _ProductListItemContext)();
};
_ProductListItemContext.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ProductListItemContext,
  factory: _ProductListItemContext.\u0275fac
});
var ProductListItemContext = _ProductListItemContext;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductListItemContext, [{
    type: Injectable
  }], null, null);
})();
var _ProductListItemContextSource = class _ProductListItemContextSource extends ProductListItemContext {
  constructor() {
    super(...arguments);
    this.product$ = new ReplaySubject(1);
  }
};
_ProductListItemContextSource.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275ProductListItemContextSource_BaseFactory;
  return function ProductListItemContextSource_Factory(t) {
    return (\u0275ProductListItemContextSource_BaseFactory || (\u0275ProductListItemContextSource_BaseFactory = \u0275\u0275getInheritedFactory(_ProductListItemContextSource)))(t || _ProductListItemContextSource);
  };
})();
_ProductListItemContextSource.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ProductListItemContextSource,
  factory: _ProductListItemContextSource.\u0275fac
});
var ProductListItemContextSource = _ProductListItemContextSource;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductListItemContextSource, [{
    type: Injectable
  }], null, null);
})();
var _ProductListItemComponent = class _ProductListItemComponent {
  constructor(productListItemContextSource) {
    this.productListItemContextSource = productListItemContextSource;
    this.ProductListOutlets = ProductListOutlets;
  }
  ngOnChanges(changes) {
    if (changes?.product) {
      this.productListItemContextSource.product$.next(this.product);
    }
  }
};
_ProductListItemComponent.\u0275fac = function ProductListItemComponent_Factory(t) {
  return new (t || _ProductListItemComponent)(\u0275\u0275directiveInject(ProductListItemContextSource));
};
_ProductListItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductListItemComponent,
  selectors: [["cx-product-list-item"]],
  inputs: {
    product: "product"
  },
  features: [\u0275\u0275ProvidersFeature([ProductListItemContextSource, {
    provide: ProductListItemContext,
    useExisting: ProductListItemContextSource
  }]), \u0275\u0275NgOnChangesFeature],
  decls: 17,
  vars: 23,
  consts: [[1, "row"], [1, "col-12", "col-md-4"], [1, "cx-product-image-container", 3, "routerLink"], ["format", "product", 1, "cx-product-image", 3, "container", "alt"], [1, "col-12", "col-md-8"], [1, "cx-product-name", 3, "routerLink"], [3, "innerHtml"], [3, "cxOutlet"], [1, "col-12", "col-md-7", "col-xl-7"], [1, "cx-product-summary", 3, "innerHtml"], [1, "col-12", "col-md-5", "col-xl-5"], [3, "rating", 4, "ngIf"], ["class", "cx-product-no-review", 4, "ngIf"], [1, "cx-product-price"], [3, "rating"], [1, "cx-product-no-review"], ["cxInnerComponentsHost", ""]],
  template: function ProductListItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "a", 2);
      \u0275\u0275pipe(3, "cxUrl");
      \u0275\u0275pipe(4, "cxTranslate");
      \u0275\u0275element(5, "cx-media", 3);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(6, "div", 4)(7, "a", 5);
      \u0275\u0275pipe(8, "cxUrl");
      \u0275\u0275element(9, "h2", 6);
      \u0275\u0275elementEnd();
      \u0275\u0275template(10, ProductListItemComponent_ng_template_10_Template, 5, 6, "ng-template", 7);
      \u0275\u0275elementStart(11, "div", 0)(12, "div", 8)(13, "p", 9);
      \u0275\u0275text(14);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(15, "div", 10);
      \u0275\u0275template(16, ProductListItemComponent_ng_template_16_Template, 1, 0, "ng-template", 7);
      \u0275\u0275elementEnd()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(3, 10, \u0275\u0275pureFunction1(17, _c31, ctx.product)));
      \u0275\u0275attribute("aria-label", !(ctx.product.images == null ? null : ctx.product.images.hasOwnProperty("PRIMARY")) ? \u0275\u0275pipeBind2(4, 12, "productDetails.noProductImage", \u0275\u0275pureFunction1(19, _c39, ctx.product.name)) : void 0);
      \u0275\u0275advance(3);
      \u0275\u0275property("container", ctx.product.images == null ? null : ctx.product.images.PRIMARY)("alt", ctx.product.name || ctx.product.summary);
      \u0275\u0275advance(2);
      \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(8, 15, \u0275\u0275pureFunction1(21, _c31, ctx.product)));
      \u0275\u0275advance(2);
      \u0275\u0275property("innerHtml", ctx.product.nameHtml, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance();
      \u0275\u0275property("cxOutlet", ctx.ProductListOutlets.ITEM_DETAILS);
      \u0275\u0275advance(3);
      \u0275\u0275property("innerHtml", ctx.product.summary, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.product.summary, " ");
      \u0275\u0275advance(2);
      \u0275\u0275property("cxOutlet", ctx.ProductListOutlets.ITEM_ACTIONS);
    }
  },
  dependencies: [NgIf, MediaComponent, OutletDirective, InnerComponentsHostDirective, RouterLink, StarRatingComponent, TranslatePipe, UrlPipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductListItemComponent = _ProductListItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductListItemComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-list-item",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ProductListItemContextSource, {
        provide: ProductListItemContext,
        useExisting: ProductListItemContextSource
      }],
      template: `<div class="row">
  <div class="col-12 col-md-4">
    <a
      [attr.aria-label]="
        !product.images?.hasOwnProperty('PRIMARY')
          ? ('productDetails.noProductImage'
            | cxTranslate: { product: product.name })
          : undefined
      "
      [routerLink]="{ cxRoute: 'product', params: product } | cxUrl"
      class="cx-product-image-container"
    >
      <cx-media
        class="cx-product-image"
        [container]="product.images?.PRIMARY"
        format="product"
        [alt]="product.name || product.summary"
      ></cx-media>
    </a>
  </div>
  <div class="col-12 col-md-8">
    <a
      [routerLink]="{ cxRoute: 'product', params: product } | cxUrl"
      class="cx-product-name"
    >
      <h2 [innerHtml]="product.nameHtml"></h2>
    </a>

    <ng-template [cxOutlet]="ProductListOutlets.ITEM_DETAILS">
      <cx-star-rating
        *ngIf="product.averageRating"
        [rating]="product?.averageRating"
      ></cx-star-rating>
      <div *ngIf="!product.averageRating" class="cx-product-no-review">
        {{ 'productDetails.noReviews' | cxTranslate }}
      </div>
      <div
        class="cx-product-price"
        [attr.aria-label]="'productDetails.productPrice' | cxTranslate"
      >
        {{ product.price?.formattedValue }}
      </div>
    </ng-template>

    <div class="row">
      <div class="col-12 col-md-7 col-xl-7">
        <p class="cx-product-summary" [innerHtml]="product.summary">
          {{ product.summary }}
        </p>
      </div>
      <div class="col-12 col-md-5 col-xl-5">
        <ng-template [cxOutlet]="ProductListOutlets.ITEM_ACTIONS">
          <ng-container cxInnerComponentsHost></ng-container>
        </ng-template>
      </div>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: ProductListItemContextSource
  }], {
    product: [{
      type: Input
    }]
  });
})();
var _ProductGridItemComponent = class _ProductGridItemComponent {
  constructor(productListItemContextSource) {
    this.productListItemContextSource = productListItemContextSource;
    this.ProductListOutlets = ProductListOutlets;
  }
  ngOnChanges(changes) {
    if (changes?.product) {
      this.productListItemContextSource.product$.next(this.product);
    }
  }
};
_ProductGridItemComponent.\u0275fac = function ProductGridItemComponent_Factory(t) {
  return new (t || _ProductGridItemComponent)(\u0275\u0275directiveInject(ProductListItemContextSource));
};
_ProductGridItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductGridItemComponent,
  selectors: [["cx-product-grid-item"]],
  inputs: {
    product: "product"
  },
  features: [\u0275\u0275ProvidersFeature([ProductListItemContextSource, {
    provide: ProductListItemContext,
    useExisting: ProductListItemContextSource
  }]), \u0275\u0275NgOnChangesFeature],
  decls: 7,
  vars: 15,
  consts: [["tabindex", "-1", 1, "cx-product-image-container", 3, "routerLink"], ["format", "product", 1, "cx-product-image", 3, "container", "alt"], [1, "cx-product-name", 3, "routerLink", "innerHTML"], [3, "cxOutlet"], [1, "cx-product-rating"], [3, "rating", 4, "ngIf"], [4, "ngIf"], [1, "cx-product-price-container"], [1, "cx-product-price"], [3, "rating"], ["cxInnerComponentsHost", ""]],
  template: function ProductGridItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "a", 0);
      \u0275\u0275pipe(1, "cxUrl");
      \u0275\u0275element(2, "cx-media", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275element(3, "a", 2);
      \u0275\u0275pipe(4, "cxUrl");
      \u0275\u0275template(5, ProductGridItemComponent_ng_template_5_Template, 7, 6, "ng-template", 3)(6, ProductGridItemComponent_ng_template_6_Template, 1, 0, "ng-template", 3);
    }
    if (rf & 2) {
      \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(1, 7, \u0275\u0275pureFunction1(11, _c31, ctx.product)));
      \u0275\u0275advance(2);
      \u0275\u0275property("container", ctx.product.images == null ? null : ctx.product.images.PRIMARY)("alt", ctx.product.summary);
      \u0275\u0275advance();
      \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(4, 9, \u0275\u0275pureFunction1(13, _c31, ctx.product)))("innerHTML", ctx.product.nameHtml, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance(2);
      \u0275\u0275property("cxOutlet", ctx.ProductListOutlets.ITEM_DETAILS);
      \u0275\u0275advance();
      \u0275\u0275property("cxOutlet", ctx.ProductListOutlets.ITEM_ACTIONS);
    }
  },
  dependencies: [NgIf, MediaComponent, OutletDirective, InnerComponentsHostDirective, RouterLink, StarRatingComponent, TranslatePipe, UrlPipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductGridItemComponent = _ProductGridItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductGridItemComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-grid-item",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ProductListItemContextSource, {
        provide: ProductListItemContext,
        useExisting: ProductListItemContextSource
      }],
      template: `<a
  [routerLink]="{ cxRoute: 'product', params: product } | cxUrl"
  class="cx-product-image-container"
  tabindex="-1"
>
  <cx-media
    class="cx-product-image"
    [container]="product.images?.PRIMARY"
    format="product"
    [alt]="product.summary"
  ></cx-media>
</a>
<a
  [routerLink]="{ cxRoute: 'product', params: product } | cxUrl"
  class="cx-product-name"
  [innerHTML]="product.nameHtml"
></a>

<ng-template [cxOutlet]="ProductListOutlets.ITEM_DETAILS">
  <div class="cx-product-rating">
    <cx-star-rating
      *ngIf="product.averageRating"
      [rating]="product?.averageRating"
    ></cx-star-rating>
    <div *ngIf="!product.averageRating">
      {{ 'productDetails.noReviews' | cxTranslate }}
    </div>
  </div>
  <div class="cx-product-price-container">
    <div
      class="cx-product-price"
      [attr.aria-label]="'productDetails.productPrice' | cxTranslate"
    >
      {{ product.price?.formattedValue }}
    </div>
  </div>
</ng-template>

<ng-template [cxOutlet]="ProductListOutlets.ITEM_ACTIONS">
  <ng-container cxInnerComponentsHost></ng-container>
</ng-template>
`
    }]
  }], () => [{
    type: ProductListItemContextSource
  }], {
    product: [{
      type: Input
    }]
  });
})();
var _ProductScrollComponent = class _ProductScrollComponent {
  set setConfig(inputConfig) {
    this.setComponentConfigurations(inputConfig);
  }
  set setModel(inputModel) {
    this.infiniteScrollOperations(inputModel);
  }
  set setViewMode(inputViewMode) {
    this.inputViewMode = inputViewMode;
    if (this.viewMode) {
      this.resetListOnViewModeChange();
    } else {
      this.viewMode = inputViewMode;
    }
  }
  constructor(productListComponentService, ref) {
    this.productListComponentService = productListComponentService;
    this.ref = ref;
    this.subscription = new Subscription();
    this.ViewModes = ViewModes;
    this.appendProducts = false;
    this.resetList = false;
    this.isMaxProducts = false;
    this.isLastPage = false;
    this.isEmpty = false;
  }
  scrollPage(pageNumber) {
    this.appendProducts = true;
    this.ref.markForCheck();
    this.productListComponentService.getPageItems(pageNumber);
  }
  loadNextPage(pageNumber) {
    this.isMaxProducts = false;
    this.scrollPage(pageNumber);
  }
  scrollToTop() {
    window.scroll(0, 0);
  }
  setComponentConfigurations(scrollConfig) {
    const isButton = scrollConfig.view?.infiniteScroll?.showMoreButton;
    const configProductLimit = scrollConfig.view?.infiniteScroll?.productLimit;
    this.productLimit = isButton ? 1 : configProductLimit;
  }
  infiniteScrollOperations(inputModel) {
    if (this.appendProducts) {
      this.model = __spreadProps(__spreadValues({}, inputModel), {
        products: this.model.products?.concat(inputModel.products ?? [])
      });
    } else {
      this.model = inputModel;
      this.maxProducts = this.productLimit;
    }
    this.setConditions();
    this.ref.markForCheck();
  }
  resetListOnViewModeChange() {
    this.scrollToTop();
    this.resetList = true;
    this.productListComponentService.getPageItems(0);
  }
  //Set booleans after model has been retrieved
  setConditions() {
    this.isEmpty = !this.model.products || this.model.products.length === 0;
    this.isLastPage = this.model.pagination?.currentPage === (this.model.pagination?.totalPages ?? 0) - 1;
    if (this.model.products) {
      this.isMaxProducts = this.productLimit !== void 0 && this.productLimit !== 0 && this.model.products.length >= (this.maxProducts ?? 0);
      if (this.isMaxProducts) {
        this.maxProducts = this.model.products.length + (this.productLimit ?? 0);
      }
    }
    if (this.viewMode !== this.inputViewMode) {
      this.viewMode = this.inputViewMode;
    }
    this.resetList = false;
    this.appendProducts = false;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_ProductScrollComponent.\u0275fac = function ProductScrollComponent_Factory(t) {
  return new (t || _ProductScrollComponent)(\u0275\u0275directiveInject(ProductListComponentService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ProductScrollComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductScrollComponent,
  selectors: [["cx-product-scroll"]],
  inputs: {
    setConfig: [InputFlags.None, "scrollConfig", "setConfig"],
    setModel: [InputFlags.None, "model", "setModel"],
    setViewMode: [InputFlags.None, "inputViewMode", "setViewMode"]
  },
  decls: 2,
  vars: 2,
  consts: [[4, "ngIf"], ["infiniteScroll", "", 3, "scrolled", "infiniteScrollDistance", "infiniteScrollThrottle", "infiniteScrollDisabled"], [1, "row"], ["class", "col-12 col-sm-6 col-md-4", 3, "product", 4, "ngFor", "ngForOf"], [3, "className"], ["class", "btn btn-block btn-secondary", 3, "click", 4, "ngIf"], ["class", "btn btn-block btn-secondary align-btn", 3, "click", 4, "ngIf"], ["class", "cx-spinner", 4, "ngIf"], [1, "col-12", "col-sm-6", "col-md-4", 3, "product"], [1, "btn", "btn-block", "btn-secondary", 3, "click"], [1, "btn", "btn-block", "btn-secondary", "align-btn", 3, "click"], [1, "cx-spinner"], ["class", "cx-product-search-list", 3, "product", 4, "ngFor", "ngForOf"], [1, "cx-product-search-list", 3, "product"]],
  template: function ProductScrollComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductScrollComponent_ng_container_0_Template, 8, 8, "ng-container", 0)(1, ProductScrollComponent_ng_container_1_Template, 7, 8, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.viewMode === ctx.ViewModes.Grid);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.viewMode === ctx.ViewModes.List);
    }
  },
  dependencies: [NgForOf, NgIf, InfiniteScrollDirective, SpinnerComponent, ProductListItemComponent, ProductGridItemComponent, TranslatePipe],
  encapsulation: 2
});
var ProductScrollComponent = _ProductScrollComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductScrollComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-scroll",
      template: `<ng-container *ngIf="viewMode === ViewModes.Grid">
  <div
    infiniteScroll
    [infiniteScrollDistance]="5"
    [infiniteScrollThrottle]="50"
    [infiniteScrollDisabled]="isMaxProducts || isLastPage || isEmpty"
    (scrolled)="scrollPage((model?.pagination?.currentPage ?? 0) + 1)"
  >
    <div class="row">
      <cx-product-grid-item
        *ngFor="let product of model?.products"
        [product]="product"
        class="col-12 col-sm-6 col-md-4"
      ></cx-product-grid-item>
    </div>
    <div
      [className]="
        !isLastPage && (model?.pagination?.currentPage ?? 0) > 0
          ? 'cx-double-btn-container grid-btn-padding'
          : 'cx-single-btn-container grid-btn-padding'
      "
    >
      <div
        *ngIf="
          (isMaxProducts || isLastPage) &&
          (model?.pagination?.currentPage ?? 0) > 0
        "
        (click)="scrollToTop()"
        class="btn btn-block btn-secondary"
      >
        {{ 'productList.backToTopBtn' | cxTranslate }}
      </div>
      <div
        *ngIf="isMaxProducts && !isLastPage"
        (click)="loadNextPage((model?.pagination?.currentPage ?? 0) + 1)"
        class="btn btn-block btn-secondary align-btn"
      >
        {{ 'productList.showMoreBtn' | cxTranslate }}
      </div>
    </div>
    <div *ngIf="appendProducts" class="cx-spinner">
      <cx-spinner></cx-spinner>
    </div>
  </div>
</ng-container>

<ng-container *ngIf="viewMode === ViewModes.List">
  <div
    infiniteScroll
    [infiniteScrollDistance]="3"
    [infiniteScrollThrottle]="50"
    [infiniteScrollDisabled]="isMaxProducts || isLastPage || isEmpty"
    (scrolled)="scrollPage((model?.pagination?.currentPage ?? 0) + 1)"
  >
    <cx-product-list-item
      *ngFor="let product of model?.products"
      [product]="product"
      class="cx-product-search-list"
    ></cx-product-list-item>
    <div
      [className]="
        !isLastPage && (model?.pagination?.currentPage ?? 0) > 0
          ? 'cx-double-btn-container'
          : 'cx-single-btn-container'
      "
    >
      <div
        *ngIf="
          (isMaxProducts || isLastPage) &&
          (model?.pagination?.currentPage ?? 0) > 0
        "
        (click)="scrollToTop()"
        class="btn btn-block btn-secondary"
      >
        {{ 'productList.backToTopBtn' | cxTranslate }}
      </div>
      <div
        *ngIf="isMaxProducts && !isLastPage"
        (click)="loadNextPage((model?.pagination?.currentPage ?? 0) + 1)"
        class="btn btn-block btn-secondary align-btn"
      >
        {{ 'productList.showMoreBtn' | cxTranslate }}
      </div>
    </div>
    <div *ngIf="appendProducts" class="cx-spinner">
      <cx-spinner></cx-spinner>
    </div>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: ProductListComponentService
  }, {
    type: ChangeDetectorRef
  }], {
    setConfig: [{
      type: Input,
      args: ["scrollConfig"]
    }],
    setModel: [{
      type: Input,
      args: ["model"]
    }],
    setViewMode: [{
      type: Input,
      args: ["inputViewMode"]
    }]
  });
})();
var _ProductListComponent = class _ProductListComponent {
  constructor(pageLayoutService, productListComponentService, globalMessageService, scrollConfig) {
    this.pageLayoutService = pageLayoutService;
    this.productListComponentService = productListComponentService;
    this.globalMessageService = globalMessageService;
    this.scrollConfig = scrollConfig;
    this.subscription = new Subscription();
    this.model$ = this.productListComponentService.model$;
    this.viewMode$ = new BehaviorSubject(ViewModes.Grid);
    this.ViewModes = ViewModes;
  }
  ngOnInit() {
    this.isInfiniteScroll = this.scrollConfig.view?.infiniteScroll?.active;
    this.subscription.add(this.pageLayoutService.templateName$.pipe(take(1)).subscribe((template) => {
      this.viewMode$.next(template === "ProductGridPageTemplate" ? ViewModes.Grid : ViewModes.List);
    }));
    this.subscription.add(combineLatest([this.model$, this.viewMode$]).pipe(skip(1), filter(([model, mode]) => !!model && !!mode)).subscribe(() => this.globalMessageService.add({
      key: "sorting.pageViewUpdated"
    }, GlobalMessageType.MSG_TYPE_ASSISTIVE, 500)));
  }
  sortList(sortCode) {
    this.productListComponentService.sort(sortCode);
  }
  setViewMode(mode) {
    this.viewMode$.next(mode);
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_ProductListComponent.\u0275fac = function ProductListComponent_Factory(t) {
  return new (t || _ProductListComponent)(\u0275\u0275directiveInject(PageLayoutService), \u0275\u0275directiveInject(ProductListComponentService), \u0275\u0275directiveInject(GlobalMessageService), \u0275\u0275directiveInject(ViewConfig));
};
_ProductListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductListComponent,
  selectors: [["cx-product-list"]],
  decls: 2,
  vars: 3,
  consts: [["infiniteScroll", ""], ["class", "cx-page", 4, "ngIf"], [1, "cx-page"], ["tabindex", "-1", 1, "cx-page-section"], [1, "container"], [1, "row"], ["class", "col-12 col-lg-12", 4, "ngIf"], [1, "col-12", "col-lg-12"], [1, "cx-sorting", "top"], [1, "form-group", "cx-sort-dropdown", "col-12", "col-lg-4", "mr-auto"], ["ariaControls", "product-results-list", 3, "sortListEvent", "sortOptions", "selectedOption", "ariaLabel", "placeholder"], ["class", "col-auto", 4, "ngIf"], [1, "col-auto", "ml-auto", "ml-lg-0"], [3, "modeChange", "mode"], ["id", "product-results-list", 1, "cx-product-container"], [4, "ngIf", "ngIfElse"], [1, "cx-sorting", "bottom"], [1, "col-auto"], [1, "cx-pagination"], ["queryParam", "currentPage", 3, "pagination", "defaultPage"], [4, "ngIf"], ["class", "col-12 col-sm-6 col-md-4", 3, "product", 4, "ngFor", "ngForOf"], [1, "col-12", "col-sm-6", "col-md-4", 3, "product"], ["class", "cx-product-search-list", 3, "product", 4, "ngFor", "ngForOf"], [1, "cx-product-search-list", 3, "product"], [3, "scrollConfig", "model", "inputViewMode"]],
  template: function ProductListComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductListComponent_div_0_Template, 7, 6, "div", 1);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.model$));
    }
  },
  dependencies: [NgForOf, NgIf, SortingComponent, PaginationComponent, ProductListItemComponent, ProductGridItemComponent, ProductViewComponent, ProductScrollComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var ProductListComponent = _ProductListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductListComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-list",
      template: `<div class="cx-page" *ngIf="model$ | async as model">
  <section
    tabindex="-1"
    class="cx-page-section"
    [attr.aria-label]="'productList.productListResults' | cxTranslate"
  >
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-12" *ngIf="viewMode$ | async as viewMode">
          <div class="cx-sorting top">
            <div class="row">
              <label
                class="form-group cx-sort-dropdown col-12 col-lg-4 mr-auto"
              >
                <span>{{ 'productList.sortBy' | cxTranslate }}</span>
                <cx-sorting
                  [sortOptions]="model.sorts"
                  (sortListEvent)="sortList($event)"
                  [selectedOption]="model.pagination?.sort"
                  [ariaLabel]="'productList.sortResults' | cxTranslate"
                  ariaControls="product-results-list"
                  placeholder="{{ 'productList.sortBy' | cxTranslate }}"
                ></cx-sorting>
              </label>
              <div *ngIf="!isInfiniteScroll" class="col-auto">
                <div
                  class="cx-pagination"
                  [attr.aria-label]="
                    'productList.productSearchPagination' | cxTranslate
                  "
                >
                  <cx-pagination
                    [pagination]="model.pagination"
                    queryParam="currentPage"
                    [defaultPage]="0"
                  ></cx-pagination>
                </div>
              </div>
              <div class="col-auto ml-auto ml-lg-0">
                <cx-product-view
                  (modeChange)="setViewMode($event)"
                  [mode]="viewMode"
                ></cx-product-view>
              </div>
            </div>
          </div>
          <div id="product-results-list" class="cx-product-container">
            <!-- Product list when using pagination -->
            <ng-container *ngIf="!isInfiniteScroll; else infiniteScroll">
              <ng-container *ngIf="viewMode === ViewModes.Grid">
                <div class="row">
                  <cx-product-grid-item
                    *ngFor="let product of model?.products"
                    [product]="product"
                    class="col-12 col-sm-6 col-md-4"
                  ></cx-product-grid-item>
                </div>
              </ng-container>

              <ng-container *ngIf="viewMode === ViewModes.List">
                <cx-product-list-item
                  *ngFor="let product of model?.products"
                  [product]="product"
                  class="cx-product-search-list"
                ></cx-product-list-item>
              </ng-container>
            </ng-container>

            <!-- Product list when using infinite scroll -->
            <ng-template #infiniteScroll>
              <cx-product-scroll
                [scrollConfig]="scrollConfig"
                [model]="model"
                [inputViewMode]="viewMode"
              ></cx-product-scroll>
            </ng-template>
          </div>
          <div class="cx-sorting bottom">
            <div class="row">
              <label
                class="form-group cx-sort-dropdown col-12 col-lg-4 mr-auto"
              >
                <span>{{ 'productList.sortBy' | cxTranslate }}</span>
                <cx-sorting
                  [sortOptions]="model.sorts"
                  (sortListEvent)="sortList($event)"
                  [selectedOption]="model.pagination?.sort"
                  [ariaLabel]="'productList.sortResults' | cxTranslate"
                  ariaControls="product-results-list"
                  placeholder="{{ 'productList.sortBy' | cxTranslate }}"
                ></cx-sorting>
              </label>
              <div
                *ngIf="!isInfiniteScroll"
                class="col-auto"
                [attr.aria-label]="
                  'productList.productSearchPagination' | cxTranslate
                "
              >
                <div class="cx-pagination">
                  <cx-pagination
                    [pagination]="model.pagination"
                    queryParam="currentPage"
                    [defaultPage]="0"
                  ></cx-pagination>
                </div>
              </div>
              <div class="col-auto ml-auto ml-lg-0">
                <cx-product-view
                  (modeChange)="setViewMode($event)"
                  [mode]="viewMode"
                ></cx-product-view>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>
`
    }]
  }], () => [{
    type: PageLayoutService
  }, {
    type: ProductListComponentService
  }, {
    type: GlobalMessageService
  }, {
    type: ViewConfig
  }], null);
})();
var FacetGroupCollapsedState;
(function(FacetGroupCollapsedState2) {
  FacetGroupCollapsedState2["EXPANDED"] = "EXPANDED";
  FacetGroupCollapsedState2["COLLAPSED"] = "COLLAPSED";
})(FacetGroupCollapsedState || (FacetGroupCollapsedState = {}));
var _ProductFacetService = class _ProductFacetService {
  constructor(routing, productListComponentService) {
    this.routing = routing;
    this.productListComponentService = productListComponentService;
    this.routeState$ = this.routing.getRouterState().pipe(map((routerState) => routerState.state));
    this.searchResult$ = this.routeState$.pipe(switchMap((state) => this.productListComponentService.model$.pipe(filter((page) => this.filterForPage(state, page)), map((page) => __spreadProps(__spreadValues({}, page), {
      breadcrumbs: this.filterBreadcrumbs(page?.breadcrumbs ?? [], state.params)
    })))));
    this.facetList$ = this.searchResult$.pipe(map((result) => ({
      facets: result.facets,
      activeFacets: result.breadcrumbs
    })));
  }
  /**
   * Filters the current result by verifying if the result is related to the page.
   * This is done to avoid a combination of the next page and the current search results.
   */
  filterForPage(state, page) {
    if (!page.currentQuery?.query?.value) {
      return false;
    }
    if (state.context.type === PageType.CATEGORY_PAGE) {
      return page.currentQuery.query.value.indexOf(`allCategories:${state.context.id}`) > -1;
    }
    if (state.context.type === PageType.CONTENT_PAGE && state.context.id === "search") {
      return page.freeTextSearch === state.params.query.split(":")[0];
    }
    return false;
  }
  /**
   * Filter breadcrumbs which are not actively selected but coming from
   * the route navigation.
   *
   * The breadcrumbs might include the active category page code, which is not actively
   * selected by the user.
   */
  filterBreadcrumbs(breadcrumbs, params) {
    return breadcrumbs ? breadcrumbs.filter((breadcrumb) => !(breadcrumb.facetCode === "allCategories" && (breadcrumb.facetValueCode === params.categoryCode || breadcrumb.facetValueCode === params.brandCode))) : [];
  }
};
_ProductFacetService.\u0275fac = function ProductFacetService_Factory(t) {
  return new (t || _ProductFacetService)(\u0275\u0275inject(RoutingService), \u0275\u0275inject(ProductListComponentService));
};
_ProductFacetService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ProductFacetService,
  factory: _ProductFacetService.\u0275fac,
  providedIn: "root"
});
var ProductFacetService = _ProductFacetService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductFacetService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RoutingService
  }, {
    type: ProductListComponentService
  }], null);
})();
var _FacetService = class _FacetService {
  constructor(productFacetService) {
    this.productFacetService = productFacetService;
    this.facetState = /* @__PURE__ */ new Map();
    this.codec = new HttpUrlEncodingCodec();
    this.facetList$ = this.productFacetService.facetList$.pipe(tap((facetList) => {
      facetList.facets?.forEach((facet) => this.initialize(facet));
    }));
  }
  /**
   * Returns the observed UI state for the facet.
   *
   * The state is initialized using the `initialize` method.
   */
  getState(facet) {
    this.initialize(facet);
    return facet.name ? this.facetState.get(facet.name) ?? of({}) : of({});
  }
  /**
   * Returns the UI state for the facet.
   *
   * The state is initialized using the `initialize` method.
   */
  getStateSnapshot(facet) {
    return this.getState(facet).value;
  }
  /**
   * Toggles the facet expanded state. If the expanded state becomes false,
   * the visible values will decrease to the top values only.
   *
   * If the optional value argument is provided the expanded state will be set
   * to this value, regardless of the current `expanded` state.
   */
  toggle(facet, isExpanded) {
    const state = this.getStateSnapshot(facet);
    const toggledState = {
      toggled: isExpanded ? FacetGroupCollapsedState.COLLAPSED : FacetGroupCollapsedState.EXPANDED
    };
    if (toggledState.toggled === FacetGroupCollapsedState.COLLAPSED) {
      toggledState.maxVisible = state.topVisible;
    }
    this.updateState(facet, toggledState);
  }
  /**
   * Increases the visible values to the maximum values of the facet.
   */
  increaseVisibleValues(facet) {
    this.updateState(facet, {
      maxVisible: facet.values?.length
    });
  }
  /**
   * Decreases the visible values to the topValueCount.
   *
   * The topValueCount defaults to 6, but can be controlled in
   * the backend as well.
   */
  decreaseVisibleValues(facet) {
    this.updateState(facet, {
      maxVisible: facet.topValueCount
    });
  }
  /**
   * Persists the facet state and initializes the default values for the top
   * and max visible values.
   */
  initialize(facet) {
    const topFacets = facet.topValueCount && facet.topValueCount > 0 ? facet.topValueCount : facet.values?.length || 0;
    if (facet.name && !this.hasState(facet)) {
      this.facetState.set(facet.name, new BehaviorSubject({
        topVisible: topFacets,
        maxVisible: topFacets
      }));
    }
  }
  /**
   * Updates the state of the facet in the local facet map.
   */
  updateState(facet, property) {
    const state = __spreadValues(__spreadValues({}, this.getStateSnapshot(facet)), property);
    if (facet.name) {
      this.facetState.get(facet.name)?.next(state);
    }
  }
  hasState(facet) {
    if (facet.name) {
      return this.facetState.has(facet.name);
    }
    return false;
  }
  getLinkParams(query) {
    return {
      // to avoid encoding issues with facets that have space (' ') in their name,
      // we replace the decoded '+' back to empty space ' '.
      // For more, see https://github.com/SAP/spartacus/issues/7348
      query: this.codec.decodeValue(this.decodeUriComponentSafe(query)).replace(/\+/g, " ")
    };
  }
  decodeUriComponentSafe(query) {
    return query.replace(/%(?![0-9a-fA-F]{2})/g, "%25");
  }
};
_FacetService.\u0275fac = function FacetService_Factory(t) {
  return new (t || _FacetService)(\u0275\u0275inject(ProductFacetService));
};
_FacetService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FacetService,
  factory: _FacetService.\u0275fac,
  providedIn: "root"
});
var FacetService = _FacetService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FacetService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ProductFacetService
  }], null);
})();
var _ActiveFacetsComponent = class _ActiveFacetsComponent {
  constructor(facetService) {
    this.facetService = facetService;
    this.role = "group";
    this.labelledby = "cx-active-facets-groupName";
    this.facetList$ = this.facetService.facetList$;
    this.closeIcon = ICON_TYPE.CLOSE;
  }
  getLinkParams(facet) {
    return this.facetService.getLinkParams(facet.removeQuery?.query?.value ?? "");
  }
  /**
   * The focus key is used to persist the focus on the facet when the DOM is being
   * recreated. We only apply the focus key for the given _active_ facet when there
   * the original facets is not available. This happens for non multi-valued facets.
   *
   * With this approach, the we keep the focus, either at the facet list or on the
   * active facets.
   */
  getFocusKey(facetList, facet) {
    return facetList.facets?.find((f) => f.values?.find((val) => val.name === facet.facetValueName)) ? "" : facet.facetValueName;
  }
  /**
   * Purpose of this function is to allow keyboard users to click on a filter they
   * wish to remove by pressing spacebar. Event not handled natively by <a> elements.
   *
   * @param event spacebar keydown
   */
  removeFilterWithSpacebar(event) {
    event?.preventDefault();
    event?.target?.dispatchEvent(new MouseEvent("click", {
      cancelable: true
    }));
  }
};
_ActiveFacetsComponent.\u0275fac = function ActiveFacetsComponent_Factory(t) {
  return new (t || _ActiveFacetsComponent)(\u0275\u0275directiveInject(FacetService));
};
_ActiveFacetsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ActiveFacetsComponent,
  selectors: [["cx-active-facets"]],
  hostVars: 2,
  hostBindings: function ActiveFacetsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("role", ctx.role)("aria-labelledby", ctx.labelledby);
    }
  },
  inputs: {
    closeIcon: "closeIcon"
  },
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], ["id", "cx-active-facets-groupName", 4, "ngIf"], ["routerLink", "./", "role", "button", 3, "queryParams", "cxFocus", "keydown.space", 4, "ngFor", "ngForOf"], ["id", "cx-active-facets-groupName"], ["routerLink", "./", "role", "button", 3, "keydown.space", "queryParams", "cxFocus"], ["aria-hidden", "true", 3, "type"]],
  template: function ActiveFacetsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ActiveFacetsComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.facetList$));
    }
  },
  dependencies: [NgForOf, NgIf, RouterLink, IconComponent, FocusDirective, AsyncPipe, TranslatePipe],
  encapsulation: 2
});
var ActiveFacetsComponent = _ActiveFacetsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActiveFacetsComponent, [{
    type: Component,
    args: [{
      selector: "cx-active-facets",
      changeDetection: ChangeDetectionStrategy.Default,
      template: `<ng-container *ngIf="facetList$ | async as facetList">
  <div
    id="cx-active-facets-groupName"
    *ngIf="facetList.activeFacets && facetList.activeFacets.length > 0"
  >
    {{ 'productList.appliedFilter' | cxTranslate }}
  </div>

  <a
    *ngFor="let facet of facetList?.activeFacets"
    routerLink="./"
    [queryParams]="getLinkParams(facet)"
    [cxFocus]="{ key: getFocusKey(facetList, facet) }"
    role="button"
    (keydown.space)="removeFilterWithSpacebar($event)"
    [attr.aria-label]="
      'productList.activeFilter' | cxTranslate: { filter: facet.facetValueName }
    "
  >
    <span>{{ facet.facetValueName }}</span>
    <cx-icon aria-hidden="true" [type]="closeIcon"></cx-icon>
  </a>
</ng-container>
`
    }]
  }], () => [{
    type: FacetService
  }], {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    labelledby: [{
      type: HostBinding,
      args: ["attr.aria-labelledby"]
    }],
    closeIcon: [{
      type: Input
    }]
  });
})();
var _ActiveFacetsModule = class _ActiveFacetsModule {
};
_ActiveFacetsModule.\u0275fac = function ActiveFacetsModule_Factory(t) {
  return new (t || _ActiveFacetsModule)();
};
_ActiveFacetsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ActiveFacetsModule
});
_ActiveFacetsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule, I18nModule, IconModule, KeyboardFocusModule]
});
var ActiveFacetsModule = _ActiveFacetsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActiveFacetsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, I18nModule, IconModule, KeyboardFocusModule],
      declarations: [ActiveFacetsComponent],
      exports: [ActiveFacetsComponent]
    }]
  }], null, null);
})();
var _FacetComponent = class _FacetComponent {
  set facet(value) {
    this._facet = value;
    this.isMultiSelect = !!value.multiSelect;
    this.state$ = this.facetService.getState(value);
  }
  get facet() {
    return this._facet;
  }
  constructor(facetService, elementRef, cd) {
    this.facetService = facetService;
    this.elementRef = elementRef;
    this.cd = cd;
    this.expandIcon = ICON_TYPE.EXPAND;
    this.collapseIcon = ICON_TYPE.COLLAPSE;
  }
  /**
   * Handles clicking the heading of the facet group, which means toggling
   * the visibility of the group (collapse / expand) and optionally focusing
   * the group.
   */
  toggleGroup(event) {
    const host = this.elementRef.nativeElement;
    const isLocked = this.keyboardFocus?.isLocked;
    this.facetService.toggle(this.facet, this.isExpanded);
    if (!isLocked || this.isExpanded) {
      host.focus();
      event.stopPropagation();
    }
  }
  get isExpanded() {
    return this.values?.first?.nativeElement.offsetParent !== null;
  }
  openLink(event) {
    event.target.click();
    event.preventDefault();
  }
  /**
   * Increases the number of visible values for the facet. This is delegated
   * to `facetService.increaseVisibleValues`.
   */
  increaseVisibleValues() {
    this.facetService.increaseVisibleValues(this.facet);
  }
  /**
   * Decreases the number of visible values for the facet. This is delegated
   * to `facetService.decreaseVisibleValues`.
   */
  decreaseVisibleValues() {
    this.facetService.decreaseVisibleValues(this.facet);
  }
  getLinkParams(value) {
    return this.facetService.getLinkParams(value.query?.query?.value ?? "");
  }
};
_FacetComponent.\u0275fac = function FacetComponent_Factory(t) {
  return new (t || _FacetComponent)(\u0275\u0275directiveInject(FacetService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_FacetComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FacetComponent,
  selectors: [["cx-facet"]],
  viewQuery: function FacetComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(FocusDirective, 5);
      \u0275\u0275viewQuery(_c422, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.keyboardFocus = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.values = _t);
    }
  },
  hostVars: 2,
  hostBindings: function FacetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("multi-select", ctx.isMultiSelect);
    }
  },
  inputs: {
    expandIcon: "expandIcon",
    collapseIcon: "collapseIcon",
    facet: "facet"
  },
  decls: 2,
  vars: 3,
  consts: [["facetValue", ""], [4, "ngIf"], [1, "heading", 3, "click"], [1, "collapse-icon", 3, "type"], [1, "expand-icon", 3, "type"], ["routerLink", "./", "class", "value", 3, "queryParams", "selected", "cxFocus", "keydown.space", 4, "ngFor", "ngForOf"], [1, "more"], ["aria-expanded", "true", "class", "cx-action-link", 3, "cxAtMessage", "cxFocus", "click", 4, "ngIf"], ["aria-expanded", "false", "class", "cx-action-link", 3, "cxAtMessage", "cxFocus", "click", 4, "ngIf"], ["routerLink", "./", 1, "value", 3, "keydown.space", "queryParams", "cxFocus"], ["aria-hidden", "true"], ["aria-hidden", "true", 1, "count"], [1, "count"], ["aria-expanded", "true", 1, "cx-action-link", 3, "click", "cxAtMessage", "cxFocus"], ["aria-expanded", "false", 1, "cx-action-link", 3, "click", "cxAtMessage", "cxFocus"]],
  template: function FacetComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, FacetComponent_ng_container_0_Template, 14, 22, "ng-container", 1);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.state$));
    }
  },
  dependencies: [AtMessageDirective, NgForOf, NgIf, IconComponent, FocusDirective, RouterLink, AsyncPipe, SlicePipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var FacetComponent = _FacetComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FacetComponent, [{
    type: Component,
    args: [{
      selector: "cx-facet",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="state$ | async as state">
  <button
    class="heading"
    (click)="toggleGroup($event)"
    [attr.aria-expanded]="isExpanded"
    [attr.aria-label]="
      'productFacetNavigation.filterBy.name' | cxTranslate: { name: facet.name }
    "
  >
    {{ facet.name }}
    <cx-icon class="collapse-icon" [type]="collapseIcon"></cx-icon>
    <cx-icon class="expand-icon" [type]="expandIcon"></cx-icon>
  </button>

  <div>
    <a
      *ngFor="let value of facet.values | slice: 0:state.topVisible"
      #facetValue
      routerLink="./"
      [queryParams]="getLinkParams(value)"
      class="value"
      [class.selected]="value.selected"
      [cxFocus]="{ key: value.name }"
      (keydown.space)="openLink($any($event))"
      [attr.role]="facet.multiSelect ? 'checkbox' : null"
      [attr.aria-checked]="facet.multiSelect ? value.selected : null"
      attr.aria-label="{{
        'productFacetNavigation.ariaLabelItemsAvailable'
          | cxTranslate: { name: value.name, count: value.count }
      }}"
    >
      <span aria-hidden="true"
        >{{ value.name
        }}<span aria-hidden="true" class="count">{{ value.count }}</span></span
      >
    </a>

    <div class="more">
      <a
        *ngFor="
          let value of facet.values
            | slice: state.topVisible ?? 0:state.maxVisible
        "
        #facetValue
        routerLink="./"
        [queryParams]="getLinkParams(value)"
        class="value"
        [class.selected]="value.selected"
        [cxFocus]="{ key: value.name }"
        (keydown.space)="openLink($any($event))"
      >
        <span
          >{{ value.name }}<span class="count">{{ value.count }}</span></span
        >
      </a>

      <button
        *ngIf="
          state.maxVisible &&
          state.topVisible &&
          state.maxVisible > state.topVisible
        "
        (click)="decreaseVisibleValues()"
        [cxAtMessage]="
          'productFacetNavigation.decreaseOptionsVisibility' | cxTranslate
        "
        aria-expanded="true"
        attr.aria-label="{{
          'productFacetNavigation.ariaLabelShowLess' | cxTranslate
        }}"
        class="cx-action-link"
        [cxFocus]="{ key: 'moreorless' }"
      >
        {{ 'productList.showLess' | cxTranslate }}
      </button>

      <button
        *ngIf="
          state.maxVisible &&
          facet.values &&
          state.maxVisible > 0 &&
          state.maxVisible < facet.values.length
        "
        (click)="increaseVisibleValues()"
        [cxAtMessage]="
          'productFacetNavigation.increaseOptionsVisibility' | cxTranslate
        "
        aria-expanded="false"
        attr.aria-label="{{
          'productFacetNavigation.ariaLabelShowMore' | cxTranslate
        }}"
        class="cx-action-link"
        [cxFocus]="{ key: 'moreorless' }"
      >
        {{ 'productList.showMore' | cxTranslate }}
      </button>
    </div>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: FacetService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    expandIcon: [{
      type: Input
    }],
    collapseIcon: [{
      type: Input
    }],
    isMultiSelect: [{
      type: HostBinding,
      args: ["class.multi-select"]
    }],
    values: [{
      type: ViewChildren,
      args: ["facetValue"]
    }],
    keyboardFocus: [{
      type: ViewChild,
      args: [FocusDirective]
    }],
    facet: [{
      type: Input
    }]
  });
})();
var _FacetListComponent = class _FacetListComponent {
  /**
   * Indicates that the facet navigation is rendered in dialog.
   */
  set isDialog(value) {
    this._isDialog = value;
    if (value) {
      this.renderer.addClass(document.body, "modal-open");
    }
  }
  get isDialog() {
    return this._isDialog;
  }
  handleClick() {
    this.close();
  }
  constructor(facetService, elementRef, renderer) {
    this.facetService = facetService;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.closeList = new EventEmitter();
    this.facetList$ = this.facetService.facetList$;
    this.iconTypes = ICON_TYPE;
    this.dialogFocusConfig = {
      trap: true,
      block: true,
      focusOnEscape: true,
      autofocus: "cx-facet"
    };
  }
  /**
   * Toggles the facet group in case it is not expanded.
   */
  expandFacetGroup(facet, ref) {
    if (!ref.isExpanded) {
      this.facetService.toggle(facet, ref.isExpanded);
    }
  }
  /**
   * Indicates that the facet group has been expanded.
   */
  isExpanded(facet) {
    return this.facetService.getState(facet).pipe(map((value) => value.toggled === FacetGroupCollapsedState.EXPANDED));
  }
  /**
   * Indicates that the facet group has been collapsed.
   */
  isCollapsed(facet) {
    return this.facetService.getState(facet).pipe(map((value) => value.toggled === FacetGroupCollapsedState.COLLAPSED));
  }
  close(event) {
    this.renderer.removeClass(document.body, "modal-open");
    this.closeList.emit(event);
  }
  block(event) {
    event?.stopPropagation();
  }
};
_FacetListComponent.\u0275fac = function FacetListComponent_Factory(t) {
  return new (t || _FacetListComponent)(\u0275\u0275directiveInject(FacetService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_FacetListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FacetListComponent,
  selectors: [["cx-facet-list"]],
  hostBindings: function FacetListComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function FacetListComponent_click_HostBindingHandler() {
        return ctx.handleClick();
      });
    }
  },
  inputs: {
    isDialog: "isDialog"
  },
  outputs: {
    closeList: "closeList"
  },
  decls: 2,
  vars: 3,
  consts: [["facetRef", ""], ["class", "inner", 3, "cxFocus", "tabindex", "esc", "click", 4, "ngIf"], [1, "inner", 3, "esc", "click", "cxFocus", "tabindex"], [1, "list-header"], ["type", "button", 1, "close", 3, "click"], ["aria-hidden", "true", 3, "type"], ["role", "group", 3, "facet", "expanded", "collapsed", 4, "ngFor", "ngForOf"], ["role", "group", 3, "facet"]],
  template: function FacetListComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, FacetListComponent_section_0_Template, 10, 14, "section", 1);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      let tmp_0_0;
      \u0275\u0275property("ngIf", (tmp_0_0 = \u0275\u0275pipeBind1(1, 1, ctx.facetList$)) == null ? null : tmp_0_0.facets);
    }
  },
  dependencies: [NgForOf, NgIf, IconComponent, FacetComponent, FocusDirective, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var FacetListComponent = _FacetListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FacetListComponent, [{
    type: Component,
    args: [{
      selector: "cx-facet-list",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<section
  class="inner"
  *ngIf="(facetList$ | async)?.facets as facets"
  [attr.aria-label]="'productFacetNavigation.filterBy.facet' | cxTranslate"
  [cxFocus]="isDialog ? dialogFocusConfig : {}"
  [tabindex]="-1"
  (esc)="close($event)"
  (click)="block($event)"
>
  <div class="list-header">
    <h4>
      {{ 'productList.filterBy.label' | cxTranslate }}
    </h4>
    <button
      type="button"
      class="close"
      [attr.aria-label]="'common.close' | cxTranslate"
      (click)="close()"
    >
      <cx-icon aria-hidden="true" [type]="iconTypes.CLOSE"></cx-icon>
    </button>
  </div>

  <!--
      Here we'd like to introduce configurable facet components,
      either by using specific configuration or generic sproutlets
  -->
  <cx-facet
    *ngFor="let facet of facets"
    #facetRef
    [facet]="facet"
    [class.expanded]="isExpanded(facet) | async"
    [class.collapsed]="isCollapsed(facet) | async"
    role="group"
    attr.aria-label="{{
      'productFacetNavigation.ariaLabelItemsAvailable'
        | cxTranslate
          : {
              name: facet.name,
              count: facet?.values?.length
            }
    }}"
  ></cx-facet>
</section>
`
    }]
  }], () => [{
    type: FacetService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    isDialog: [{
      type: Input
    }],
    closeList: [{
      type: Output
    }],
    handleClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _FacetModule = class _FacetModule {
};
_FacetModule.\u0275fac = function FacetModule_Factory(t) {
  return new (t || _FacetModule)();
};
_FacetModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FacetModule
});
_FacetModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [AtMessageModule, CommonModule, I18nModule, IconModule, KeyboardFocusModule, RouterModule, UrlModule]
});
var FacetModule = _FacetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FacetModule, [{
    type: NgModule,
    args: [{
      imports: [AtMessageModule, CommonModule, I18nModule, IconModule, KeyboardFocusModule, RouterModule, UrlModule],
      declarations: [FacetComponent],
      exports: [FacetComponent]
    }]
  }], null, null);
})();
var _FacetListModule = class _FacetListModule {
};
_FacetListModule.\u0275fac = function FacetListModule_Factory(t) {
  return new (t || _FacetListModule)();
};
_FacetListModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FacetListModule
});
_FacetListModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, I18nModule, IconModule, FacetModule, KeyboardFocusModule]
});
var FacetListModule = _FacetListModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FacetListModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, IconModule, FacetModule, KeyboardFocusModule],
      declarations: [FacetListComponent],
      exports: [FacetListComponent]
    }]
  }], null, null);
})();
var _ProductFacetNavigationComponent = class _ProductFacetNavigationComponent {
  constructor(breakpointService) {
    this.breakpointService = breakpointService;
    this.iconTypes = ICON_TYPE;
    this.CLOSE_DELAY = 300;
    this.open$ = new BehaviorSubject(false);
    this.isOpen$ = this.breakpointService.breakpoint$.pipe(
      // deffer emitting a new value to the next micro-task to ensure that the `hasTrigger`
      // method represents the actual UI state.
      observeOn(asapScheduler),
      switchMap(() => this.hasTrigger ? this.open$ : of(true)),
      delayWhen((launched) => interval(launched ? 0 : this.CLOSE_DELAY))
    );
    this.isActive$ = this.open$.pipe(
      // deffer emitting a new value to the next micro-task to ensure the active class is
      //  applied after the DOM is created
      observeOn(asapScheduler)
    );
  }
  launch() {
    this.open$.next(true);
  }
  close() {
    this.open$.next(false);
    this.trigger.nativeElement.focus();
  }
  /**
   * Indicates that the facet navigation should be open explicitely by a trigger.
   * This is fully controlled by CSS, where the trigger button can be hidden
   * (display:none) for certain screen sizes.
   */
  get hasTrigger() {
    return this.trigger.nativeElement.offsetParent !== null;
  }
};
_ProductFacetNavigationComponent.\u0275fac = function ProductFacetNavigationComponent_Factory(t) {
  return new (t || _ProductFacetNavigationComponent)(\u0275\u0275directiveInject(BreakpointService));
};
_ProductFacetNavigationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductFacetNavigationComponent,
  selectors: [["cx-product-facet-navigation"]],
  viewQuery: function ProductFacetNavigationComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c46, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.trigger = _t.first);
    }
  },
  decls: 8,
  vars: 7,
  consts: [["trigger", ""], [1, "btn", "btn-secondary", "btn-block", "dialog-trigger", 3, "click"], [3, "type"], [3, "isDialog", "active", "dialog", "closeList", 4, "ngIf"], [3, "closeList", "isDialog"]],
  template: function ProductFacetNavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "button", 1, 0);
      \u0275\u0275listener("click", function ProductFacetNavigationComponent_Template_button_click_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.launch());
      });
      \u0275\u0275element(2, "cx-icon", 2);
      \u0275\u0275text(3);
      \u0275\u0275pipe(4, "cxTranslate");
      \u0275\u0275elementEnd();
      \u0275\u0275element(5, "cx-active-facets");
      \u0275\u0275template(6, ProductFacetNavigationComponent_cx_facet_list_6_Template, 2, 7, "cx-facet-list", 3);
      \u0275\u0275pipe(7, "async");
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("type", ctx.iconTypes.FILTER);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(4, 3, "productList.filterBy.label"), "\n");
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(7, 5, ctx.isOpen$));
    }
  },
  dependencies: [NgIf, FacetListComponent, ActiveFacetsComponent, IconComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductFacetNavigationComponent = _ProductFacetNavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductFacetNavigationComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-facet-navigation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<button
  #trigger
  class="btn btn-secondary btn-block dialog-trigger"
  (click)="launch()"
>
  <cx-icon [type]="iconTypes.FILTER"></cx-icon>
  {{ 'productList.filterBy.label' | cxTranslate }}
</button>

<cx-active-facets></cx-active-facets>

<cx-facet-list
  *ngIf="isOpen$ | async"
  [isDialog]="hasTrigger"
  (closeList)="close()"
  [class.active]="isActive$ | async"
  [class.dialog]="hasTrigger"
></cx-facet-list>
`
    }]
  }], () => [{
    type: BreakpointService
  }], {
    trigger: [{
      type: ViewChild,
      args: ["trigger"]
    }]
  });
})();
var _ProductFacetNavigationModule = class _ProductFacetNavigationModule {
};
_ProductFacetNavigationModule.\u0275fac = function ProductFacetNavigationModule_Factory(t) {
  return new (t || _ProductFacetNavigationModule)();
};
_ProductFacetNavigationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductFacetNavigationModule
});
_ProductFacetNavigationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FacetListModule, ActiveFacetsModule, IconModule, I18nModule, ConfigModule.withConfig({
    cmsComponents: {
      ProductRefinementComponent: {
        component: ProductFacetNavigationComponent
      }
    }
  })]
});
var ProductFacetNavigationModule = _ProductFacetNavigationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductFacetNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FacetListModule, ActiveFacetsModule, IconModule, I18nModule, ConfigModule.withConfig({
        cmsComponents: {
          ProductRefinementComponent: {
            component: ProductFacetNavigationComponent
          }
        }
      })],
      declarations: [ProductFacetNavigationComponent],
      exports: [ProductFacetNavigationComponent]
    }]
  }], null, null);
})();
var _FileDownloadService = class _FileDownloadService {
  /**
   * Triggers the browser downloading of the file from the given URL.
   *
   * @param {string} url URL to file.
   * @param {string} [fileName] The optional parameter for defining filename
   * (including the extension) when saving the file.
   */
  download(url, fileName) {
    const link = document.createElement("a");
    link.setAttribute("href", url);
    link.setAttribute("download", `${fileName}`);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
};
_FileDownloadService.\u0275fac = function FileDownloadService_Factory(t) {
  return new (t || _FileDownloadService)();
};
_FileDownloadService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FileDownloadService,
  factory: _FileDownloadService.\u0275fac,
  providedIn: "root"
});
var FileDownloadService = _FileDownloadService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileDownloadService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ExportCsvFileService = class _ExportCsvFileService {
  constructor(fileDownloadService) {
    this.fileDownloadService = fileDownloadService;
  }
  /**
   * Converts array of objects into CSV data structure.
   *
   * @param objectsArray Array of objects which should be converted to CSV.
   * @param separator Separator for CSV data.
   * @returns Processed string ready to be saved into file.
   */
  convert(objectsArray, separator) {
    return objectsArray.reduce((csvString, row) => {
      const line = row.reduce((currentLine, column) => {
        currentLine += currentLine !== "" ? separator : "";
        const cell = column.includes(separator) ? `"${column}"` : column;
        return `${currentLine}${cell}`;
      }, "");
      return `${csvString}${line}\r
`;
    }, "");
  }
  /**
   * Creates and download CSV file.
   *
   * @param objectsArray Array of objects which should be converted to CSV.
   * @param separator Separator for CSV data.
   * @param fileOptions Exported file options.
   */
  download(objectsArray, separator, fileOptions) {
    const {
      fileName,
      type,
      extension
    } = fileOptions;
    const fileContent = this.convert(objectsArray, separator);
    const blob = new Blob([fileContent], {
      type
    });
    const url = URL.createObjectURL(blob);
    this.fileDownloadService.download(url, `${fileName}.${extension}`);
  }
};
_ExportCsvFileService.\u0275fac = function ExportCsvFileService_Factory(t) {
  return new (t || _ExportCsvFileService)(\u0275\u0275inject(FileDownloadService));
};
_ExportCsvFileService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ExportCsvFileService,
  factory: _ExportCsvFileService.\u0275fac,
  providedIn: "root"
});
var ExportCsvFileService = _ExportCsvFileService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExportCsvFileService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: FileDownloadService
  }], null);
})();
var _FileReaderService = class _FileReaderService {
  /**
   * Load text file
   *
   * @param file text file to extract the data
   * @returns Observable from file reader
   */
  loadTextFile(file) {
    return new Observable((observer) => {
      const fileReader = new FileReader();
      fileReader.readAsText(file);
      fileReader.onload = () => {
        observer.next(fileReader.result);
        observer.complete();
      };
      fileReader.onerror = (error) => {
        fileReader.abort();
        observer.error(error);
      };
    });
  }
};
_FileReaderService.\u0275fac = function FileReaderService_Factory(t) {
  return new (t || _FileReaderService)();
};
_FileReaderService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FileReaderService,
  factory: _FileReaderService.\u0275fac,
  providedIn: "root"
});
var FileReaderService = _FileReaderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileReaderService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ImportCsvFileService = class _ImportCsvFileService {
  constructor(fileReaderService) {
    this.fileReaderService = fileReaderService;
  }
  /**
   * Load CSV file.
   *
   * @param file File we want to load as CSV.
   * @param separator Separator for CSV data.
   * @return {Observable<string[][]>} Imported file
   */
  loadFile(file, separator) {
    return this.fileReaderService.loadTextFile(file).pipe(map((res) => this.parse(res, separator)));
  }
  /**
   * Combined csv validation
   *
   * @param file File we want to load as CSV.
   * @param separator Separator for CSV data.
   * @param isDataParsable (optional) Callback for verify that structure type is proper.
   * @param maxEntries (optional) Limitation for maximum entries count.
   * @return {Observable<CsvFileValidationErrors | null>} Result of validation
   */
  validateFile(file, {
    separator,
    isDataParsable,
    maxEntries
  }) {
    const validationErrors = {};
    return this.fileReaderService.loadTextFile(file).pipe(tap((data) => {
      this.validateEmpty(data, validationErrors);
    }), map((res) => this.parse(res, separator)), tap((data) => {
      this.validateNotParsable(data, validationErrors, isDataParsable);
      this.validateTooManyEntries(data, validationErrors, maxEntries);
    }), catchError((errors) => of(errors)), map(() => Object.keys(validationErrors).length === 0 ? null : validationErrors));
  }
  /**
   * Processes the CSV data
   *
   * @param csvString raw extracted data from CSV
   * @param separator for csv data
   * @param ignoreHeader (optional) flag allows for ignore headers row while reading
   * @returns {string[][]} Parsed file
   */
  parse(csvString, separator, ignoreHeader = true) {
    return csvString.split("\n").map((row) => row.split(separator).map((cell) => cell.replace(/"/g, ""))).filter((value, index) => !(ignoreHeader && index === 0) && value[0] !== "");
  }
  validateEmpty(data, errors) {
    if (data.toString().length === 0) {
      errors.empty = true;
      throw errors;
    }
  }
  validateTooManyEntries(data, errors, maxEntries) {
    if (maxEntries && data.length > maxEntries) {
      errors.tooManyEntries = {
        maxEntries
      };
      throw errors;
    }
  }
  validateNotParsable(data, errors, isDataParsable) {
    if (isDataParsable && !isDataParsable(data)) {
      errors.notParsable = true;
      throw errors;
    }
  }
};
_ImportCsvFileService.\u0275fac = function ImportCsvFileService_Factory(t) {
  return new (t || _ImportCsvFileService)(\u0275\u0275inject(FileReaderService));
};
_ImportCsvFileService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ImportCsvFileService,
  factory: _ImportCsvFileService.\u0275fac,
  providedIn: "root"
});
var ImportCsvFileService = _ImportCsvFileService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImportCsvFileService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: FileReaderService
  }], null);
})();
var CustomFormValidators = class {
  /**
   * Checks control's value with predefined email regexp
   *
   * NOTE: Use it as a control validator
   *
   * @static
   * @param {AbstractControl} control
   * @returns {(ValidationErrors | null)} Uses 'cxInvalidEmail' validator error
   * @memberof CustomFormValidators
   */
  static emailValidator(control) {
    const email = control.value;
    return email && (!email.length || email.match(EMAIL_PATTERN)) ? null : {
      cxInvalidEmail: true
    };
  }
  /**
   * Checks control's value with predefined password regexp
   *
   * NOTE: Use it as a control validator
   *
   * @static
   * @param {AbstractControl} control
   * @returns {(ValidationErrors | null)} Uses 'cxInvalidPassword' validator error
   * @memberof CustomFormValidators
   */
  static passwordValidator(control) {
    const password = control.value;
    return password && (!password.length || password.match(PASSWORD_PATTERN)) ? null : {
      cxInvalidPassword: true
    };
  }
  /**
   * Checks if control's value is between 1 and 5
   *
   * NOTE: Use it as a control validator
   *
   * @static
   * @param {AbstractControl} control
   * @returns {(ValidationErrors | null)} Uses 'cxStarRatingEmpty' validator error
   * @memberof CustomFormValidators
   */
  static starRatingEmpty(control) {
    const rating = control.value;
    return rating >= 1 && rating <= 5 ? null : {
      cxStarRatingEmpty: true
    };
  }
  /**
   * Checks if two password controls match
   *
   * NOTE: Use it as a form validator and pass password control names as parameters
   *
   * @static
   * @param {string} password First password control name
   * @param {string} passwordConfirmation Second password control name
   * @returns Uses 'cxPasswordsMustMatch' validator error
   * @memberof CustomFormValidators
   */
  static passwordsMustMatch(password, passwordConfirmation) {
    const validator = (formGroup) => controlsMustMatch(formGroup, password, passwordConfirmation, "cxPasswordsMustMatch");
    return validator;
  }
  /**
   * Checks if two email controls match
   *
   * NOTE: Use it as a form validator and pass email control names as parameters
   *
   * @static
   * @param {string} email First email control name
   * @param {string} emailConfirmation Second email control name
   * @returns Uses 'cxEmailsMustMatch' validator error
   * @memberof CustomFormValidators
   */
  static emailsMustMatch(email, emailConfirmation) {
    const validator = (formGroup) => controlsMustMatch(formGroup, email, emailConfirmation, "cxEmailsMustMatch");
    return validator;
  }
  /**
   * Checks if control's value is euqal or greater than 0
   *
   * NOTE: Use it as a control validator
   *
   * @static
   * @param {AbstractControl} control
   * @returns {(ValidationErrors | null)} Uses 'cxNegativeAmount' validator error
   * @memberof CustomFormValidators
   */
  static mustBePositive(control) {
    const amount = control.value;
    return amount >= 0 ? null : {
      cxNegativeAmount: true
    };
  }
  /**
   * Checks if control's value does not contain any special characters
   *
   * NOTE: Use it as a control validator
   *
   * @static
   * @param {AbstractControl} control
   * @returns {(ValidationErrors | null)} Uses 'cxContainsSpecialCharacters' validator error
   * @memberof CustomFormValidators
   */
  static noSpecialCharacters(control) {
    const forbiddenChars = ["/"];
    const str = String(control.value);
    const containsSpecialChars = forbiddenChars.some((char) => str.includes(char));
    return !containsSpecialChars ? null : {
      cxContainsSpecialCharacters: true
    };
  }
  /**
   * Checks if control's value passes pattern
   *
   * NOTE: Use it as a control validator
   *
   * @static
   * @param {(date: string) => boolean} isValidFormat Pattern verification function
   * @returns {(control: AbstractControl): ValidationErrors | null} Uses 'pattern' validator error
   * @memberof CustomFormValidators
   */
  static patternValidation(isValidFormat) {
    const validator = (control) => {
      const errors = {};
      if (control.value && control.value !== "" && !isValidFormat(control.value)) {
        errors.pattern = true;
      }
      return Object.keys(errors).length === 0 ? null : errors;
    };
    return validator;
  }
  /**
   * Checks if two email controls match
   *
   * NOTE: Use it as a form validator and pass dates for range
   *
   * @static
   * @param {string} startDateKey First date control name
   * @param {string} endDateKey Second date control name
   * @param {(value: string) => Date} getDate Converting function
   * @returns Uses 'min' and 'max validator error
   * @memberof CustomFormValidators
   */
  static dateRange(startDateKey, endDateKey, getDate) {
    return (formGroup) => {
      const startDateControl = formGroup.controls[startDateKey];
      const endDateControl = formGroup.controls[endDateKey];
      const startDate = getDate(startDateControl.value);
      const endDate = getDate(endDateControl.value);
      if (startDate && endDate) {
        if (!startDateControl.errors?.pattern) {
          if (startDate > endDate) {
            startDateControl.setErrors({
              max: true
            });
          }
        }
        if (!endDateControl.errors?.pattern) {
          if (endDate < startDate) {
            endDateControl.setErrors({
              min: true
            });
          }
        }
      }
      return null;
    };
  }
};
function controlsMustMatch(formGroup, firstControlName, secondControlName, errorName) {
  const firstControl = formGroup.controls[firstControlName];
  const secondControl = formGroup.controls[secondControlName];
  if (secondControl.errors && !secondControl.errors[errorName]) {
    return;
  }
  secondControl.setErrors(firstControl.value !== secondControl.value ? {
    [errorName]: true
  } : null);
}
var titleScores = {
  mr: 1,
  mrs: 2,
  miss: 3,
  ms: 4,
  dr: 5,
  rev: 6
};
function sortTitles(title1, title2) {
  if (title1.code && title2.code) {
    if (!titleScores[title1.code] || !titleScores[title2.code]) {
      return 1;
    } else {
      return titleScores[title1.code] - titleScores[title2.code];
    }
  }
  return 1;
}
var defaultViewConfig = {
  view: {
    defaultPageSize: 12,
    infiniteScroll: {
      active: false,
      productLimit: 0,
      showMoreButton: false
    }
  }
};
var _ProductListModule = class _ProductListModule {
};
_ProductListModule.\u0275fac = function ProductListModule_Factory(t) {
  return new (t || _ProductListModule)();
};
_ProductListModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductListModule
});
_ProductListModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultViewConfig), provideDefaultConfig({
    cmsComponents: {
      CMSProductListComponent: {
        component: ProductListComponent,
        data: {
          composition: {
            inner: ["ProductAddToCartComponent"]
          }
        }
      },
      ProductGridComponent: {
        component: ProductListComponent,
        data: {
          composition: {
            inner: ["ProductAddToCartComponent"]
          }
        }
      },
      SearchResultsListComponent: {
        component: ProductListComponent,
        data: {
          composition: {
            inner: ["ProductAddToCartComponent"]
          }
        }
      }
    }
  })],
  imports: [AtMessageModule, CommonModule, I18nModule, IconModule, InfiniteScrollModule, ItemCounterModule, ListNavigationModule, MediaModule, OutletModule, PageComponentModule, RouterModule, SpinnerModule, StarRatingModule, UrlModule]
});
var ProductListModule = _ProductListModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductListModule, [{
    type: NgModule,
    args: [{
      imports: [AtMessageModule, CommonModule, I18nModule, IconModule, InfiniteScrollModule, ItemCounterModule, ListNavigationModule, MediaModule, OutletModule, PageComponentModule, RouterModule, SpinnerModule, StarRatingModule, UrlModule],
      providers: [provideDefaultConfig(defaultViewConfig), provideDefaultConfig({
        cmsComponents: {
          CMSProductListComponent: {
            component: ProductListComponent,
            data: {
              composition: {
                inner: ["ProductAddToCartComponent"]
              }
            }
          },
          ProductGridComponent: {
            component: ProductListComponent,
            data: {
              composition: {
                inner: ["ProductAddToCartComponent"]
              }
            }
          },
          SearchResultsListComponent: {
            component: ProductListComponent,
            data: {
              composition: {
                inner: ["ProductAddToCartComponent"]
              }
            }
          }
        }
      })],
      declarations: [ProductListComponent, ProductListItemComponent, ProductGridItemComponent, ProductViewComponent, ProductScrollComponent],
      exports: [ProductListComponent, ProductListItemComponent, ProductGridItemComponent, ProductViewComponent, ProductScrollComponent]
    }]
  }], null, null);
})();
var _ProductCarouselItemComponent = class _ProductCarouselItemComponent {
  constructor(productListItemContextSource) {
    this.productListItemContextSource = productListItemContextSource;
  }
  ngOnChanges(changes) {
    if (changes?.item) {
      this.productListItemContextSource.product$.next(this.item);
    }
  }
};
_ProductCarouselItemComponent.\u0275fac = function ProductCarouselItemComponent_Factory(t) {
  return new (t || _ProductCarouselItemComponent)(\u0275\u0275directiveInject(ProductListItemContextSource));
};
_ProductCarouselItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductCarouselItemComponent,
  selectors: [["cx-product-carousel-item"]],
  inputs: {
    item: "item"
  },
  features: [\u0275\u0275ProvidersFeature([ProductListItemContextSource, {
    provide: ProductListItemContext,
    useExisting: ProductListItemContextSource
  }]), \u0275\u0275NgOnChangesFeature],
  decls: 9,
  vars: 9,
  consts: [["tabindex", "0", 3, "routerLink"], ["format", "product", 3, "container", "alt"], [1, "cx-product-name"], [1, "price"], [1, "actions"], ["cxInnerComponentsHost", ""]],
  template: function ProductCarouselItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "a", 0);
      \u0275\u0275pipe(1, "cxUrl");
      \u0275\u0275element(2, "cx-media", 1);
      \u0275\u0275elementStart(3, "h3", 2);
      \u0275\u0275text(4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div", 3);
      \u0275\u0275text(6);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(7, "div", 4);
      \u0275\u0275elementContainer(8, 5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      let tmp_2_0;
      \u0275\u0275property("routerLink", \u0275\u0275pipeBind1(1, 5, \u0275\u0275pureFunction1(7, _c31, ctx.item)));
      \u0275\u0275advance(2);
      \u0275\u0275property("container", ctx.item.images == null ? null : ctx.item.images.PRIMARY)("alt", (tmp_2_0 = ctx.item.name) !== null && tmp_2_0 !== void 0 ? tmp_2_0 : "");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.item.name, " ");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.item.price == null ? null : ctx.item.price.formattedValue, " ");
    }
  },
  dependencies: [MediaComponent, RouterLink, InnerComponentsHostDirective, UrlPipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductCarouselItemComponent = _ProductCarouselItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductCarouselItemComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-carousel-item",
      providers: [ProductListItemContextSource, {
        provide: ProductListItemContext,
        useExisting: ProductListItemContextSource
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<a tabindex="0" [routerLink]="{ cxRoute: 'product', params: item } | cxUrl">
  <cx-media
    [container]="item.images?.PRIMARY"
    format="product"
    [alt]="item.name ?? ''"
  ></cx-media>
  <h3 class="cx-product-name">
    {{ item.name }}
  </h3>
  <div class="price">
    {{ item.price?.formattedValue }}
  </div>
</a>
<div class="actions">
  <ng-container cxInnerComponentsHost></ng-container>
</div>
`
    }]
  }], () => [{
    type: ProductListItemContextSource
  }], {
    item: [{
      type: Input
    }]
  });
})();
var _ProductCarouselComponent = class _ProductCarouselComponent {
  constructor(componentData, productService) {
    this.componentData = componentData;
    this.productService = productService;
    this.PRODUCT_SCOPE = [
      "list",
      "price",
      "stock"
      /* ProductScope.STOCK */
    ];
    this.componentData$ = this.componentData.data$.pipe(filter((data) => Boolean(data)));
    this.title$ = this.componentData$.pipe(map((data) => data.title));
    this.items$ = this.componentData$.pipe(map((data) => data.productCodes?.trim().split(" ") ?? []), map((codes) => codes.map((code) => this.productService.get(code, [...this.PRODUCT_SCOPE]))));
  }
};
_ProductCarouselComponent.\u0275fac = function ProductCarouselComponent_Factory(t) {
  return new (t || _ProductCarouselComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(ProductService));
};
_ProductCarouselComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductCarouselComponent,
  selectors: [["cx-product-carousel"]],
  decls: 4,
  vars: 3,
  consts: [["carouselItem", ""], ["role", "region", "itemWidth", "285px", 3, "items", "title", "template", 4, "ngIf"], ["role", "region", "itemWidth", "285px", 3, "items", "title", "template"], [3, "item"]],
  template: function ProductCarouselComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductCarouselComponent_cx_carousel_0_Template, 4, 13, "cx-carousel", 1);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, ProductCarouselComponent_ng_template_2_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.items$));
    }
  },
  dependencies: [NgIf, CarouselComponent, ProductCarouselItemComponent, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductCarouselComponent = _ProductCarouselComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductCarouselComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-carousel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<cx-carousel
  *ngIf="items$ | async as items"
  role="region"
  [attr.aria-label]="
    'productCarousel.carouselLabel' | cxTranslate: { title: title$ | async }
  "
  [items]="items"
  [title]="title$ | async"
  [template]="carouselItem"
  itemWidth="285px"
>
</cx-carousel>

<ng-template #carouselItem let-item="item">
  <cx-product-carousel-item [item]="item"></cx-product-carousel-item>
</ng-template>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: ProductService
  }], null);
})();
var _ProductCarouselModule = class _ProductCarouselModule {
};
_ProductCarouselModule.\u0275fac = function ProductCarouselModule_Factory(t) {
  return new (t || _ProductCarouselModule)();
};
_ProductCarouselModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductCarouselModule
});
_ProductCarouselModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductCarouselComponent: {
        component: ProductCarouselComponent
      }
    }
  })],
  imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule, I18nModule, PageComponentModule]
});
var ProductCarouselModule = _ProductCarouselModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductCarouselModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule, I18nModule, PageComponentModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductCarouselComponent: {
            component: ProductCarouselComponent
          }
        }
      })],
      declarations: [ProductCarouselComponent, ProductCarouselItemComponent],
      exports: [ProductCarouselComponent, ProductCarouselItemComponent]
    }]
  }], null, null);
})();
var _ProductReferencesComponent = class _ProductReferencesComponent {
  constructor(cmsComponentData, currentProductService, productReferenceService) {
    this.cmsComponentData = cmsComponentData;
    this.currentProductService = currentProductService;
    this.productReferenceService = productReferenceService;
    this.items$ = this.productCode$.pipe(withLatestFrom(this.componentData$), tap(([productCode, data]) => this.productReferenceService.loadProductReferences(productCode, data.productReferenceTypes)), switchMap(([productCode, data]) => this.getProductReferences(productCode, data.productReferenceTypes ?? "")));
  }
  get componentData$() {
    return this.cmsComponentData.data$.pipe(filter((data) => Boolean(data)));
  }
  /**
   * Returns an Observable String for the product code
   */
  get productCode$() {
    return this.currentProductService.getProduct().pipe(filter(isNotNullable), map((product) => product.code ?? ""), tap((_) => this.productReferenceService.cleanReferences()));
  }
  /**
   * Returns an Observable String for the title
   */
  get title$() {
    return this.componentData$.pipe(map((data) => data?.title));
  }
  /**
   * Returns an observable for product references
   */
  getProductReferences(code, referenceType) {
    return this.productReferenceService.getProductReferences(code, referenceType).pipe(filter((references) => Boolean(references)), map((references) => references.map((reference) => of(reference.target))));
  }
};
_ProductReferencesComponent.\u0275fac = function ProductReferencesComponent_Factory(t) {
  return new (t || _ProductReferencesComponent)(\u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(CurrentProductService), \u0275\u0275directiveInject(ProductReferenceService));
};
_ProductReferencesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductReferencesComponent,
  selectors: [["cx-product-references"]],
  decls: 4,
  vars: 3,
  consts: [["carouselItem", ""], [3, "title", "items", "template", 4, "ngIf"], [3, "title", "items", "template"], ["tabindex", "0", 3, "routerLink"], ["format", "product", 3, "container"], [1, "price"]],
  template: function ProductReferencesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductReferencesComponent_cx_carousel_0_Template, 2, 5, "cx-carousel", 1);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, ProductReferencesComponent_ng_template_2_Template, 7, 8, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.items$));
    }
  },
  dependencies: [NgIf, CarouselComponent, MediaComponent, RouterLink, AsyncPipe, UrlPipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductReferencesComponent = _ProductReferencesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductReferencesComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-references",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<cx-carousel
  *ngIf="items$ | async as items"
  [title]="title$ | async"
  [items]="items"
  [template]="carouselItem"
>
</cx-carousel>

<ng-template #carouselItem let-item="item">
  <a tabindex="0" [routerLink]="{ cxRoute: 'product', params: item } | cxUrl">
    <cx-media [container]="item.images?.PRIMARY" format="product"></cx-media>
    <h4>{{ item.name }}</h4>
    <div class="price">{{ item.price?.formattedValue }}</div>
  </a>
</ng-template>
`
    }]
  }], () => [{
    type: CmsComponentData
  }, {
    type: CurrentProductService
  }, {
    type: ProductReferenceService
  }], null);
})();
var _ProductReferencesModule = class _ProductReferencesModule {
};
_ProductReferencesModule.\u0275fac = function ProductReferencesModule_Factory(t) {
  return new (t || _ProductReferencesModule)();
};
_ProductReferencesModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductReferencesModule
});
_ProductReferencesModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductReferencesComponent: {
        component: ProductReferencesComponent
      }
    }
  })],
  imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule]
});
var ProductReferencesModule = _ProductReferencesModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductReferencesModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductReferencesComponent: {
            component: ProductReferencesComponent
          }
        }
      })],
      declarations: [ProductReferencesComponent],
      exports: [ProductReferencesComponent]
    }]
  }], null, null);
})();
var _ProductImagesComponent = class _ProductImagesComponent {
  constructor(currentProductService) {
    this.currentProductService = currentProductService;
    this.mainMediaContainer = new BehaviorSubject(null);
    this.product$ = this.currentProductService.getProduct().pipe(filter(isNotNullable), distinctUntilChanged(), tap((p) => {
      this.mainMediaContainer.next(p.images?.PRIMARY ? p.images.PRIMARY : {});
    }));
    this.thumbs$ = this.product$.pipe(map((p) => this.createThumbs(p)));
    this.mainImage$ = combineLatest([this.product$, this.mainMediaContainer]).pipe(map(([, container]) => container));
  }
  openImage(item) {
    this.mainMediaContainer.next(item);
  }
  isActive(thumbnail) {
    return this.mainMediaContainer.pipe(filter(Boolean), map((container) => {
      return container.zoom && container.zoom.url && thumbnail.zoom && thumbnail.zoom.url && container.zoom.url === thumbnail.zoom.url;
    }));
  }
  /** find the index of the main media in the list of media */
  getActive(thumbs) {
    return this.mainMediaContainer.pipe(filter(Boolean), map((container) => {
      const current = thumbs.find((t) => t.media && container.zoom && t.media.container && t.media.container.zoom && t.media.container.zoom.url === container.zoom.url);
      return thumbs.indexOf(current);
    }));
  }
  /**
   * Return an array of CarouselItems for the product thumbnails.
   * In case there are less then 2 thumbs, we return null.
   */
  createThumbs(product) {
    if (!product.images || !product.images.GALLERY || Array.isArray(product.images.GALLERY) && product.images.GALLERY.length < 2) {
      return [];
    }
    return product.images.GALLERY.map((c) => of({
      container: c
    }));
  }
};
_ProductImagesComponent.\u0275fac = function ProductImagesComponent_Factory(t) {
  return new (t || _ProductImagesComponent)(\u0275\u0275directiveInject(CurrentProductService));
};
_ProductImagesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductImagesComponent,
  selectors: [["cx-product-images"]],
  decls: 6,
  vars: 6,
  consts: [["thumb", ""], [4, "ngIf"], [3, "container"], ["class", "thumbs", "itemWidth", "120px", 3, "items", "hideIndicators", "template", 4, "ngIf"], ["itemWidth", "120px", 1, "thumbs", 3, "items", "hideIndicators", "template"], ["tabindex", "0", "format", "product", 3, "focus", "container"]],
  template: function ProductImagesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductImagesComponent_ng_container_0_Template, 2, 1, "ng-container", 1);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, ProductImagesComponent_ng_container_2_Template, 2, 1, "ng-container", 1);
      \u0275\u0275pipe(3, "async");
      \u0275\u0275template(4, ProductImagesComponent_ng_template_4_Template, 2, 5, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 2, ctx.mainImage$));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(3, 4, ctx.thumbs$));
    }
  },
  dependencies: [NgIf, MediaComponent, CarouselComponent, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductImagesComponent = _ProductImagesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductImagesComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-images",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<ng-container *ngIf="mainImage$ | async as main">\n  <cx-media [container]="main"></cx-media>\n</ng-container>\n\n<ng-container *ngIf="thumbs$ | async as thumbs">\n  <cx-carousel\n    *ngIf="thumbs.length"\n    class="thumbs"\n    [items]="thumbs"\n    itemWidth="120px"\n    [hideIndicators]="false"\n    [template]="thumb"\n  ></cx-carousel>\n</ng-container>\n\n<ng-template #thumb let-item="item">\n  <cx-media\n    [container]="item.container"\n    tabindex="0"\n    (focus)="openImage(item.container)"\n    [class.is-active]="isActive(item.container) | async"\n    format="product"\n  >\n  </cx-media>\n</ng-template>\n'
    }]
  }], () => [{
    type: CurrentProductService
  }], null);
})();
var _ProductImagesModule = class _ProductImagesModule {
};
_ProductImagesModule.\u0275fac = function ProductImagesModule_Factory(t) {
  return new (t || _ProductImagesModule)();
};
_ProductImagesModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductImagesModule
});
_ProductImagesModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductImagesComponent: {
        component: ProductImagesComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, MediaModule, OutletModule, CarouselModule]
});
var ProductImagesModule = _ProductImagesModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductImagesModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, MediaModule, OutletModule, CarouselModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductImagesComponent: {
            component: ProductImagesComponent
          }
        }
      })],
      declarations: [ProductImagesComponent],
      exports: [ProductImagesComponent]
    }]
  }], null, null);
})();
var _ProductIntroComponent = class _ProductIntroComponent {
  constructor(currentProductService, translationService, winRef, eventService) {
    this.currentProductService = currentProductService;
    this.translationService = translationService;
    this.winRef = winRef;
    this.eventService = eventService;
    this.product$ = this.currentProductService.getProduct();
    this.areReviewsAvailable$ = merge(
      // Check if reviews component is already defined:
      defer(() => of(!!this.getReviewsComponent())),
      // Observe EventService for reviews availability:
      this.eventService.get(ComponentCreateEvent).pipe(filter((event) => event.id === this.reviewsComponentId), map(() => true)),
      this.eventService.get(ComponentDestroyEvent).pipe(filter((event) => event.id === this.reviewsComponentId), map(() => false))
    );
    this.reviewsComponentId = "ProductReviewsTabComponent";
    this.reviewsTranslationKey = `TabPanelContainer.tabs.${this.reviewsComponentId}`;
  }
  /**
   * Scroll to views component on page and click "Reviews" tab
   */
  showReviews() {
    this.translationService.translate(this.reviewsTranslationKey).subscribe((reviewsTabLabel) => {
      const tabsComponent = this.getTabsComponent();
      const reviewsTab = tabsComponent && this.getTabByLabel(reviewsTabLabel, tabsComponent);
      if (reviewsTab) {
        this.clickTabIfInactive(reviewsTab);
        setTimeout(() => {
          reviewsTab.scrollIntoView({
            behavior: "smooth"
          });
          reviewsTab.focus({
            preventScroll: true
          });
        });
      }
    }).unsubscribe();
  }
  // NOTE: Does not currently exists as its own component
  // but part of tabs component. This is likely to change in refactor.
  /**
   * Get Reviews Component if exists on page
   */
  getReviewsComponent() {
    return this.winRef.document.querySelector("cx-product-reviews");
  }
  /**
   * Get Tabs Component if exists on page
   */
  getTabsComponent() {
    return this.winRef.document.querySelector("cx-tab-paragraph-container");
  }
  /**
   * Click to activate tab if not already active
   *
   * @param tab tab to click if needed
   */
  clickTabIfInactive(tab) {
    if (!tab.classList.contains("active") || tab.classList.contains("toggled")) {
      tab.click();
    }
  }
  /**
   * Get Tab by label if exists on page
   *
   * @param label label of searched tab
   * @param tabsComponent component containing tabs
   */
  getTabByLabel(label, tabsComponent) {
    const tabElements = tabsComponent.getElementsByTagName("button");
    return Array.from(tabElements).find((buttonElement) => buttonElement.innerHTML.includes(label));
  }
};
_ProductIntroComponent.\u0275fac = function ProductIntroComponent_Factory(t) {
  return new (t || _ProductIntroComponent)(\u0275\u0275directiveInject(CurrentProductService), \u0275\u0275directiveInject(TranslationService), \u0275\u0275directiveInject(WindowRef), \u0275\u0275directiveInject(EventService));
};
_ProductIntroComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductIntroComponent,
  selectors: [["cx-product-intro"]],
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], ["class", "rating", 4, "ngIf"], [1, "code"], [1, "rating"], [3, "rating"], [1, "count"], ["class", "btn btn-link cx-action-link", 3, "click", 4, "ngIf"], [1, "btn", "btn-link", "cx-action-link", 3, "click"]],
  template: function ProductIntroComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductIntroComponent_ng_container_0_Template, 6, 6, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.product$));
    }
  },
  dependencies: [NgIf, StarRatingComponent, AsyncPipe, DecimalPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductIntroComponent = _ProductIntroComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductIntroComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-intro",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="product$ | async as product">
  <div class="rating" *ngIf="product?.averageRating">
    <cx-star-rating [rating]="product?.averageRating ?? 0"></cx-star-rating>

    <div class="count">({{ product?.numberOfReviews }})</div>

    <button
      *ngIf="areReviewsAvailable$ | async"
      class="btn btn-link cx-action-link"
      (click)="showReviews()"
      [attr.aria-label]="
        'productSummary.showReviewsDetailed'
          | cxTranslate
            : {
                rating: product?.averageRating | number: '1.0-1',
                count: product?.numberOfReviews
              }
      "
    >
      {{ 'productSummary.showReviews' | cxTranslate }}
    </button>
  </div>
  <div class="rating" *ngIf="!product?.averageRating">
    {{ 'productDetails.noReviews' | cxTranslate }}
  </div>
  <div class="code">
    {{ 'productSummary.id' | cxTranslate }} {{ product?.code }}
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: CurrentProductService
  }, {
    type: TranslationService
  }, {
    type: WindowRef
  }, {
    type: EventService
  }], null);
})();
var _ProductIntroModule = class _ProductIntroModule {
};
_ProductIntroModule.\u0275fac = function ProductIntroModule_Factory(t) {
  return new (t || _ProductIntroModule)();
};
_ProductIntroModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductIntroModule
});
_ProductIntroModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductIntroComponent: {
        component: ProductIntroComponent
      }
    }
  })],
  imports: [CommonModule, I18nModule, StarRatingModule]
});
var ProductIntroModule = _ProductIntroModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductIntroModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, StarRatingModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductIntroComponent: {
            component: ProductIntroComponent
          }
        }
      })],
      declarations: [ProductIntroComponent],
      exports: [ProductIntroComponent]
    }]
  }], null, null);
})();
var _ProductSummaryComponent = class _ProductSummaryComponent {
  constructor(currentProductService) {
    this.currentProductService = currentProductService;
    this.outlets = ProductDetailOutlets;
    this.product$ = this.currentProductService.getProduct([
      "details",
      "price"
      /* ProductScope.PRICE */
    ]);
  }
};
_ProductSummaryComponent.\u0275fac = function ProductSummaryComponent_Factory(t) {
  return new (t || _ProductSummaryComponent)(\u0275\u0275directiveInject(CurrentProductService));
};
_ProductSummaryComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductSummaryComponent,
  selectors: [["cx-product-summary"]],
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [3, "cxOutlet", "cxOutletContext"], [1, "price"], [1, "summary", 3, "innerHTML"]],
  template: function ProductSummaryComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductSummaryComponent_ng_container_0_Template, 3, 8, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.product$));
    }
  },
  dependencies: [NgIf, OutletDirective, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductSummaryComponent = _ProductSummaryComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductSummaryComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-summary",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="product$ | async as product">
  <ng-template
    [cxOutlet]="outlets.PRICE"
    [cxOutletContext]="{ product: product }"
  >
    <div
      [attr.aria-label]="'productSummary.newItemPrice' | cxTranslate"
      class="price"
    >
      {{ product?.price?.formattedValue }}
    </div>
  </ng-template>

  <ng-template
    [cxOutlet]="outlets.SUMMARY"
    [cxOutletContext]="{ product: product }"
  >
    <p [innerHTML]="product?.summary" class="summary"></p>
  </ng-template>

  <!-- @TODO: Temp. Comment out share link while not in use by CMS -->
  <!-- <ng-container *cxOutlet="outlets.SHARE">
        <div>
          <a href="#" class="share btn-link">
            {{ 'productSummary.share' | cxTranslate }}
          </a>
        </div>
      </ng-container> -->
</ng-container>
`
    }]
  }], () => [{
    type: CurrentProductService
  }], null);
})();
var _ProductSummaryModule = class _ProductSummaryModule {
};
_ProductSummaryModule.\u0275fac = function ProductSummaryModule_Factory(t) {
  return new (t || _ProductSummaryModule)();
};
_ProductSummaryModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductSummaryModule
});
_ProductSummaryModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductSummaryComponent: {
        component: ProductSummaryComponent
      }
    }
  })],
  imports: [CommonModule, OutletModule, I18nModule]
});
var ProductSummaryModule = _ProductSummaryModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductSummaryModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, OutletModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductSummaryComponent: {
            component: ProductSummaryComponent
          }
        }
      })],
      declarations: [ProductSummaryComponent],
      exports: [ProductSummaryComponent]
    }]
  }], null, null);
})();
var _ProductAttributesComponent = class _ProductAttributesComponent {
  constructor(currentProductService) {
    this.currentProductService = currentProductService;
    this.product$ = this.currentProductService.getProduct(
      "attributes"
      /* ProductScope.ATTRIBUTES */
    );
  }
};
_ProductAttributesComponent.\u0275fac = function ProductAttributesComponent_Factory(t) {
  return new (t || _ProductAttributesComponent)(\u0275\u0275directiveInject(CurrentProductService));
};
_ProductAttributesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductAttributesComponent,
  selectors: [["cx-product-attributes"]],
  decls: 2,
  vars: 3,
  consts: [[4, "ngIf"], [1, "container"], [4, "ngFor", "ngForOf"]],
  template: function ProductAttributesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductAttributesComponent_ng_container_0_Template, 6, 4, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.product$));
    }
  },
  dependencies: [NgForOf, NgIf, AsyncPipe, TranslatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductAttributesComponent = _ProductAttributesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductAttributesComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-attributes",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="product$ | async as product">
  <div class="container">
    <h2>{{ 'productDetails.specification' | cxTranslate }}</h2>
    <table *ngFor="let class of product?.classifications">
      <th>
        <h2>{{ class.name }}</h2>
      </th>
      <tr *ngFor="let feature of class.features">
        <td>{{ feature.name }}</td>
        <td>
          <ul>
            <li *ngFor="let featureValue of feature?.featureValues">
              {{ featureValue?.value }}
              <span
                *ngIf="
                  feature.featureUnit &&
                  feature.featureUnit.symbol &&
                  feature.featureUnit.symbol.length > 0 &&
                  feature.featureUnit?.unitType !== '300'
                "
              >
                {{ feature.featureUnit?.symbol }}
              </span>
            </li>
          </ul>
        </td>
      </tr>
    </table>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: CurrentProductService
  }], null);
})();
var _ProductAttributesModule = class _ProductAttributesModule {
};
_ProductAttributesModule.\u0275fac = function ProductAttributesModule_Factory(t) {
  return new (t || _ProductAttributesModule)();
};
_ProductAttributesModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductAttributesModule
});
_ProductAttributesModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductSpecsTabComponent: {
        component: ProductAttributesComponent
      }
    }
  })],
  imports: [CommonModule, I18nModule]
});
var ProductAttributesModule = _ProductAttributesModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductAttributesModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductSpecsTabComponent: {
            component: ProductAttributesComponent
          }
        }
      })],
      declarations: [ProductAttributesComponent],
      exports: [ProductAttributesComponent]
    }]
  }], null, null);
})();
var _ProductDetailsTabComponent = class _ProductDetailsTabComponent {
  constructor(currentProductService, componentData, cmsService) {
    this.currentProductService = currentProductService;
    this.componentData = componentData;
    this.cmsService = cmsService;
    this.children$ = this.componentData.data$.pipe(switchMap((data) => combineLatest((data?.children ?? "").split(" ").map((component) => this.cmsService.getComponentData(component).pipe(distinctUntilChanged(), map((child) => {
      if (!child) {
        return void 0;
      }
      if (!child.flexType) {
        child = __spreadProps(__spreadValues({}, child), {
          flexType: child.typeCode
        });
      }
      return child;
    }))))));
  }
  ngOnInit() {
    this.product$ = this.currentProductService.getProduct();
  }
};
_ProductDetailsTabComponent.\u0275fac = function ProductDetailsTabComponent_Factory(t) {
  return new (t || _ProductDetailsTabComponent)(\u0275\u0275directiveInject(CurrentProductService), \u0275\u0275directiveInject(CmsComponentData), \u0275\u0275directiveInject(CmsService));
};
_ProductDetailsTabComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductDetailsTabComponent,
  selectors: [["cx-product-details-tab"]],
  decls: 4,
  vars: 6,
  consts: [[4, "ngIf"], [1, "container", 3, "innerHTML"], [4, "ngFor", "ngForOf"], [3, "cxOutlet", "cxOutletContext"], [1, "container"], [3, "cxComponentWrapper"]],
  template: function ProductDetailsTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductDetailsTabComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, ProductDetailsTabComponent_ng_container_2_Template, 2, 1, "ng-container", 0);
      \u0275\u0275pipe(3, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 2, ctx.product$));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(3, 4, ctx.children$));
    }
  },
  dependencies: [NgForOf, NgIf, ComponentWrapperDirective, OutletDirective, AsyncPipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductDetailsTabComponent = _ProductDetailsTabComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductDetailsTabComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-details-tab",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<ng-container *ngIf="product$ | async as product">\n  <div class="container" [innerHTML]="product?.description"></div>\n</ng-container>\n<ng-container *ngIf="children$ | async as children">\n  <ng-container *ngFor="let child of children">\n    <ng-container *ngIf="child">\n      <ng-template [cxOutlet]="child.flexType" [cxOutletContext]="{}">\n        <div class="container">\n          <ng-container [cxComponentWrapper]="child"></ng-container>\n        </div>\n      </ng-template>\n    </ng-container>\n  </ng-container>\n</ng-container>\n'
    }]
  }], () => [{
    type: CurrentProductService
  }, {
    type: CmsComponentData
  }, {
    type: CmsService
  }], null);
})();
var _ProductDetailsTabModule = class _ProductDetailsTabModule {
};
_ProductDetailsTabModule.\u0275fac = function ProductDetailsTabModule_Factory(t) {
  return new (t || _ProductDetailsTabModule)();
};
_ProductDetailsTabModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductDetailsTabModule
});
_ProductDetailsTabModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductDetailsTabComponent: {
        component: ProductDetailsTabComponent
      }
    }
  })],
  imports: [CommonModule, PageComponentModule, OutletModule]
});
var ProductDetailsTabModule = _ProductDetailsTabModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductDetailsTabModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PageComponentModule, OutletModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductDetailsTabComponent: {
            component: ProductDetailsTabComponent
          }
        }
      })],
      declarations: [ProductDetailsTabComponent],
      exports: [ProductDetailsTabComponent]
    }]
  }], null, null);
})();
var _ProductReviewsComponent = class _ProductReviewsComponent {
  constructor(reviewService, currentProductService, fb, cd) {
    this.reviewService = reviewService;
    this.currentProductService = currentProductService;
    this.fb = fb;
    this.cd = cd;
    this.isWritingReview = false;
    this.initialMaxListItems = 5;
    this.product$ = this.currentProductService.getProduct();
    this.reviews$ = this.product$.pipe(filter(isNotNullable), map((p) => p.code ?? ""), distinctUntilChanged(), switchMap((productCode) => this.reviewService.getByProductCode(productCode)), tap(() => {
      this.resetReviewForm();
      this.maxListItems = this.initialMaxListItems;
    }));
  }
  initiateWriteReview() {
    this.isWritingReview = true;
    this.cd.detectChanges();
    if (this.titleInput && this.titleInput.nativeElement) {
      this.titleInput.nativeElement.focus();
    }
  }
  cancelWriteReview() {
    this.isWritingReview = false;
    this.resetReviewForm();
    this.cd.detectChanges();
    if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
      this.writeReviewButton.nativeElement.focus();
    }
  }
  setRating(rating) {
    this.reviewForm.controls.rating.setValue(rating);
  }
  submitReview(product) {
    if (this.reviewForm.valid) {
      this.addReview(product);
    } else {
      this.reviewForm.markAllAsTouched();
    }
  }
  addReview(product) {
    const reviewFormControls = this.reviewForm.controls;
    const review = {
      headline: reviewFormControls.title.value,
      comment: reviewFormControls.comment.value,
      rating: reviewFormControls.rating.value,
      alias: reviewFormControls.reviewerName.value
    };
    this.reviewService.add(product.code ?? "", review);
    this.isWritingReview = false;
    this.resetReviewForm();
    this.cd.detectChanges();
    if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
      this.writeReviewButton.nativeElement.focus();
    }
  }
  resetReviewForm() {
    this.reviewForm = this.fb.group({
      title: ["", Validators.required],
      comment: ["", Validators.required],
      rating: [null, CustomFormValidators.starRatingEmpty],
      reviewerName: ""
    });
  }
};
_ProductReviewsComponent.\u0275fac = function ProductReviewsComponent_Factory(t) {
  return new (t || _ProductReviewsComponent)(\u0275\u0275directiveInject(ProductReviewService), \u0275\u0275directiveInject(CurrentProductService), \u0275\u0275directiveInject(UntypedFormBuilder), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ProductReviewsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ProductReviewsComponent,
  selectors: [["cx-product-reviews"]],
  viewQuery: function ProductReviewsComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c49, 5);
      \u0275\u0275viewQuery(_c50, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.titleInput = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.writeReviewButton = _t.first);
    }
  },
  decls: 2,
  vars: 3,
  consts: [["writeReview", ""], ["writeReviewButton", ""], ["titleInput", ""], ["class", "container", 4, "ngIf"], [1, "container"], [4, "ngIf", "ngIfElse"], [1, "header"], [1, "btn", "btn-primary", 3, "click"], ["class", "rating", 3, "rating", 4, "ngIf"], ["class", "rating", 4, "ngIf"], [1, "rating", 3, "rating"], [1, "rating"], [4, "ngIf"], ["class", "review", "tabindex", "0", 4, "ngFor", "ngForOf"], ["tabindex", "0", 1, "review"], [1, "title"], [3, "rating"], [1, "name"], [1, "date"], [1, "text"], ["class", "btn btn-primary", 3, "click", 4, "ngIf"], [3, "ngSubmit", "formGroup"], [1, "form-group"], [1, "label-content"], ["required", "true", "type", "text", "formControlName", "title", 1, "form-control"], [3, "control"], ["required", "true", "rows", "3", "formControlName", "comment", 1, "form-control"], ["required", "true", "type", "number", "formControlName", "rating", 1, "rating-input"], ["tabindex", "0", 3, "change", "disabled"], ["type", "text", "formControlName", "reviewerName", 1, "form-control"], [1, "form-group", "row"], [1, "col-12", "col-md-4"], ["type", "button", 1, "btn", "btn-block", "btn-secondary", 3, "click"], ["type", "submit", 1, "btn", "btn-block", "btn-primary"]],
  template: function ProductReviewsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ProductReviewsComponent_div_0_Template, 7, 6, "div", 3);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.product$));
    }
  },
  dependencies: [NgForOf, NgIf, \u0275NgNoValidate, DefaultValueAccessor, NumberValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, FormGroupDirective, FormControlName, StarRatingComponent, FormErrorsComponent, AsyncPipe, SlicePipe, TranslatePipe, CxDatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var ProductReviewsComponent = _ProductReviewsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductReviewsComponent, [{
    type: Component,
    args: [{
      selector: "cx-product-reviews",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div class="container" *ngIf="product$ | async as product">
  <h2>
    {{ 'productDetails.reviews' | cxTranslate }} ({{ product.numberOfReviews }})
  </h2>
  <ng-container *ngIf="!isWritingReview; else writeReview">
    <div class="header">
      <h3>{{ 'productReview.overallRating' | cxTranslate }}</h3>
      <button
        #writeReviewButton
        class="btn btn-primary"
        (click)="initiateWriteReview()"
      >
        {{ 'productReview.writeReview' | cxTranslate }}
      </button>
      <cx-star-rating
        *ngIf="product.averageRating"
        class="rating"
        [rating]="product.averageRating"
      ></cx-star-rating>
      <div class="rating" *ngIf="!product.averageRating">
        {{ 'productDetails.noReviews' | cxTranslate }}
      </div>
    </div>

    <ng-container *ngIf="!isWritingReview; else writeReview">
      <ng-container *ngIf="reviews$ | async as reviews">
        <div
          class="review"
          tabindex="0"
          *ngFor="let review of reviews | slice: 0:maxListItems"
        >
          <div class="title">{{ review.headline }}</div>
          <cx-star-rating [rating]="review.rating ?? 0"></cx-star-rating>
          <div class="name">
            {{ review.alias ? review.alias : review.principal?.name }}
          </div>
          <div class="date">{{ review.date | cxDate }}</div>
          <div class="text">{{ review.comment }}</div>
        </div>
        <div *ngIf="reviews.length > initialMaxListItems">
          <button
            class="btn btn-primary"
            (click)="maxListItems = reviews.length"
            *ngIf="maxListItems === initialMaxListItems"
          >
            {{ 'productReview.more' | cxTranslate }}
          </button>
          <button
            class="btn btn-primary"
            (click)="maxListItems = initialMaxListItems"
            *ngIf="maxListItems !== initialMaxListItems"
          >
            {{ 'productReview.less' | cxTranslate }}
          </button>
        </div>
      </ng-container>
    </ng-container>
  </ng-container>

  <ng-template #writeReview>
    <form (ngSubmit)="submitReview(product)" [formGroup]="reviewForm">
      <div class="form-group">
        <label>
          <span class="label-content">{{
            'productReview.reviewTitle' | cxTranslate
          }}</span>
          <input
            required="true"
            #titleInput
            type="text"
            class="form-control"
            formControlName="title"
          />
          <cx-form-errors [control]="reviewForm.get('title')"></cx-form-errors>
        </label>
      </div>
      <div class="form-group">
        <label>
          <span class="label-content">{{
            'productReview.writeYourComments' | cxTranslate
          }}</span>
          <textarea
            required="true"
            class="form-control"
            rows="3"
            formControlName="comment"
          ></textarea>
          <cx-form-errors
            [control]="reviewForm.get('comment')"
          ></cx-form-errors>
        </label>
      </div>
      <div class="form-group">
        <label>
          <span class="label-content">{{
            'productReview.rating' | cxTranslate
          }}</span>
          <input
            required="true"
            type="number"
            formControlName="rating"
            class="rating-input"
          />
          <cx-star-rating
            tabindex="0"
            [attr.aria-label]="'productReview.ratingRequired' | cxTranslate"
            (change)="setRating($event)"
            [disabled]="false"
          ></cx-star-rating>
          <cx-form-errors [control]="reviewForm.get('rating')"></cx-form-errors>
        </label>
      </div>
      <div class="form-group">
        <label>
          <span class="label-content">{{
            'productReview.reviewerName' | cxTranslate
          }}</span>
          <input
            type="text"
            class="form-control"
            formControlName="reviewerName"
          />
        </label>
      </div>
      <div class="form-group row">
        <div class="col-12 col-md-4">
          <button
            type="button"
            class="btn btn-block btn-secondary"
            (click)="cancelWriteReview()"
          >
            {{ 'common.cancel' | cxTranslate }}
          </button>
        </div>
        <div class="col-12 col-md-4">
          <button type="submit" class="btn btn-block btn-primary">
            {{ 'common.submit' | cxTranslate }}
          </button>
        </div>
      </div>
    </form>
  </ng-template>
</div>
`
    }]
  }], () => [{
    type: ProductReviewService
  }, {
    type: CurrentProductService
  }, {
    type: UntypedFormBuilder
  }, {
    type: ChangeDetectorRef
  }], {
    titleInput: [{
      type: ViewChild,
      args: ["titleInput", {
        static: false
      }]
    }],
    writeReviewButton: [{
      type: ViewChild,
      args: ["writeReviewButton", {
        static: false
      }]
    }]
  });
})();
var _ProductReviewsModule = class _ProductReviewsModule {
};
_ProductReviewsModule.\u0275fac = function ProductReviewsModule_Factory(t) {
  return new (t || _ProductReviewsModule)();
};
_ProductReviewsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductReviewsModule
});
_ProductReviewsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    cmsComponents: {
      ProductReviewsTabComponent: {
        component: ProductReviewsComponent
      }
    }
  })],
  imports: [CommonModule, ReactiveFormsModule, FormsModule, I18nModule, StarRatingModule, FormErrorsModule]
});
var ProductReviewsModule = _ProductReviewsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductReviewsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ReactiveFormsModule, FormsModule, I18nModule, StarRatingModule, FormErrorsModule],
      providers: [provideDefaultConfig({
        cmsComponents: {
          ProductReviewsTabComponent: {
            component: ProductReviewsComponent
          }
        }
      })],
      declarations: [ProductReviewsComponent],
      exports: [ProductReviewsComponent]
    }]
  }], null, null);
})();
var _ProductTabsModule = class _ProductTabsModule {
};
_ProductTabsModule.\u0275fac = function ProductTabsModule_Factory(t) {
  return new (t || _ProductTabsModule)();
};
_ProductTabsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductTabsModule
});
_ProductTabsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ProductAttributesModule, ProductDetailsTabModule, ProductReviewsModule]
});
var ProductTabsModule = _ProductTabsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductTabsModule, [{
    type: NgModule,
    args: [{
      imports: [ProductAttributesModule, ProductDetailsTabModule, ProductReviewsModule]
    }]
  }], null, null);
})();
var _StockNotificationDialogComponent = class _StockNotificationDialogComponent {
  handleClick(event) {
    if (event.target.tagName === this.el.nativeElement.tagName) {
      this.close("Cross click");
    }
  }
  constructor(interestsService, launchDialogService, el) {
    this.interestsService = interestsService;
    this.launchDialogService = launchDialogService;
    this.el = el;
    this.subscription = new Subscription();
    this.enabledPrefs = [];
    this.focusConfig = {
      trap: true,
      block: true,
      autofocus: "button",
      focusOnEscape: true
    };
  }
  close(reason) {
    this.launchDialogService.closeDialog(reason);
  }
  ngOnInit() {
    this.subscription.add(this.launchDialogService.data$.subscribe((data) => {
      if (data) {
        this.init(data.subscribeSuccess$, data.enabledPrefs);
      }
    }));
  }
  init(subscribeSuccess$, enabledPrefs) {
    this.subscribeSuccess$ = subscribeSuccess$;
    this.enabledPrefs = enabledPrefs;
  }
  ngOnDestroy() {
    if (this.subscribeSuccess$) {
      this.subscribeSuccess$.subscribe((success) => {
        if (success) {
          this.interestsService.resetAddInterestState();
        }
      }).unsubscribe();
    }
    this.subscription.unsubscribe();
  }
};
_StockNotificationDialogComponent.\u0275fac = function StockNotificationDialogComponent_Factory(t) {
  return new (t || _StockNotificationDialogComponent)(\u0275\u0275directiveInject(UserInterestsService), \u0275\u0275directiveInject(LaunchDialogService), \u0275\u0275directiveInject(ElementRef));
};
_StockNotificationDialogComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _StockNotificationDialogComponent,
  selectors: [["cx-stock-notification-dialog"]],
  hostBindings: function StockNotificationDialogComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function StockNotificationDialogComponent_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
  },
  decls: 14,
  vars: 11,
  consts: [["loading", ""], [1, "cx-stock-notification-dialog", 3, "esc", "cxFocus"], [1, "cx-stock-notification-container"], [1, "cx-dialog-header", "cx-modal-header"], [1, "cx-dialog-title", "modal-title"], ["type", "button", "tabindex", "-1", 1, "close", 3, "click"], ["aria-hidden", "true"], [4, "ngIf", "ngIfElse"], ["role", "status"], [1, "cx-dialog-body", "modal-body"], [1, "cx-stock-notification-content"], [1, "cx-stock-notification-text"], ["class", "channels", 4, "ngFor", "ngForOf"], [1, "link-prefs", "cx-stock-notification-link", 3, "click", "routerLink"], [1, "link-interests", "cx-stock-notification-link", 3, "click", "routerLink"], [1, "cx-modal-footer"], [1, "row"], [1, "cx-dialog-actions", "col-sm-12", "col-md-4", "offset-md-8", "col-lg-3", "offset-lg-9"], ["type", "button", 1, "btn", "btn-primary", "btn-block", "btn-ok", 3, "click"], [1, "channels"], [4, "ngIf"], [1, "cx-dialog-row"], [1, "col-sm-12"]],
  template: function StockNotificationDialogComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 1);
      \u0275\u0275listener("esc", function StockNotificationDialogComponent_Template_div_esc_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.close("Escape clicked"));
      });
      \u0275\u0275elementStart(1, "div", 2)(2, "div", 3)(3, "div", 4);
      \u0275\u0275text(4);
      \u0275\u0275pipe(5, "cxTranslate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "button", 5);
      \u0275\u0275pipe(7, "cxTranslate");
      \u0275\u0275listener("click", function StockNotificationDialogComponent_Template_button_click_6_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.close("Button clicked"));
      });
      \u0275\u0275elementStart(8, "span", 6);
      \u0275\u0275text(9, "\xD7");
      \u0275\u0275elementEnd()()();
      \u0275\u0275template(10, StockNotificationDialogComponent_ng_container_10_Template, 36, 39, "ng-container", 7);
      \u0275\u0275pipe(11, "async");
      \u0275\u0275elementEnd();
      \u0275\u0275template(12, StockNotificationDialogComponent_ng_template_12_Template, 7, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const loading_r5 = \u0275\u0275reference(13);
      \u0275\u0275property("cxFocus", ctx.focusConfig);
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(5, 5, "stockNotification.subscriptionDialog.header"), " ");
      \u0275\u0275advance(2);
      \u0275\u0275attribute("aria-label", \u0275\u0275pipeBind1(7, 7, "common.close"));
      \u0275\u0275advance(4);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(11, 9, ctx.subscribeSuccess$))("ngIfElse", loading_r5);
    }
  },
  dependencies: [NgForOf, NgIf, RouterLink, SpinnerComponent, FocusDirective, AsyncPipe, TranslatePipe, UrlPipe],
  encapsulation: 2,
  changeDetection: 0
});
var StockNotificationDialogComponent = _StockNotificationDialogComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockNotificationDialogComponent, [{
    type: Component,
    args: [{
      selector: "cx-stock-notification-dialog",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div
  class="cx-stock-notification-dialog"
  [cxFocus]="focusConfig"
  (esc)="close('Escape clicked')"
>
  <div class="cx-stock-notification-container">
    <div class="cx-dialog-header cx-modal-header">
      <div class="cx-dialog-title modal-title">
        {{ 'stockNotification.subscriptionDialog.header' | cxTranslate }}
      </div>
      <button
        type="button"
        [attr.aria-label]="'common.close' | cxTranslate"
        class="close"
        tabindex="-1"
        (click)="close('Button clicked')"
      >
        <span aria-hidden="true">&times;</span>
      </button>
    </div>

    <ng-container *ngIf="subscribeSuccess$ | async; else loading">
      <div
        role="status"
        [attr.aria-label]="'common.loaded' | cxTranslate"
      ></div>
      <div class="cx-dialog-body modal-body">
        <div class="cx-stock-notification-content">
          <p class="cx-stock-notification-text">
            {{
              'stockNotification.subscriptionDialog.notifiedPrefix'
                | cxTranslate
            }}
          </p>
          <p *ngFor="let preference of enabledPrefs" class="channels">
            <span>{{ preference.channel }}</span
            ><span *ngIf="preference.value">{{ ': ' + preference.value }}</span>
          </p>
          <p class="cx-stock-notification-text">
            {{
              'stockNotification.subscriptionDialog.notifiedSuffix'
                | cxTranslate
            }}
          </p>
          <p class="cx-stock-notification-text">
            {{
              'stockNotification.subscriptionDialog.manageChannelsPrefix'
                | cxTranslate
            }}
            <a
              (click)="close('Link clicked')"
              [routerLink]="{ cxRoute: 'notificationPreference' } | cxUrl"
              class="link-prefs cx-stock-notification-link"
            >
              {{
                'stockNotification.subscriptionDialog.manageChannelsLink'
                  | cxTranslate
              }}</a
            >
            {{
              'stockNotification.subscriptionDialog.manageChannelsSuffix'
                | cxTranslate
            }}
          </p>

          <p class="cx-stock-notification-text">
            {{
              'stockNotification.subscriptionDialog.manageSubscriptionsPrefix'
                | cxTranslate
            }}
            <a
              (click)="close('Link clicked')"
              [routerLink]="{ cxRoute: 'myInterests' } | cxUrl"
              class="link-interests cx-stock-notification-link"
            >
              {{
                'stockNotification.subscriptionDialog.manageSubscriptionsLink'
                  | cxTranslate
              }}</a
            >
            {{
              'stockNotification.subscriptionDialog.manageSubscriptionsSuffix'
                | cxTranslate
            }}
          </p>
        </div>
      </div>
      <div class="cx-modal-footer">
        <div class="row">
          <div
            class="
              cx-dialog-actions
              col-sm-12 col-md-4
              offset-md-8
              col-lg-3
              offset-lg-9
            "
          >
            <button
              class="btn btn-primary btn-block btn-ok"
              type="button"
              (click)="close('Button clicked')"
            >
              {{ 'stockNotification.subscriptionDialog.okBtn' | cxTranslate }}
            </button>
          </div>
        </div>
      </div>
    </ng-container>
  </div>

  <ng-template #loading>
    <div class="cx-dialog-body modal-body">
      <p>
        {{ 'stockNotification.subscriptionDialog.subscribing' | cxTranslate }}
      </p>
      <div class="cx-dialog-row">
        <div class="col-sm-12">
          <cx-spinner></cx-spinner>
        </div>
      </div>
    </div>
  </ng-template>
</div>
`
    }]
  }], () => [{
    type: UserInterestsService
  }, {
    type: LaunchDialogService
  }, {
    type: ElementRef
  }], {
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _StockNotificationComponent = class _StockNotificationComponent {
  constructor(currentProductService, globalMessageService, translationService, interestsService, notificationPrefService, userIdService, launchDialogService, vcr) {
    this.currentProductService = currentProductService;
    this.globalMessageService = globalMessageService;
    this.translationService = translationService;
    this.interestsService = interestsService;
    this.notificationPrefService = notificationPrefService;
    this.userIdService = userIdService;
    this.launchDialogService = launchDialogService;
    this.vcr = vcr;
    this.anonymous = true;
    this.enabledPrefs = [];
    this.subscriptions = new Subscription();
  }
  ngOnInit() {
    this.outOfStock$ = combineLatest([this.currentProductService.getProduct().pipe(filter(isNotNullable)), this.userIdService.getUserId()]).pipe(tap(([product, userId]) => {
      this.productCode = product.code ?? "";
      if (userId !== OCC_USER_ID_ANONYMOUS) {
        this.anonymous = false;
        this.notificationPrefService.loadPreferences();
        this.interestsService.loadProductInterests(void 0, void 0, void 0, product.code, NotificationType.BACK_IN_STOCK);
      }
    }), map(([product]) => !!product.stock && product.stock.stockLevelStatus === "outOfStock"));
    this.hasProductInterests$ = this.interestsService.getProductInterests().pipe(map((interests) => !!interests.results && interests.results.length === 1));
    this.subscribeSuccess$ = this.interestsService.getAddProductInterestSuccess();
    this.isRemoveInterestLoading$ = this.interestsService.getRemoveProdutInterestLoading();
    this.prefsEnabled$ = this.notificationPrefService.getEnabledPreferences().pipe(tap((prefs) => this.enabledPrefs = prefs), map((prefs) => prefs.length > 0));
    this.subscriptions.add(this.interestsService.getAddProductInterestError().subscribe((error) => {
      if (error) {
        this.onInterestAddingError();
      }
    }));
    this.subscriptions.add(this.interestsService.getRemoveProdutInterestSuccess().subscribe((success) => {
      if (success) {
        this.onInterestRemovingSuccess();
      }
    }));
  }
  subscribe() {
    this.openDialog();
    this.interestsService.addProductInterest(this.productCode, NotificationType.BACK_IN_STOCK);
  }
  unsubscribe() {
    this.interestsService.removeProdutInterest({
      product: {
        code: this.productCode
      },
      productInterestEntry: [{
        interestType: NotificationType.BACK_IN_STOCK
      }]
    }, true);
  }
  onInterestRemovingSuccess() {
    this.subscriptions.add(this.translationService.translate("stockNotification.unsubscribeSuccess").pipe(first()).subscribe((text) => this.globalMessageService.add(text, GlobalMessageType.MSG_TYPE_INFO)));
    this.interestsService.resetRemoveInterestState();
  }
  onInterestAddingError() {
    this.launchDialogService.closeDialog("Interests error");
    this.interestsService.resetAddInterestState();
  }
  openDialog() {
    const modalInstanceData = {
      subscribeSuccess$: this.subscribeSuccess$,
      enabledPrefs: this.enabledPrefs
    };
    const dialog = this.launchDialogService.openDialog("STOCK_NOTIFICATION", this.element, this.vcr, modalInstanceData);
    if (dialog) {
      dialog.pipe(take(1)).subscribe();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.interestsService.clearProductInterests();
    this.notificationPrefService.clearPreferences();
  }
};
_StockNotificationComponent.\u0275fac = function StockNotificationComponent_Factory(t) {
  return new (t || _StockNotificationComponent)(\u0275\u0275directiveInject(CurrentProductService), \u0275\u0275directiveInject(GlobalMessageService), \u0275\u0275directiveInject(TranslationService), \u0275\u0275directiveInject(UserInterestsService), \u0275\u0275directiveInject(UserNotificationPreferenceService), \u0275\u0275directiveInject(UserIdService), \u0275\u0275directiveInject(LaunchDialogService), \u0275\u0275directiveInject(ViewContainerRef));
};
_StockNotificationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _StockNotificationComponent,
  selectors: [["cx-stock-notification"]],
  viewQuery: function StockNotificationComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c29, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.element = _t.first);
    }
  },
  decls: 8,
  vars: 3,
  consts: [["disableNotify", ""], ["stopNotify", ""], ["loading", ""], ["loggedIn", ""], [4, "ngIf"], [4, "ngIf", "ngIfElse"], [1, "stock-notification-notes"], ["type", "button", 1, "btn", "btn-primary", "btn-block", "btn-notify", 3, "click"], ["id", "outOfStockMessage", 1, "stock-notification-notes"], ["type", "button", "aria-describedby", "outOfStockMessage", 1, "btn", "btn-primary", "btn-block", "btn-notify", 3, "click"], [3, "routerLink"], ["role", "status"], ["type", "button", 1, "btn", "btn-primary", "btn-block", "btn-stop-notify", 3, "click"], [1, "cx-dialog-body", "modal-body"], [1, "cx-dialog-row"], [1, "col-sm-12"]],
  template: function StockNotificationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, StockNotificationComponent_ng_container_0_Template, 3, 4, "ng-container", 4);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275template(2, StockNotificationComponent_ng_template_2_Template, 8, 6, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(4, StockNotificationComponent_ng_template_4_Template, 2, 4, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(6, StockNotificationComponent_ng_template_6_Template, 4, 0, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.outOfStock$));
    }
  },
  dependencies: [NgIf, RouterLink, SpinnerComponent, AsyncPipe, TranslatePipe, UrlPipe],
  encapsulation: 2,
  changeDetection: 0
});
var StockNotificationComponent = _StockNotificationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockNotificationComponent, [{
    type: Component,
    args: [{
      selector: "cx-stock-notification",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container *ngIf="outOfStock$ | async">
  <ng-container *ngIf="!(hasProductInterests$ | async); else stopNotify">
    <ng-container *ngIf="prefsEnabled$ | async; else disableNotify">
      <div class="stock-notification-notes">
        <p>{{ 'stockNotification.getNotified' | cxTranslate }}</p>
      </div>
      <button
        class="btn btn-primary btn-block btn-notify"
        type="button"
        (click)="subscribe()"
      >
        {{ 'stockNotification.notifyMe' | cxTranslate }}
      </button>
    </ng-container>
  </ng-container>
</ng-container>

<ng-template #disableNotify>
  <div class="stock-notification-notes" id="outOfStockMessage">
    <p>
      <ng-container *ngIf="anonymous; else loggedIn">
        <a [routerLink]="{ cxRoute: 'login' } | cxUrl">
          {{ 'miniLogin.signInRegister' | cxTranslate }}</a
        >
        {{ 'stockNotification.getNotifySuffix' | cxTranslate }}<br />
      </ng-container>
      <ng-template #loggedIn>
        {{ 'stockNotification.getNotify' | cxTranslate }}<br />
        {{ 'stockNotification.activateChannelsPrefix' | cxTranslate }}
        <a [routerLink]="{ cxRoute: 'notificationPreference' } | cxUrl">{{
          'stockNotification.channelsLink' | cxTranslate
        }}</a
        >{{ 'stockNotification.activateChannelsSuffix' | cxTranslate }}
      </ng-template>
    </p>
  </div>
  <button
    class="btn btn-primary btn-block btn-notify"
    type="button"
    [attr.disabled]="anonymous ? true : null"
    aria-describedby="outOfStockMessage"
    (click)="subscribe()"
  >
    {{ 'stockNotification.notifyMe' | cxTranslate }}
  </button>
</ng-template>

<ng-template #stopNotify>
  <ng-container *ngIf="!(isRemoveInterestLoading$ | async); else loading">
    <div role="status" [attr.aria-label]="'common.loaded' | cxTranslate"></div>
    <div class="stock-notification-notes">
      <p>{{ 'stockNotification.notified' | cxTranslate }}</p>
    </div>
    <button
      class="btn btn-primary btn-block btn-stop-notify"
      type="button"
      (click)="unsubscribe()"
    >
      {{ 'stockNotification.stopNotify' | cxTranslate }}
    </button>
  </ng-container>
</ng-template>

<ng-template #loading>
  <div class="cx-dialog-body modal-body">
    <div class="cx-dialog-row">
      <div class="col-sm-12">
        <cx-spinner></cx-spinner>
      </div>
    </div>
  </div>
</ng-template>
`
    }]
  }], () => [{
    type: CurrentProductService
  }, {
    type: GlobalMessageService
  }, {
    type: TranslationService
  }, {
    type: UserInterestsService
  }, {
    type: UserNotificationPreferenceService
  }, {
    type: UserIdService
  }, {
    type: LaunchDialogService
  }, {
    type: ViewContainerRef
  }], {
    element: [{
      type: ViewChild,
      args: ["element"]
    }]
  });
})();
var defaultStockNotificationLayoutConfig = {
  launch: {
    STOCK_NOTIFICATION: {
      inlineRoot: true,
      component: StockNotificationDialogComponent,
      dialogType: DIALOG_TYPE.DIALOG
    }
  }
};
var _StockNotificationModule = class _StockNotificationModule {
};
_StockNotificationModule.\u0275fac = function StockNotificationModule_Factory(t) {
  return new (t || _StockNotificationModule)();
};
_StockNotificationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _StockNotificationModule
});
_StockNotificationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultStockNotificationLayoutConfig), provideDefaultConfig({
    cmsComponents: {
      StockNotificationComponent: {
        component: StockNotificationComponent
      }
    }
  })],
  imports: [CommonModule, RouterModule, I18nModule, SpinnerModule, UrlModule, KeyboardFocusModule]
});
var StockNotificationModule = _StockNotificationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockNotificationModule, [{
    type: NgModule,
    args: [{
      declarations: [StockNotificationComponent, StockNotificationDialogComponent],
      imports: [CommonModule, RouterModule, I18nModule, SpinnerModule, UrlModule, KeyboardFocusModule],
      providers: [provideDefaultConfig(defaultStockNotificationLayoutConfig), provideDefaultConfig({
        cmsComponents: {
          StockNotificationComponent: {
            component: StockNotificationComponent
          }
        }
      })],
      exports: [StockNotificationComponent, StockNotificationDialogComponent]
    }]
  }], null, null);
})();
var _LoginGuard = class _LoginGuard {
  constructor(authService, authConfigService, cmsPageGuard) {
    this.authService = authService;
    this.authConfigService = authConfigService;
    this.cmsPageGuard = cmsPageGuard;
  }
  canActivate(route, state) {
    return this.authService.isUserLoggedIn().pipe(take(1), switchMap((isUserLoggedIn) => {
      if (this.authConfigService.getOAuthFlow() === OAuthFlow.ResourceOwnerPasswordFlow || isUserLoggedIn) {
        return this.cmsPageGuard.canActivate(route, state);
      } else {
        const redirected = this.authService.loginWithRedirect();
        if (!redirected) {
          return of(false);
        }
        return EMPTY;
      }
    }));
  }
};
_LoginGuard.\u0275fac = function LoginGuard_Factory(t) {
  return new (t || _LoginGuard)(\u0275\u0275inject(AuthService), \u0275\u0275inject(AuthConfigService), \u0275\u0275inject(CmsPageGuard));
};
_LoginGuard.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LoginGuard,
  factory: _LoginGuard.\u0275fac,
  providedIn: "root"
});
var LoginGuard = _LoginGuard;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoginGuard, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AuthService
  }, {
    type: AuthConfigService
  }, {
    type: CmsPageGuard
  }], null);
})();
var _LoginRouteModule = class _LoginRouteModule {
};
_LoginRouteModule.\u0275fac = function LoginRouteModule_Factory(t) {
  return new (t || _LoginRouteModule)();
};
_LoginRouteModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LoginRouteModule
});
_LoginRouteModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [PageLayoutModule, RouterModule.forChild([{
    // @ts-ignore
    path: null,
    canActivate: [LoginGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "login"
    }
  }])]
});
var LoginRouteModule = _LoginRouteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoginRouteModule, [{
    type: NgModule,
    args: [{
      imports: [PageLayoutModule, RouterModule.forChild([{
        // @ts-ignore
        path: null,
        canActivate: [LoginGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "login"
        }
      }])]
    }]
  }], null, null);
})();
var _LogoutGuard = class _LogoutGuard {
  constructor(auth, cms, semanticPathService, protectedRoutes, router) {
    this.auth = auth;
    this.cms = cms;
    this.semanticPathService = semanticPathService;
    this.protectedRoutes = protectedRoutes;
    this.router = router;
  }
  canActivate() {
    return from(this.logout()).pipe(switchMap(() => {
      return this.cms.hasPage({
        id: this.semanticPathService.get("logout") ?? "",
        type: PageType.CONTENT_PAGE
      }).pipe(map((hasPage) => {
        if (!hasPage) {
          return this.getRedirectUrl();
        }
        return hasPage;
      }));
    }));
  }
  logout() {
    return this.auth.coreLogout();
  }
  /**
   * Whenever there is no specific "logout" page configured in the CMS,
   * we redirect after the user is logged out.
   *
   * The user gets redirected to the homepage, unless the homepage is protected
   * (in case of a closed shop). We'll redirect to the login page instead.
   */
  getRedirectUrl() {
    const cxRoute = this.protectedRoutes.shouldProtect ? "login" : "home";
    return this.router.parseUrl(this.semanticPathService.get(cxRoute) ?? "");
  }
};
_LogoutGuard.\u0275fac = function LogoutGuard_Factory(t) {
  return new (t || _LogoutGuard)(\u0275\u0275inject(AuthService), \u0275\u0275inject(CmsService), \u0275\u0275inject(SemanticPathService), \u0275\u0275inject(ProtectedRoutesService), \u0275\u0275inject(Router));
};
_LogoutGuard.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LogoutGuard,
  factory: _LogoutGuard.\u0275fac,
  providedIn: "root"
});
var LogoutGuard = _LogoutGuard;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogoutGuard, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AuthService
  }, {
    type: CmsService
  }, {
    type: SemanticPathService
  }, {
    type: ProtectedRoutesService
  }, {
    type: Router
  }], null);
})();
var _LogoutModule = class _LogoutModule {
};
_LogoutModule.\u0275fac = function LogoutModule_Factory(t) {
  return new (t || _LogoutModule)();
};
_LogoutModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LogoutModule
});
_LogoutModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [PageLayoutModule, RouterModule.forChild([{
    // @ts-ignore
    path: null,
    canActivate: [LogoutGuard, CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "logout"
    }
  }])]
});
var LogoutModule = _LogoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogoutModule, [{
    type: NgModule,
    args: [{
      imports: [PageLayoutModule, RouterModule.forChild([{
        // @ts-ignore
        path: null,
        canActivate: [LogoutGuard, CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "logout"
        }
      }])]
    }]
  }], null, null);
})();
var _UserComponentModule = class _UserComponentModule {
};
_UserComponentModule.\u0275fac = function UserComponentModule_Factory(t) {
  return new (t || _UserComponentModule)();
};
_UserComponentModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _UserComponentModule
});
_UserComponentModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [LogoutModule, LoginRouteModule, ReactiveFormsModule, RouterModule, UrlModule]
});
var UserComponentModule = _UserComponentModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UserComponentModule, [{
    type: NgModule,
    args: [{
      imports: [LogoutModule, LoginRouteModule, ReactiveFormsModule, RouterModule, UrlModule]
    }]
  }], null, null);
})();
function getProductDetailsUrlMatcherFactory(service, defaultMatcherFactory) {
  const factory = (route) => {
    const defaultMatcher = defaultMatcherFactory(route);
    const suffixPDPMatcher = getSuffixUrlMatcher({
      marker: "p",
      paramName: "productCode"
    });
    return service.getCombined([defaultMatcher, suffixPDPMatcher]);
  };
  return factory;
}
var PRODUCT_DETAILS_URL_MATCHER = new InjectionToken("PRODUCT_DETAILS_URL_MATCHER", {
  providedIn: "root",
  factory: () => getProductDetailsUrlMatcherFactory(inject(UrlMatcherService), inject(DEFAULT_URL_MATCHER))
});
var _ProductDetailsPageModule = class _ProductDetailsPageModule {
};
_ProductDetailsPageModule.\u0275fac = function ProductDetailsPageModule_Factory(t) {
  return new (t || _ProductDetailsPageModule)();
};
_ProductDetailsPageModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductDetailsPageModule
});
_ProductDetailsPageModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    routing: {
      routes: {
        product: {
          matchers: [PRODUCT_DETAILS_URL_MATCHER]
        }
      }
    }
  })],
  imports: [RouterModule.forChild([{
    // @ts-ignore
    path: null,
    canActivate: [CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "product"
    }
  }])]
});
var ProductDetailsPageModule = _ProductDetailsPageModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductDetailsPageModule, [{
    type: NgModule,
    args: [{
      imports: [RouterModule.forChild([{
        // @ts-ignore
        path: null,
        canActivate: [CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "product"
        }
      }])],
      providers: [provideDefaultConfig({
        routing: {
          routes: {
            product: {
              matchers: [PRODUCT_DETAILS_URL_MATCHER]
            }
          }
        }
      })]
    }]
  }], null, null);
})();
function getProductListingUrlMatcherFactory(service, defaultMatcherFactory) {
  const factory = (route) => {
    const defaultMatcher = defaultMatcherFactory(route);
    const suffixPLPMatcher = getSuffixUrlMatcher({
      marker: "c",
      paramName: "categoryCode"
    });
    return service.getCombined([defaultMatcher, suffixPLPMatcher]);
  };
  return factory;
}
var PRODUCT_LISTING_URL_MATCHER = new InjectionToken("PRODUCT_LISTING_URL_MATCHER", {
  providedIn: "root",
  factory: () => getProductListingUrlMatcherFactory(inject(UrlMatcherService), inject(DEFAULT_URL_MATCHER))
});
var _ProductListingPageModule = class _ProductListingPageModule {
};
_ProductListingPageModule.\u0275fac = function ProductListingPageModule_Factory(t) {
  return new (t || _ProductListingPageModule)();
};
_ProductListingPageModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductListingPageModule
});
_ProductListingPageModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig({
    routing: {
      routes: {
        category: {
          matchers: [PRODUCT_LISTING_URL_MATCHER]
        }
      }
    }
  })],
  imports: [RouterModule.forChild([{
    // @ts-ignore
    path: null,
    canActivate: [CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      pageLabel: "search",
      cxRoute: "search"
    }
  }, {
    // @ts-ignore
    path: null,
    canActivate: [CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "brand"
    }
  }, {
    // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
    // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
    // @ts-ignore
    path: null,
    canActivate: [CmsPageGuard],
    component: PageLayoutComponent,
    data: {
      cxRoute: "category"
    }
  }])]
});
var ProductListingPageModule = _ProductListingPageModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductListingPageModule, [{
    type: NgModule,
    args: [{
      imports: [RouterModule.forChild([{
        // @ts-ignore
        path: null,
        canActivate: [CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          pageLabel: "search",
          cxRoute: "search"
        }
      }, {
        // @ts-ignore
        path: null,
        canActivate: [CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "brand"
        }
      }, {
        // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
        // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
        // @ts-ignore
        path: null,
        canActivate: [CmsPageGuard],
        component: PageLayoutComponent,
        data: {
          cxRoute: "category"
        }
      }])],
      providers: [provideDefaultConfig({
        routing: {
          routes: {
            category: {
              matchers: [PRODUCT_LISTING_URL_MATCHER]
            }
          }
        }
      })]
    }]
  }], null, null);
})();
var _RoutingContextService = class _RoutingContextService {
  constructor(activatedRoutesService, injector) {
    this.activatedRoutesService = activatedRoutesService;
    this.injector = injector;
    this.contextTokenMapping$ = this.activatedRoutesService.routes$.pipe(map((routes) => this.getRoutesContextTokenMapping(routes)), shareReplay({
      refCount: true,
      bufferSize: 1
    }));
  }
  /**
   * Returns the merged context token mapping, consisting of mappings
   * defined in all Activated Angular Routes.
   */
  getRoutesContextTokenMapping(routes) {
    return Object.assign({}, ...routes.map((route) => route?.data?.cxContext));
  }
  /**
   * Resolves the specified `contextToken` from `cxContext` data parameter of the activated Angular Routes.
   * @param contextToken
   *
   * @returns instance from the root injector if defined, otherwise `undefined`.
   */
  get(contextToken) {
    return this.contextTokenMapping$.pipe(switchMap((contextMapping) => {
      const providerToken = contextMapping?.[contextToken];
      return !!providerToken ? this.injector.get(providerToken) : of(void 0);
    }));
  }
};
_RoutingContextService.\u0275fac = function RoutingContextService_Factory(t) {
  return new (t || _RoutingContextService)(\u0275\u0275inject(ActivatedRoutesService), \u0275\u0275inject(UnifiedInjector));
};
_RoutingContextService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RoutingContextService,
  factory: _RoutingContextService.\u0275fac,
  providedIn: "root"
});
var RoutingContextService = _RoutingContextService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutingContextService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ActivatedRoutesService
  }, {
    type: UnifiedInjector
  }], null);
})();
var _ContextService = class _ContextService {
  constructor(routingContextService) {
    this.routingContextService = routingContextService;
  }
  /**
   * Returns the context for the given token.
   */
  get(contextToken) {
    return this.resolveContext(contextToken).pipe(distinctUntilChanged(), shareReplay({
      refCount: true,
      bufferSize: 1
    }));
  }
  /**
   * Resolves the context for the given token.
   */
  resolveContext(contextToken) {
    return this.routingContextService.get(contextToken);
  }
};
_ContextService.\u0275fac = function ContextService_Factory(t) {
  return new (t || _ContextService)(\u0275\u0275inject(RoutingContextService));
};
_ContextService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ContextService,
  factory: _ContextService.\u0275fac,
  providedIn: "root"
});
var ContextService = _ContextService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RoutingContextService
  }], null);
})();
var _NavigationEvent = class _NavigationEvent extends CxEvent {
};
_NavigationEvent.type = "NavigationEvent";
var NavigationEvent = _NavigationEvent;
var PageEvent = class extends CxEvent {
};
var _HomePageEvent = class _HomePageEvent extends PageEvent {
};
_HomePageEvent.type = "HomePageEvent";
var HomePageEvent = _HomePageEvent;
var _HomePageEventBuilder = class _HomePageEventBuilder {
  constructor(eventService) {
    this.eventService = eventService;
    this.register();
  }
  register() {
    this.eventService.register(HomePageEvent, this.buildHomePageEvent());
  }
  buildHomePageEvent() {
    return this.eventService.get(NavigationEvent).pipe(filter((navigationEvent) => navigationEvent.semanticRoute === "home"), map((navigationEvent) => createFrom(HomePageEvent, {
      navigation: navigationEvent
    })));
  }
};
_HomePageEventBuilder.\u0275fac = function HomePageEventBuilder_Factory(t) {
  return new (t || _HomePageEventBuilder)(\u0275\u0275inject(EventService));
};
_HomePageEventBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HomePageEventBuilder,
  factory: _HomePageEventBuilder.\u0275fac,
  providedIn: "root"
});
var HomePageEventBuilder = _HomePageEventBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HomePageEventBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: EventService
  }], null);
})();
var _HomePageEventModule = class _HomePageEventModule {
  constructor(_homePageEventBuilder) {
  }
};
_HomePageEventModule.\u0275fac = function HomePageEventModule_Factory(t) {
  return new (t || _HomePageEventModule)(\u0275\u0275inject(HomePageEventBuilder));
};
_HomePageEventModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _HomePageEventModule
});
_HomePageEventModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var HomePageEventModule = _HomePageEventModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HomePageEventModule, [{
    type: NgModule,
    args: [{}]
  }], () => [{
    type: HomePageEventBuilder
  }], null);
})();
var _NavigationEventBuilder = class _NavigationEventBuilder {
  constructor(actions, eventService) {
    this.actions = actions;
    this.eventService = eventService;
    this.register();
  }
  /**
   * Registers events
   */
  register() {
    this.eventService.register(NavigationEvent, this.buildNavigationEvent());
  }
  /**
   * Builds the navigation events
   */
  buildNavigationEvent() {
    return this.getNavigatedEvent().pipe(map((state) => createFrom(NavigationEvent, {
      context: state.context,
      semanticRoute: state.semanticRoute,
      url: state.url,
      params: state.params
    })));
  }
  getNavigatedEvent() {
    return this.actions.pipe(ofType(ROUTER_NAVIGATED), map((event) => event.payload.routerState));
  }
};
_NavigationEventBuilder.\u0275fac = function NavigationEventBuilder_Factory(t) {
  return new (t || _NavigationEventBuilder)(\u0275\u0275inject(ActionsSubject), \u0275\u0275inject(EventService));
};
_NavigationEventBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NavigationEventBuilder,
  factory: _NavigationEventBuilder.\u0275fac,
  providedIn: "root"
});
var NavigationEventBuilder = _NavigationEventBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationEventBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ActionsSubject
  }, {
    type: EventService
  }], null);
})();
var _NavigationEventModule = class _NavigationEventModule {
  constructor(_navigationEventBuilder) {
  }
};
_NavigationEventModule.\u0275fac = function NavigationEventModule_Factory(t) {
  return new (t || _NavigationEventModule)(\u0275\u0275inject(NavigationEventBuilder));
};
_NavigationEventModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NavigationEventModule
});
_NavigationEventModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NavigationEventModule = _NavigationEventModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationEventModule, [{
    type: NgModule,
    args: [{}]
  }], () => [{
    type: NavigationEventBuilder
  }], null);
})();
var _ProductDetailsPageEvent = class _ProductDetailsPageEvent extends PageEvent {
};
_ProductDetailsPageEvent.type = "ProductDetailsPageEvent";
var ProductDetailsPageEvent = _ProductDetailsPageEvent;
var _CategoryPageResultsEvent = class _CategoryPageResultsEvent extends PageEvent {
};
_CategoryPageResultsEvent.type = "CategoryPageResultsEvent";
var CategoryPageResultsEvent = _CategoryPageResultsEvent;
var _SearchPageResultsEvent = class _SearchPageResultsEvent extends PageEvent {
};
_SearchPageResultsEvent.type = "SearchPageResultsEvent";
var SearchPageResultsEvent = _SearchPageResultsEvent;
var _ProductPageEventBuilder = class _ProductPageEventBuilder {
  constructor(eventService, productService, productSearchService) {
    this.eventService = eventService;
    this.productService = productService;
    this.productSearchService = productSearchService;
    this.register();
  }
  register() {
    this.eventService.register(SearchPageResultsEvent, this.buildSearchPageResultsEvent());
    this.eventService.register(ProductDetailsPageEvent, this.buildProductDetailsPageEvent());
    this.eventService.register(CategoryPageResultsEvent, this.buildCategoryResultsPageEvent());
  }
  buildProductDetailsPageEvent() {
    return this.eventService.get(NavigationEvent).pipe(filter((navigationEvent) => navigationEvent.semanticRoute === "product"), switchMap((navigationEvent) => this.productService.get(navigationEvent.context.id).pipe(filter((product) => Boolean(product)), take(1), map((product) => createFrom(ProductDetailsPageEvent, {
      navigation: navigationEvent,
      categories: product?.categories,
      code: product?.code,
      name: product?.name,
      price: product?.price
    })))));
  }
  buildCategoryResultsPageEvent() {
    const searchResults$ = this.productSearchService.getResults().pipe(
      // skipping the initial value, and preventing emission of the previous search state
      skip(1)
    );
    return this.eventService.get(NavigationEvent).pipe(switchMap((navigationEvent) => {
      if (navigationEvent?.semanticRoute !== "category") {
        return EMPTY;
      }
      return searchResults$.pipe(map((searchResults) => createFrom(CategoryPageResultsEvent, __spreadValues({
        navigation: navigationEvent
      }, {
        categoryCode: navigationEvent?.context?.id,
        numberOfResults: searchResults?.pagination?.totalResults ?? 0,
        categoryName: searchResults.breadcrumbs?.[0].facetValueName
      }))));
    }));
  }
  buildSearchPageResultsEvent() {
    const searchResults$ = this.productSearchService.getResults().pipe(
      // skipping the initial value, and preventing emission of the previous search state
      skip(1)
    );
    return this.eventService.get(NavigationEvent).pipe(switchMap((navigationEvent) => {
      if (navigationEvent?.semanticRoute !== "search") {
        return EMPTY;
      }
      return searchResults$.pipe(map((searchResults) => createFrom(SearchPageResultsEvent, __spreadValues({
        navigation: navigationEvent
      }, {
        searchTerm: searchResults?.freeTextSearch ?? "",
        numberOfResults: searchResults?.pagination?.totalResults ?? 0
      }))));
    }));
  }
};
_ProductPageEventBuilder.\u0275fac = function ProductPageEventBuilder_Factory(t) {
  return new (t || _ProductPageEventBuilder)(\u0275\u0275inject(EventService), \u0275\u0275inject(ProductService), \u0275\u0275inject(ProductSearchService));
};
_ProductPageEventBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ProductPageEventBuilder,
  factory: _ProductPageEventBuilder.\u0275fac,
  providedIn: "root"
});
var ProductPageEventBuilder = _ProductPageEventBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductPageEventBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: EventService
  }, {
    type: ProductService
  }, {
    type: ProductSearchService
  }], null);
})();
var _ProductPageEventModule = class _ProductPageEventModule {
  constructor(_productPageEventBuilder) {
  }
};
_ProductPageEventModule.\u0275fac = function ProductPageEventModule_Factory(t) {
  return new (t || _ProductPageEventModule)(\u0275\u0275inject(ProductPageEventBuilder));
};
_ProductPageEventModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ProductPageEventModule
});
_ProductPageEventModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var ProductPageEventModule = _ProductPageEventModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProductPageEventModule, [{
    type: NgModule,
    args: [{}]
  }], () => [{
    type: ProductPageEventBuilder
  }], null);
})();
var mediaConfig = {
  mediaFormats: {
    mobile: {
      width: 400
    },
    tablet: {
      width: 770
    },
    desktop: {
      width: 1140
    },
    widescreen: {
      width: 1400
    },
    // product media
    cartIcon: {
      width: 65
    },
    thumbnail: {
      width: 96
    },
    product: {
      width: 284
    },
    zoom: {
      width: 515
    }
  }
};
var layoutConfig = {
  // deferredLoading: {
  //   strategy: DeferLoadingStrategy.DEFER,
  //   intersectionMargin: '50px',
  // },
  layoutSlots: {
    header: {
      lg: {
        slots: ["PreHeader", "SiteContext", "SiteLinks", "SiteLogo", "SearchBox", "SiteLogin", "MiniCart", "NavigationBar"]
      },
      slots: ["PreHeader", "SiteLogo", "SearchBox", "MiniCart"]
    },
    navigation: {
      lg: {
        slots: []
      },
      slots: ["SiteLogin", "NavigationBar", "SiteContext", "SiteLinks"]
    },
    footer: {
      slots: ["Footer"]
    },
    LandingPage2Template: {
      pageFold: "Section2B",
      slots: ["Section1", "Section2A", "Section2B", "Section2C", "Section3", "Section4", "Section5"]
    },
    ContentPage1Template: {
      slots: ["Section2A", "Section2B"]
    },
    CategoryPageTemplate: {
      pageFold: "Section2",
      slots: ["Section1", "Section2", "Section3"]
    },
    ProductListPageTemplate: {
      slots: ["ProductLeftRefinements", "ProductListSlot"]
    },
    ProductGridPageTemplate: {
      slots: ["ProductLeftRefinements", "ProductGridSlot"]
    },
    SearchResultsListPageTemplate: {
      slots: ["Section2", "ProductLeftRefinements", "SearchResultsListSlot", "Section4"]
    },
    SearchResultsGridPageTemplate: {
      slots: ["Section2", "ProductLeftRefinements", "SearchResultsGridSlot", "Section4"]
    },
    ProductDetailsPageTemplate: {
      lg: {
        pageFold: "UpSelling"
      },
      pageFold: "Summary",
      slots: ["Summary", "UpSelling", "CrossSelling", "Tabs", "PlaceholderContentSlot"]
    },
    CartPageTemplate: {
      slots: ["TopContent", "CenterRightContentSlot", "EmptyCartMiddleContent"]
    },
    AccountPageTemplate: {
      slots: ["BodyContent", "SideContent"]
    },
    LoginPageTemplate: {
      slots: ["LeftContentSlot", "RightContentSlot"]
    },
    ErrorPageTemplate: {
      slots: ["TopContent", "MiddleContent", "BottomContent"]
    },
    OrderConfirmationPageTemplate: {
      slots: ["BodyContent", "SideContent"]
    },
    MultiStepCheckoutSummaryPageTemplate: {
      slots: ["TopContent", "BodyContent", "SideContent", "BottomContent"]
    },
    CheckoutLoginPageTemplate: {
      slots: ["RightContentSlot"]
    },
    MyAccountViewPageTemplate: {
      slots: ["LeftContentSlot", "RightContentSlot"]
    }
  }
};
var defaultCmsContentProviders = [provideCmsStructure({
  componentId: "HamburgerMenuComponent",
  pageSlotPosition: "PreHeader"
}), provideCmsStructure({
  componentId: "LoginComponent",
  pageSlotPosition: "SiteLogin"
})];
var defaultOnNavigateConfig = {
  enableResetViewOnNavigate: {
    active: true,
    ignoreQueryString: false,
    ignoreRoutes: []
  }
};
var _OnNavigateConfig = class _OnNavigateConfig {
};
_OnNavigateConfig.\u0275fac = function OnNavigateConfig_Factory(t) {
  return new (t || _OnNavigateConfig)();
};
_OnNavigateConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _OnNavigateConfig,
  factory: function OnNavigateConfig_Factory(t) {
    let r = null;
    if (t) {
      r = new (t || _OnNavigateConfig)();
    } else {
      r = \u0275\u0275inject(Config);
    }
    return r;
  },
  providedIn: "root"
});
var OnNavigateConfig = _OnNavigateConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OnNavigateConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: Config
    }]
  }], null, null);
})();
var _OnNavigateService = class _OnNavigateService {
  get hostComponent() {
    return this.injector.get(ApplicationRef)?.components?.[0];
  }
  constructor(config, router, viewportScroller, injector) {
    this.config = config;
    this.router = router;
    this.viewportScroller = viewportScroller;
    this.injector = injector;
  }
  /**
   * Reads configuration and enables features based on flags set.
   */
  initializeWithConfig() {
    if (this.config?.enableResetViewOnNavigate?.active) {
      this.setResetViewOnNavigate(this.config.enableResetViewOnNavigate.active);
    }
  }
  /**
   * Resets view back to the original position when performing a back navigation and to the top when performing a front navigation
   * and sets the focus back to the top of the page before skiplinks for any type of navigation
   * @param enable Enable or disable this feature
   */
  setResetViewOnNavigate(enable) {
    this.subscription?.unsubscribe();
    if (enable) {
      this.viewportScroller.setHistoryScrollRestoration("manual");
      this.subscription = this.router.events.pipe(filter((event) => event instanceof Scroll), pairwise()).subscribe((event) => {
        const previousRoute = event[0];
        const currentRoute = event[1];
        const position = currentRoute.position;
        if (position) {
          setTimeout(() => this.viewportScroller.scrollToPosition(position));
        } else {
          if (this.config.enableResetViewOnNavigate?.ignoreQueryString && this.isPathEqual(previousRoute, currentRoute)) {
            return;
          }
          if (this.isChildRoute(currentRoute)) {
            return;
          }
          setTimeout(() => this.viewportScroller.scrollToPosition([0, 0]), 100);
        }
        this.hostComponent?.location?.nativeElement.focus();
      });
    }
  }
  /**
   * Verifies if the current route is a child route from the given ignore config route
   *
   * @param route
   * @returns boolean whether the route is a child route
   */
  isChildRoute(route) {
    return this.config.enableResetViewOnNavigate?.ignoreRoutes?.some((configRoute) => this.isNavigationEnd(route.routerEvent) && route.routerEvent.urlAfterRedirects.split("/").includes(configRoute)) ?? false;
  }
  /**
   * Verifies if the previous and current route are the same without the query string
   *
   * @param previousRoute
   * @param currentRoute
   * @returns boolean depending on the previous and current route are equal without the query strings
   */
  isPathEqual(previousRoute, currentRoute) {
    if (!this.isNavigationEnd(previousRoute.routerEvent) || !this.isNavigationEnd(currentRoute.routerEvent)) {
      return false;
    }
    return previousRoute.routerEvent.urlAfterRedirects.split("?")[0] === currentRoute.routerEvent.urlAfterRedirects.split("?")[0];
  }
  /**
   * Verifies if router event is a navigation end event
   * @private
   */
  isNavigationEnd(event) {
    return event.type === 1;
  }
};
_OnNavigateService.\u0275fac = function OnNavigateService_Factory(t) {
  return new (t || _OnNavigateService)(\u0275\u0275inject(OnNavigateConfig), \u0275\u0275inject(Router), \u0275\u0275inject(ViewportScroller), \u0275\u0275inject(Injector));
};
_OnNavigateService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _OnNavigateService,
  factory: _OnNavigateService.\u0275fac,
  providedIn: "root"
});
var OnNavigateService = _OnNavigateService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OnNavigateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: OnNavigateConfig
  }, {
    type: Router
  }, {
    type: ViewportScroller
  }, {
    type: Injector
  }], null);
})();
var _AppRoutingModule = class _AppRoutingModule {
};
_AppRoutingModule.\u0275fac = function AppRoutingModule_Factory(t) {
  return new (t || _AppRoutingModule)();
};
_AppRoutingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _AppRoutingModule
});
_AppRoutingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideDefaultConfig(defaultOnNavigateConfig), {
    provide: APP_INITIALIZER,
    useFactory: onNavigateFactory,
    deps: [OnNavigateService],
    multi: true
  }],
  imports: [RouterModule.forRoot([], {
    anchorScrolling: "enabled",
    initialNavigation: "enabledBlocking"
  })]
});
var AppRoutingModule = _AppRoutingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppRoutingModule, [{
    type: NgModule,
    args: [{
      imports: [RouterModule.forRoot([], {
        anchorScrolling: "enabled",
        initialNavigation: "enabledBlocking"
      })],
      providers: [provideDefaultConfig(defaultOnNavigateConfig), {
        provide: APP_INITIALIZER,
        useFactory: onNavigateFactory,
        deps: [OnNavigateService],
        multi: true
      }]
    }]
  }], null, null);
})();
function onNavigateFactory(onNavigateService) {
  const isReady = () => onNavigateService.initializeWithConfig();
  return isReady;
}
var FormUtils;
(function(FormUtils2) {
  function deepUpdateValueAndValidity(control, options = {}) {
    if (control instanceof UntypedFormGroup || control instanceof UntypedFormArray) {
      Object.values(control.controls).forEach((childControl) => {
        deepUpdateValueAndValidity(childControl, options);
      });
    }
    control.updateValueAndValidity({
      onlySelf: true,
      emitEvent: options.emitEvent
    });
  }
  FormUtils2.deepUpdateValueAndValidity = deepUpdateValueAndValidity;
})(FormUtils || (FormUtils = {}));
function getAddressNumbers(address, textPhone, textMobile) {
  if (address.cellphone && address.phone) {
    if (address.cellphone === address.phone) {
      return textMobile + ": " + address.cellphone;
    }
    return `${textPhone}: ${address.phone}
${textMobile}: ${address.cellphone}`;
  }
  if (address.cellphone) {
    return textMobile + ": " + address.cellphone;
  }
  if (address.phone) {
    return textPhone + ": " + address.phone;
  }
  return void 0;
}
var _BaseStorefrontModule = class _BaseStorefrontModule {
};
_BaseStorefrontModule.\u0275fac = function BaseStorefrontModule_Factory(t) {
  return new (t || _BaseStorefrontModule)();
};
_BaseStorefrontModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BaseStorefrontModule
});
_BaseStorefrontModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [BaseCoreModule.forRoot(), RouterModule, GlobalMessageComponentModule, OutletModule, OutletRefModule, PwaModule, PageLayoutModule, SeoModule, PageComponentModule.forRoot(), PageSlotModule, SkipLinkModule, KeyboardFocusModule, LayoutModule, RoutingModule2.forRoot(), MediaModule.forRoot(), OutletModule.forRoot(), StorefrontComponentModule, LayoutModule, StorefrontComponentModule]
});
var BaseStorefrontModule = _BaseStorefrontModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseStorefrontModule, [{
    type: NgModule,
    args: [{
      imports: [BaseCoreModule.forRoot(), RouterModule, GlobalMessageComponentModule, OutletModule, OutletRefModule, PwaModule, PageLayoutModule, SeoModule, PageComponentModule.forRoot(), PageSlotModule, SkipLinkModule, KeyboardFocusModule, LayoutModule, RoutingModule2.forRoot(), MediaModule.forRoot(), OutletModule.forRoot(), StorefrontComponentModule],
      exports: [LayoutModule, StorefrontComponentModule]
    }]
  }], null, null);
})();

export {
  CheckboxControlValueAccessor,
  DefaultValueAccessor,
  Validators,
  NgControlStatus,
  NgControlStatusGroup,
  UntypedFormGroup,
  NgForm,
  FormControl,
  UntypedFormControl,
  NgModel,
  ɵNgNoValidate,
  NumberValueAccessor,
  RadioControlValueAccessor,
  FormControlDirective,
  FormGroupDirective,
  FormGroupName,
  FormArrayName,
  FormControlName,
  RequiredValidator,
  CheckboxRequiredValidator,
  FormBuilder,
  UntypedFormBuilder,
  FormsModule,
  ReactiveFormsModule,
  NgOptionComponent,
  NgSelectComponent,
  NgSelectModule,
  FocusDirective,
  KeyboardFocusModule,
  DIALOG_TYPE,
  BREAKPOINT,
  LaunchDialogService,
  OutletPosition,
  OutletContextData,
  OutletService,
  OutletDirective,
  provideOutlet,
  OutletModule,
  ICON_TYPE,
  DirectionMode,
  IconComponent,
  IconModule,
  SpinnerComponent,
  AnonymousConsentManagementBannerModule,
  PAGE_LAYOUT_HANDLER,
  BreakpointService,
  CmsComponentData,
  PageSlotComponent,
  PageLayoutComponent,
  CmsPageGuard,
  InnerComponentsHostDirective,
  PageComponentModule,
  PageSlotModule,
  AddToHomeScreenBannerComponent,
  PwaModule,
  CurrentProductService,
  CarouselComponent,
  SpinnerModule,
  ConsentManagementModule,
  AnonymousConsentsDialogModule,
  AtMessageDirective,
  CardComponent,
  AtMessageModule,
  CardModule,
  MediaComponent,
  MediaModule,
  CarouselModule,
  FormErrorsComponent,
  FormErrorsModule,
  DatePickerModule,
  FileUploadComponent,
  FileUploadModule,
  PasswordVisibilityToggleDirective,
  PasswordVisibilityToggleModule,
  ItemCounterComponent,
  ItemCounterModule,
  NgSelectA11yDirective,
  SortingComponent,
  NgSelectA11yModule,
  SortingModule,
  PaginationComponent,
  PaginationModule,
  ListNavigationModule,
  ProgressButtonComponent,
  ProgressButtonModule,
  MessageComponent,
  MessageComponentModule,
  PromotionsComponent,
  PromotionsModule,
  SiteContextSelectorModule,
  StarRatingComponent,
  StarRatingModule,
  FilesFormValidators,
  BannerCarouselModule,
  BannerModule,
  LinkModule,
  CmsParagraphModule,
  PDFModule,
  TabParagraphContainerModule,
  VideoModule,
  DirectionService,
  HamburgerMenuModule,
  StorefrontComponent,
  MyCouponsModule,
  MyInterestsModule,
  NotificationPreferenceModule,
  PaymentMethodsModule,
  BreadcrumbModule,
  NavigationModule,
  CategoryNavigationModule,
  FooterNavigationModule,
  PageTitleModule,
  SearchBoxModule,
  ScrollToTopModule,
  MyAccountV2Module,
  ProductListOutlets,
  ProductListItemContext,
  ProductListItemContextSource,
  ProductFacetNavigationModule,
  FileDownloadService,
  ExportCsvFileService,
  ImportCsvFileService,
  CustomFormValidators,
  sortTitles,
  ProductListModule,
  ProductCarouselModule,
  ProductReferencesModule,
  ProductImagesComponent,
  ProductImagesModule,
  ProductIntroModule,
  ProductSummaryModule,
  ProductTabsModule,
  StockNotificationModule,
  LoginRouteModule,
  LogoutModule,
  ProductDetailsPageModule,
  ProductListingPageModule,
  ContextService,
  NavigationEvent,
  PageEvent,
  HomePageEventModule,
  NavigationEventModule,
  ProductPageEventModule,
  mediaConfig,
  layoutConfig,
  defaultCmsContentProviders,
  AppRoutingModule,
  FormUtils,
  getAddressNumbers,
  BaseStorefrontModule
};
/*! Bundled license information:

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v17.3.3
   * (c) 2010-2022 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/service-worker/fesm2022/service-worker.mjs:
  (**
   * @license Angular v17.3.3
   * (c) 2010-2022 Google LLC. https://angular.io/
   * License: MIT
   *)
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
*/
//# sourceMappingURL=chunk-JOGQIABG.mjs.map
